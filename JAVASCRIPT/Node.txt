
	NODE:
_______________________________________________________

INDICE:

[1]. Qué es Node
[2]. Qué es npm
[3]. Instalación
[4]. Iniciar proyecto Node
[5]. Instalar Dependencias
	[5.1]. Dependencias de desarrollo
		[5.1.1]. "nodemon"
		[5.1.2]. "pm2"
[6]. Variables de entorno
[7]. Qué es "express"
	[7.1]. Archivo base de "express"
	[7.2]. Habilitar modulos
	[7.3]. "Hola mundo!" en "express"
	[7.4]. "Routing" en "express"
		[7.4.1]. Métodos HTTP
		[7.4.2]. Peticiones GET y POST
	[7.5]. Template engines
		[7.5.1]. Instalando PUG
		[7.5.2]. Pasar variables hacia las vistas
		[7.5.3]. Crear Layout principal
	[7.6]. Servir archivos estáticos
	[7.7]. "middleware"
	[7.8]. "Controllers"
	[7.9]. ORM's y Bases de Datos
		[7.9.1]. Sequelize y MySQL
			[7.9.1.1]. Información de la BD en variables de entorno
			[7.9.1.2]. Modelo
			[7.9.1.3]. Comunicar vista con routing y controller
			[7.9.1.4]. Leer datos de un formulario
			[7.9.1.5]. Consultar la BD
				[7.9.1.5.1]. Limitar datos consulta
				[7.9.1.5.2]. Consultar la BD según URL
				[7.9.1.5.3]. Múltiples consultas
		[7.9.2]. Mongoose y MongoDB
			[7.9.2.1]. Información de la BD en variables de entorno
			[7.9.2.2]. Modelo
				[7.9.2.2.1]. Modelo con llave foránea
			[7.9.2.3]. Almacenar registros en la BD
				[7.9.2.3.1]. Validacion confirmar cuenta
				[7.9.2.3.2]. Hashear passwords de usuarios
					[7.9.2.3.2.1]. Hashear passwords con argon2
					[7.9.2.3.2.2]. Hashear passwords con bcrypt
			[7.9.2.4]. Consultar la BD
	[7.10]. JSON Web Token (JWT)
		[7.10.1]. Ejemplo JWT
		[7.10.2]. Bearer token
			[7.10.2.1]. Crear rutas protegidas - Middleware

_______________________________________________________

	[1]. Qué es Node:
_______________________________________________________

Es un entorno de código abierto multiplataforma, que permite crear aplicaciones del lado del servidor en JavaScript.

Permite crear APIS, aplicaciones web e incluso acceder a archivos y leer sus contenidos.

Ventajas: velocidad y rendimiento, excelente para aplicaciones en tiempo real.

_______________________________________________________

	[2]. Qué es npm:
_______________________________________________________

"npm" o Node Package Manager, es una gran cantidad de paquetes y librerias de código abierto, ya listos para ser utilizados, entrte ellos paquetes para subir archivos, autenticación de usuarios, enviar emails, template engines, seguridad, etc.

Para ver la versión de "npm" instalada usamos:

	npm -v
_______________________________________________________

	[3]. Instalación:
_______________________________________________________

1) Para instalar Node:

	https://nodejs.org/es/

Nota: Se recomienda la versión LTS(Long Term Service).

2) Luego en consola (windows cmd o powershell), escribimos el comando:

	node -v

Esto nos mostrara la version de Node instalada.

Si queremos ejecutar codigo JavaScript en la conmsola de node escribimos:

	node

Y luego el codigo JavaScript como:

	console.log("Hola!!!");
_______________________________________________________

	[4]. Iniciar proyecto Node:
_______________________________________________________

1) Crear una carpeta para el proyecto, para el nombre del proyecto, seguimos las siguientes recomendaciones:

	A) Utiliza siempre minúsculas.
	B) No utilices espacios en el nombre. Usa guiones en su lugar.
	C) Evita el uso de carácteres especiales, signos de puntuación, etc...

2) Para llevar el control de versiones del proyecto con "Git", en consola de comandos, nos ubicamos en la carpeta del proyecto y usamos el comando:

	git init

Luego añadimos la URL de GitHub (u otro servicio) como repositorio remoto:

	git remote add origin https://github.com/landinezrichard/backend.git

Creamos un archivo ".gitignore", para ignorar archivos y carpetas que no se deben subir a github (Como la carpeta node_modules, ya que allí van las dependencias del proyecto y no se deben subir a github, ya que estas dependencias son binarios y su compilación depende del sistema operativo):

	node_modules
	*.log

Nota: tambien podemos crear el archivo ".gitignore", con una herramienta online:

	https://www.toptal.com/developers/gitignore

3) En la consola, ubicados en la carpeta del proyecto, escribimos el comando "npm init", el cual va a crear el archivo "package.json":

	npm init

El comando "npm init", hará algunas preguntas iniciales sobre nuestro proyecto:

	name: nombreproyecto
	version: 1.0
	description: Api RESTful para frameworks JavaScript
	entry point: index.js
	test comand:
	git repository:
	keywords: 
	autor: Ricardo Landínez <landinezrichard@gmail.com>
	license: BSD

Nota: en licencia tambien pódemos usar ISC, MIT.

IMPORTANTE: para que npm init no falle al momento del nombre del proyecto, no usar letras mayusculas, no usar espacios, evitar el uso de carácteres especiales, signos de puntuación, etc..

Tambien podemos iniciarlo con todo en default con:

	npm init -y

_______________________________________________________

	[5]. Instalar Dependencias:
_______________________________________________________

Podremos instalar paquetes de NPM en nuestros proyectos y/o en nuestro sistema. Se pueden instalar de dos formas:

- A nivel de proyecto: usar NPM como un gestor de dependencias de un proyecto, esto es, un sistema con el que controlamos que paquetes o librerías Javascript están instalados (y que versión), de modo que quedan asociados al proyecto en sí. Esto facilita que si un usuario diferente se descarga el proyecto, pueda gestionarlo fácil y rápidamente (instalar paquetes, actualizarlos, etc...).

- A nivel global: hay paquetes que son realmente utilidades que no se utilizan en proyectos, muy común en aplicaciones de línea de comandos (CLI) que usamos desde terminal. En esta modalidad, los paquetes se instalan a nivel del sistema (no en la carpeta del proyecto), por lo que están disponibles siempre que el usuario quiera utilizarlos, sin necesidad de tenerlo en cada proyecto.

Nota: para ver comandos de instalación de paquetes globales ir a:

	https://lenguajejs.com/npm/introduccion/instalaciones-globales/
_______________________________________________________

En este caso vamos a instalar paquetes a nivel de proyecto. Nos ubicamos dentro de la carpeta del proyecto, y usamos los comandos:

	npm install --save express

Con el flag "--save", indicamos que es una dependencia de nuestro proyecto, es decir, que el proyecto necesita la libreria para funcionar. Tambien hace que en el archivo "package.json" se grabe como dependencia y aparezca la versión instalada.

Tambien podemos ahorrarnos escribir todo el "install", y si no usamos el flag "--save", igual se instala como dependencia:

	npm i express

En nuestra carpeta de proyecto, aparece una carpeta llamada "node-modules", que es donde se descargan las librerias instaladas y las dependencias de estas.

Nota 1: para buscar algun paquete o ver más información de los paquetes:

	https://www.npmjs.com/

Nota 2: Si descargamos algun proyecto de otra persona, y necesitamos instalar sus dependencias (el proyecto debe tener el archivo "package.json"), usamos el comando:

	npm install
_______________________________________________________

	[5.1]. Dependencias de desarrollo:
_______________________________________________________

Podemos instalar dependencias de desarrollo (las que no se necesitan en producción), con el flag "--save-dev":

	npm install --save-dev nodemon

Para ahorrarnos escribir todo el flag "--save-dev":

	npm i -D nodemon

_______________________________________________________

	[5.1.1]. "nodemon":
_______________________________________________________

"nodemon" es una herramienta que ayuda a desarrollar aplicaciones basadas en node.js al reiniciar automáticamente la aplicación de node cuando se detectan cambios de archivo en el directorio.

	npm install --save-dev nodemon

Tambien se puede instalar de forma global:

    npm install -g nodemon

Luego ejecutamos en consola:

    nodemon index.js

Para usar "nodemon", agregamos un nuevo script al archivo "package.json":

	"scripts": {
		"dev": "nodemon index.js",
		"start": "node index.js"
	},

Luego en la consola corremos el script con:

	npm dev

De esta forma, al hacer cambios en "index.js" (que se creara más adelante), se recarga automáticamente el script en ejecución, sin necesidad de pausarlo (ctrl + C) y volverlo a correr.
_______________________________________________________

	[5.1.2]. "pm2":
_______________________________________________________

Para tener algo similar a "nodemon" en producción usamos "pm2":

    https://pm2.keymetrics.io/

Para instalarlo:

    npm install -g pm2

Para ejecutar nuestras apps:

    pm2 start index.js

Para balancear 4 instancias de la app:

    pm2 start api.js -i 4

Este ultimo comando es muy util por ejemplo para una API, para crear una instancia por cada nucleo del procesador del servidor.

Para monitorizar la app:

    pm2 monitor

Para ver todas las apps que estan corriendo:

    pm2 status

Para ver los "logs":

    pm2 logs

Nota: para salir de ver los "logs" (ctrl + C).

Parar la app:

    pm2 stop id

Nota: el id del proceso de la app que esta corriendo es el que vemos con "pm2 status"

_______________________________________________________

	[6]. Variables de entorno:
_______________________________________________________

Las variables de entorno sirven para almacenar datos de configuración como claves de API, contraseñas o URLs, permitiendo adaptar el comportamiento de un programa sin modificar su código fuente. 

Esto facilita la gestión de aplicaciones en diferentes entornos (como desarrollo y producción), mejora la seguridad al mantener información sensible fuera del código y permite que un programa sea más flexible y portátil. 
_______________________________________________________

Si tenemos un archivo, por ejemplo, "index.js", en donde leemos variables de entorno:

    let nombre = process.env.NOMBRE || 'sin nombre';
    let web = process.env.MI_WEB || 'no tengo web';

    console.log('Hola ' + nombre);
    console.log('Mi web es ' + web);

Aca accedemos a las variables de entorno que se encuentran en "process".

Con el or "||" definimos un valor por defecto, en caso que desde la consola no definamos la variable de entorno imprimiria este valor, si no usamos el or, saca un undefined.

Para pasarle las variables de entorno a nuestro archivo desde consola usamos:

    NOMBRE=Ricardo MI_WEB=loquesea.com node index.js

En consola nos sale:

    Hola Ricardo
    Mi web es loquesea.com

Si ejecutamos sin pasarle variable:

    node index.js

Sale en consola:

    Hola sin nombre
    Mi web es no tengo web

Nota: en PowerShell hay que definir primero las variables de entorno:

    $env:NOMBRE="Ricardo"

Y luego ejecutar:

    node index.js
_______________________________________________________

	[7]. Qué es "express":
_______________________________________________________

Es el framework más popular de Node, es la herramienta sobre la cual están desarrollados otros frameworks como MEAN, SAILS, LOOPBACK, GRAPHQL YOGA y otros.

Soporta los diferentes verbos o acciones de HTTP (POST, GET, PUT, PATCH, DELETE) en las rutas (routing).

Permite creación de aplicaciones MVC (Modelo Vista Controlador) para separar y organizar el código.

Soporta Middlewares (peticiones que se ejecutan en la tuberia de la petición).

"express" es una libreria que nos proporciona herramientas pequeñas y sólidas para servidores HTTP, lo que la convierte en una gran solución para aplicaciones de una sola página, sitios web, híbridos o API HTTP públicas. Nos va a servir para crear las diferentes rutas de nuestro proyecto.

"express" es como "Apache" en PHP.

Lo instalamos con:

	npm install --save express
_______________________________________________________

	[7.1]. Archivo base de "express":
_______________________________________________________

En la raíz del proyecto creamos el archivo "index.js":

	const express = require('express');

	// Crear la app
	const app = express();

	// Definir puerto
	const PORT = process.env.PORT || 4000;

	// Arrancar la app
	app.listen(PORT, () => {
		console.log(`Servidor funcionando en el puerto ${PORT}`);
	});

Este archivo usa la sintaxis "CommonJs", que es con la que empezo Node y muchas de sus librerias.

En el puerto, definimos que en local use el puerto 4000, pero si la variable de entorno del puerto está disponible, la usa. Esto ya queda listo y con soporte tanto en desarrollo como en producción.

Al ejecutar en consola:

	npm run dev

Podemos ver el mensaje:

	Servidor funcionando en el puerto 4000

_______________________________________________________

	[7.2]. Habilitar modulos:
_______________________________________________________

Para cambiar la sintaxis de "CommonJs" y usar "imports" y "exports" (modulois ECMAScript), en el archivo "package.json" agregamos:

	"type": "module",

Y luego en nuestro archivo base de "express", "index.js":

	import express from "express";

_______________________________________________________

	[7.3]. "Hola mundo!" en "express":
_______________________________________________________

Completamos el archivo "index.js":

	import express from "express";

	const app = express();

	// Definir puerto
	const PORT = process.env.PORT || 4000;

	// Routing
	app.get("/", (req, res) => {
		res.send("Hello World!");
	});

	app.listen(PORT, () => {
		console.log(`Servidor funcionando en el puerto ${PORT}`);
	});

Acá usamos la acción "GET", el callback recibe un "req" ("request" o petición) y un "res" ("response" o respuesta).

"req" --> la petición que se envia al servidor.

"res" --> la respuesta de "express".

Podemos ver el "Hello World!" en el navegador, en la siguiente ruta:

	http://localhost:4000/

_______________________________________________________

Tambien podemos responder con JSON:

	app.get("/", (req, res) => {
		res.json({
			id: 1
		});
	});

_______________________________________________________

Y responder con el renderizado de una vista:

	app.get("/", (req, res) => {
		res.render('nombreVista');
	});

_______________________________________________________

	[7.4]. "Routing" en "express":
_______________________________________________________

El "Routing" es por donde van a transitar (los "endpoints", donde se registran, donde llenan el formulario, donde consulatar la información, etc.) los usuarios de nuestro sitio web o aplicación.

1) Podemos definir varias rutas:

	// Routing
	app.get("/", (req, res) => {
		res.send("Hello World!");
	});

	app.get("/nosotros", (req, res) => {
		res.send("Nosotros");
	});

	app.get("/contacto", (req, res) => {
		res.send("Contacto");
	});

2) Cuando ya tenemos varias rutas, lo mejor es separar el Routing en otro archivo, para esto, creamos una carpeta llamada "routes", y dentro de esta un archivo "index.js":

	import express from "express";

	const router = express.Router();

	router.get("/", (req, res) => {
		res.send("Hello World!");
	});

	router.get("/nosotros", (req, res) => {
		res.send("Nosotros");
	});

	router.get("/contacto", (req, res) => {
		res.send("Contacto");
	});

	export default router;

Importamos "express", pero solo usamos el "Router" de esté, ya que solo puede existir una instancia de "express".

Nota: el archivo "index.js" lo podemos nombrar como queramos, por ejemplo "usuarioRoutes.js".

3) Ahora en nuestro archivo principal, importamos y usamos el "router":

	import express from "express";
	import router from "./routes/index.js";

	// Crear la app
	const app = express();

	// Definir puerto
	const PORT = process.env.PORT || 4000;

	// Routing
	app.use("/", router);

	// Arrancar la app
	app.listen(PORT, () => {
		console.log(`Servidor funcionando en el puerto ${PORT}`);
	});

Aca el método "use", soporta todos los verbos o acciones HTTP(GET, POST, etc.), resuelve cualquier petición a "/", buscando en el archivo de "routing".

Nota: como el "router" es un archivo que nosotros creamos y no una dependencia, es necesario indicar la extensión y la ruta del archivo para importarlo.

Podemos probar las rutas en el navegador, por ejemplo:

	http://localhost:4000/nosotros

_______________________________________________________

	[7.4.1]. Métodos HTTP:
_______________________________________________________

Los métodos HTTP que usamos son:

- GET --> Utilizado para mostrar información.
- POST --> Utilizado para enviar información.
- PUT / PATCH --> Utilizado para actualizar información.
- DELETE --> Utilizado para eliminar información.
_______________________________________________________

	[7.4.2]. Peticiones GET y POST:
_______________________________________________________

Al crear las rutas, hay que tener en cuenta que una ruta(url) solo puede existir una vez (no se puesde repetir dos veses "/nosotros" por ejemplo), sin embargo, se puede tener la misma ruta con diferente acción:

	router.get("/", (req, res) => {
		res.send("Hello World!");
	});

	router.post("/", (req, res) => {
		res.send("Para recibir datos del formulario");
	});

Tambien podemos tener el mismo resultado de la siguiente forma:

	router.route('/')
		.get(function(req, res) => {
			res.send("Hello World!");
		})
		.post(function(req, res) => {
			res.send("Para recibir datos del formulario");
		})

_______________________________________________________

	[7.5]. Template engines:
_______________________________________________________

"Template Engines" o Motores de Plantilla son tecnologías que nos permiten 
crear el código HTML y mostrar información contenida en variables de una 
forma más compacta y clara.

Pug, Handlebars, EJS son las opciones más populares para Node.js.

También es posible utilizar React, Angular, Svelte o Vue como tu 
Template Engine, reemplazando a los "template engines" pero necesitarás crear una API con respuestas JSON. 
_______________________________________________________

	[7.5.1]. Instalando PUG:
_______________________________________________________

1) Instalamos PUG como depenedencia:

	npm i pug

2) En nuestro archivo principal "index.js", habilitamos PUG como "template engine":

	// Habilitar PUG
	app.set("view engine", "pug");

3) Creamos una carpeta llamada "views", y dentro de está un archivo para la vista llamado "nosotros.pug":

	h1 Nosotros

4) En el "router", renderizamos la vista en su respectiva "url", en el archivo "routes\index.js":

	router.get("/nosotros", (req, res) => {
		res.render('nosotros');
	});
_______________________________________________________

	[7.5.2]. Pasar variables hacia las vistas:
_______________________________________________________

Podemos pasar variables hacia las vistas, por ejemplo desde el router le pasamos un objeto a la vista:

	router.get("/nosotros", (req, res) => {
		const variable = "Algun valor";
		res.render('nosotros', { variable });
	});

Luego en la vista "views\nosotros.pug":

	h1 Nosotros
	p Aquí muestro los datos #{variable}.
_______________________________________________________

	[7.5.3]. Crear Layout principal:
_______________________________________________________

Podemos crear un Layout principal, con el titulo de la página, el llamado a las hojas de estilos, etc, para poder reutilizarlo.

1) Creamos una carpeta llamada "layout" dentro de la carpeta "views".

2) Creamos dentro de la carpeta "layout" un archivo "index.pug":

	doctype html
	html(lang="es")
		head
			meta(charset="utf-8")
			meta(name="viewport", content="width=device-width, initial-scale=1, maximum-scale=1")
			title Agencia de Viajes
		body
			h1 Agencia de Viajes
			block contenido

3) Usamos el layout en el archivo "views\nosotros.pug":

	extends layout/index.pug

	block contenido
		p Nosotros

_______________________________________________________

	[7.6]. Servir archivos estáticos:
_______________________________________________________

Podemos servir archivos estáticos en "express", como archivos CSS, imagenes, fuentes, etc.

1) Creamos en la raíz del proyecto una carpeta llamada "public".

2) Dentro de la carpeta "public", creamos las carpetas "css", "img", "fonts", etc. con sus respectivos archivos.

3) En el archivo principal "index.js", definimos la carpeta "public":

	// Definir la carpeta publica
	app.use(express.static("public"));

4) Ya podemos usar archivos estaticos en las vistas:

	doctype html
	html(lang="es")
		head
			meta(charset="utf-8")
			meta(name="viewport", content="width=device-width, initial-scale=1, maximum-scale=1")
			title Agencia de Viajes
			link(rel='preconnect' href='https://fonts.googleapis.com')
			link(rel='preconnect' href='https://fonts.gstatic.com' crossorigin='')
			link(href='https://fonts.googleapis.com/css2?family=Covered+By+Your+Grace&family=Staatliches&display=swap' rel='stylesheet')
			link(rel="stylesheet", href="/css/bootstrap.css")
			link(rel="stylesheet", href="/css/style.css")
		body
			h1 Agencia de Viajes
			img(src="/img/cupon.jpg", alt="Cupon Agencia de Viajes")
			block contenido

_______________________________________________________

	[7.7]. "middleware":
_______________________________________________________

Un "middleware" actúa como una capa intermedia entre la solicitud del cliente y las rutas finales de la aplicación. Funcionan como un puente entre el servidor y la aplicación, interceptando y manipulando la solicitud antes de que se envíe a su destino final.

En el archivo principal "index.js":

	import express from "express";
	import router from "./routes/index.js";

	// Crear la app
	const app = express();

	// Definir puerto
	const PORT = process.env.PORT || 4000;

	// Habilitar PUG
	app.set("view engine", "pug");

	// Definir la carpeta publica
	app.use(express.static("public"));

	// Routing
	app.use("/", router);

	// Arrancar la app
	app.listen(PORT, () => {
		console.log(`Servidor funcionando en el puerto ${PORT}`);
	});

Cada "app.set", "app.use" y "app.listen" son "middlewares".

Podemos crear un "middleware" propio:

	// Obtener el año actual
	app.use( (req, res, next) => {
		const year = new Date();
		res.locals.actualYear = year.getFullYear();
		next();
	});

Vemos que en el callback, además del "req" ("request") y el "res" ("response"), resive un "next", que es con lo que le indicamos que, despues de realizar los calculos o lo que queramos, ya puede pasar al siguiente "middleware".

Nota: si no pasa al siguiente "middleware", podemos forzarlo con:

	return next();

"locals", es un objeto con variables internas de "express", y nos permite pasar valores de un archivo a la vista o de un archivo a otro.

Luego usamos nuestra variable en la vista:

	p.copyright.text-center.text-md-right &copy; Todos los derechos reservados. #{actualYear}
_______________________________________________________

	[7.8]. "Controllers":
_______________________________________________________

Los "Controllers" o controladores, son los encargados de solicitar al modelo ("model") los datos, y luego enviarlos a la vista ("view") para que está ultima los muestre.

1) En la raíz de nuestro proyecto creamos la carpeta "controllers".

2) Creamos dentro de la carpeta "controllers", el controlador, en este caso "usuarioController.js":

	const formularioLogin = (req, res) => {
		res.render("auth/login");
	};

	export { formularioLogin };

En este caso, le estamos quitando responsabilidades al "router".

Nota 1: el nombre del archivo tambien puede ser:

	"usuario.controller.js"

Esto ya depende de las convenciones que maneje el proyecto.

Nota 2: Si se necesita enviar datos a la vista, se hace ahora en el "controller".

3) En el "router" importamos el controlador:

	import express from "express";
	import { formularioLogin } from "../controllers/usuarioController.js";

	const router = express.Router();

	router.get("/login", formularioLogin);

	export default router;

_______________________________________________________

	[7.9]. ORM's y Bases de Datos:
_______________________________________________________

Un ORM (Object Relational Mapping), es una herramienta de programación que actúa como intermediario entre una aplicación y una base de datos relacional, facilitando la interacción con los datos sin necesidad de escribir código SQL directamente.

Convierte los objetos de un lenguaje de programación en el formato adecuado para ser almacenado en la base de datos y, a su vez, traduce los resultados de las consultas de la base de datos en objetos que la aplicación puede usar.

En MVC; un ORM se relaciona bastante con el Modelo

Node.js tiene una gran cantidad de ORM’s que se instalan como librería, algunos de los más populares son:

- Prisma
- Mongoose
- Sequelize
- TypeORM
- Bookshelf.js

_______________________________________________________

	[7.9.1]. Sequelize y MySQL:
_______________________________________________________

1) Instalamos el ORM Sequelize y MySQL2 como dependencias:

	npm i sequelize mysql2

Nota: debemos tambien instalar MySQl:

	https://www.mysql.com/downloads/

El "mysql2" que instalamos con Node, es el driver(controlador) para nuestra base de datos.

"Sequelize" tambien acepta otros motores de BD como Postgres, MariaDB, etc.

Nota: para más info de Sequelize, ir a:

	https://sequelize.org/

2) Ingresamos a MySQL en modo terminal:

	mysql -u root -p

3) Crear Base de Datos:

	CREATE DATABASE bienesraices_node_mvc;

4) En la raíz de nuestro proyecto, creamos una carpeta llamada "config", y dentro un archivo "db.js":

	import { Sequelize } from "sequelize";

	const db = new Sequelize('bienesraices_node_mvc', 'root', 'root', {
		host: 'localhost',
		port: 3306,
		dialect: 'mysql',
		define: {
			timestamps: true
		},
		pool: {
			max: 5,
			min: 0,
			acquire: 30000,
			idle: 10000
		},
	});

	export default db;

Este archivo trae la configuración de conexión a nuestra base de datos. En donde:

	const db = new Sequelize('nombreBaseDatos', 'usuarioBD', 'passwordBD', {objetoConfiguracion});

Acá creamos la instancia de Sequelize. En el Objeto de configuración tenemos:

	"timestamps" --> Hacemos que automáticamente en la tabla se agreguen dos columnas extras, de la fecha de creación del registro, y de la fecha de actualización del registro.

	"pool" --> el conecction pool, en donde:

	"max" --> el número de conexiones máximas por persona.

	"min" --> igualamos a cero(0) para indicar que cuando no haya actividad en el sitio se desconecta para liberar recursos.

	"acquire" --> en milisegundos, en este caso son "30 seg" para intentar crear la conexión antes de generar un error.

	"idle" --> en milisegundos, en este caso "10 seg", si no hay actividad en el sitio en ese tiempo, se finaliza la conexión a la BD.

5) En nuestro archivo principal de "express", "index.js", llamamos la conexión de la BD:

	import express from "express";
	import usuarioRoutes from "./routes/usuarioRoutes.js";
	import db from "./config/db.js";

	// Crear la app
	const app = express();

	// Conectar a la base de datos
	try {
		await db.authenticate();
		console.log('Conectado a la base de datos.');
	} catch (error) {
		console.error('No se pudo conectar a la base de datos:', error);
	}

_______________________________________________________

	[7.9.1.1]. Información de la BD en variables de entorno:
_______________________________________________________

1) Para ocultar la información de la base de datos en variables de entorno, primero instalamos "dotenv":

	npm i dotenv

Dotenv es un módulo sin dependencias que carga variables de entorno desde un archivo .env a process.env.

Nota: para más info de Dotenv, ir a:

	https://github.com/motdotla/dotenv#readme

2) En la raíz del proyecto, creamos un archivo ".env" con los datos a proteger:

	BD_NOMBRE=bienesraices_node_mvc
	BD_USUARIO=root
	BD_PASSWORD=root
	BD_HOST=localhost
	BD_PORT=3306

3) En el archivo de configuración de conexión con la Base de Datos "config\db.js":

	import { Sequelize } from "sequelize";
	import dotenv from 'dotenv';
	dotenv.config({ path: './.env' })

	const db = new Sequelize(process.env.BD_NOMBRE, process.env.BD_USUARIO, process.env.BD_PASSWORD, {
		host: process.env.BD_HOST,
		port: process.env.BD_PORT,
		dialect: 'mysql',
		define: {
			timestamps: true
		},
		pool: {
			max: 5,
			min: 0,
			acquire: 30000,
			idle: 10000
		}
	});

	export default db;

Importamos "dotenv", con "dotenv.config" definimos la ruta al archivo ".env", y con "process.env.", llamamos las variables de entorno definidas.
_______________________________________________________

	[7.9.1.2]. Modelo:
_______________________________________________________

El modelo ("model"), es le encargado de solicitar datos a la BD y de la lógica para mostrar esos datos.

Para crear un modelo:

1) Creamos en la raíz del proyecto una carpeta llamada "models".

2) Dentro de la carpeta "models", creamos el modelo, por convención se pone la primera letra en mayuscula, como si fuera una clase.

Ejemplo: archivo "Usuario.js":

	import { DataTypes } from "sequelize";
	import db from "../config/db.js";

	const Usuario = db.define("usuarios", {
		nombre: {
			type: DataTypes.STRING,
			allowNull: false,
		},
		email: {
			type: DataTypes.STRING,
			allowNull: false,
		},
		password: {
			type: DataTypes.STRING,
			allowNull: false,
		},
		token: DataTypes.STRING,
		confirmado: DataTypes.BOOLEAN,
	});

	export default Usuario;

Aca definimos el nombre de la tabla "usuarios", los campos que va a tener (nombre, email, password, etc.) y el tipo de datos del campo. Con "allowNull" indicamos que ese campo no debe estar vacio.

Nota 1: el "id" no es necesario especificarlo porque ya Sequelize asume que existe en la BD.

Nota 2: para más info de todos los tipos de datos disponibles, ir a:

	https://sequelize.org/docs/v6/core-concepts/model-basics/#data-types
_______________________________________________________

	[7.9.1.3]. Comunicar vista con routing y controller:
_______________________________________________________

1) Creamos la función en el controlador "controllers\usuarioController.js" y la exportamos:

	const registrar = (req, res) => {
		console.log('Registrando usuario...');
	};

	export { formularioLogin, formularioRegistro, registrar, formularioOlvidoPassword };

2) En el router "routes\usuarioRoutes.js", creamos la ruta, importamos y llamamos la función: 

	import { formularioLogin, formularioRegistro, registrar, formularioOlvidoPassword } from "../controllers/usuarioController.js";

	router.get("/registro", formularioRegistro);
	router.post("/registro", registrar);

En este caso recibe datos via POST de un formulario de registro de usuarios.

3) En la vista "views\auth\registro.pug", agregamos el método, y la acción en el formulario de registro:

	form.space-y-5(method="POST", action="/auth/registro")

_______________________________________________________

	[7.9.1.4]. Leer datos de un formulario:
_______________________________________________________

1) En nuestro archivo principal "index.js" habilitamos la lectura de los datos del formulario:

	// Habilitar lectura de datos de formularios
	app.use(express.urlencoded({ extended: true }));

Nota: está es la nueva forma de habilitar la lectura de datos del formulario, ya que antes "Express" no venia con esta funcionalidad y teniamos que usar otras librerias como "body-parser":

	let bodyParser = require("body-parser");
	
	// Middlewares
	// usar el body-parser
	app.use(bodyParser.urlencoded({extended:false}));
	app.use(bodyParser.json());

2) En el controlador "controllers\usuarioController.js", leemos los datos enviados por el formulario:

	const registrar = (req, res) => {
		console.log('Registrando usuario...', req.body);
	};

En consola podremos ver:

	Rergistrando usuario... {
		nombre: 'Ricardo',
		email: 'correo@correo.com',
		password: '123456',
		repetir_password: '123456'
	}

La "key" de los campos (nombre, email, password) corresponde al "name" de los campos en el formulario.

3) En el controlador es necesario validar los campos (que no esten vacios, etc.), antes de almacenar los datos en la BD.

Ejemplo:

	import { Testimonial } from "../models/Testimonial.js";

	const guardarTestimonial = async (req, res) => {
		const { nombre, correo, mensaje } = req.body;

		//Validar que los campos no esten vacios
		const errores = [];
		if (nombre.trim() === "") {
			errores.push({ mensaje: "El nombre esta vacio" });
		}
		if (correo.trim() === "") {
			errores.push({ mensaje: "El correo esta vacio" });
		}
		if (mensaje.trim() === "") {
			errores.push({ mensaje: "El mensaje esta vacio" });
		}

		if (errores.length > 0) {
			//Mostrar los errores en la vista
			res.render("testimoniales", {
				pagina: "Testimoniales",
				errores,
				nombre,
				correo,
				mensaje,
			});
		} else {
			//Almacenar el testimonial en la BD
			try {
				await Testimonial.create({
					nombre,
					correo,
					mensaje,
				});
				res.redirect("/testimoniales");
			} catch (error) {
				console.log(error);
			}
		}
	};

	export { guardarTestimonial };

_______________________________________________________

	[7.9.1.5]. Consultar la BD:
_______________________________________________________

Para consultar los datos de una BD, se hace directamente desde el controlador.

1) En el controlador "controllers\paginasController.js":

	import { Viaje } from "../models/Viaje.js";

	const paginaViajes = async (req, res) => {
		// Consultar BD
		const viajes = await Viaje.findAll();

		res.render("viajes", {
			pagina: "Viajes",
			viajes
		});
	};

Primero importamos el modelo, luego la función correspondiente del controlador la volvemos asincrona ("async").

Consultamos todos los registros de la tabla "viajes", con el modelo, y el metodo de "Sequelize" ".findAll()".

Luego le pasamos el array de "viajes" a la vista.

Nota: para más info de las consultas en Sequelize, ir a:

	https://sequelize.org/docs/v6/core-concepts/model-querying-basics/

2) En la vista "views\viajes.pug", iteramos por cada elemento del array:

	each viaje in viajes
		.col-md-6.col-lg-4.mb-4
			.card
				img.card-img-top(src=`/img/destinos_${viaje.imagen}.jpg` alt=`Imagen del viaje a ${viaje.titulo}`)
				.card-body
					h2.card-title #{viaje.titulo}
					p
						| #{viaje.fecha_ida} - #{viaje.fecha_vuelta}
					p
						| #{viaje.disponibles} Disponibles
					p.card-text #{viaje.descripcion.substr(0, 100)}...
					p.precio $#{viaje.precio}
					a.btn.btn-success.btn-block(href=`/viajes/${viaje.slug}`) Más información
_______________________________________________________

	[7.9.1.5.1]. Limitar datos consulta:
_______________________________________________________

Podemos limitar el número de resultados obtenidos de la BD:

	const paginaInicio = async (req, res) => {
		// Consultar 3 viajes del modelo Viaje
		try {
			const viajes = await Viaje.findAll({ limit: 3 });
			
			res.render("inicio", {
				pagina: "Inicio",
				clase: "home",
				viajes,
			});
		} catch (error) {
			console.log("Error al obtener los viajes: ", error);
		}
	};

En este caso al método "findAll()", le pasamos un objeto con "limit: 3", para limitar a solo tres resultados.
_______________________________________________________

	[7.9.1.5.2]. Consultar la BD según URL:
_______________________________________________________

Podemos consultar el detalle de un elemento visitando una url en especifico, por ejemplo:

	http://localhost:4000/viajes/viaje-italia

Para poder hacerlo:

1) En el router, creamos la nueva ruta:

	import { paginaInicio, paginaNosotros, paginaViajes, paginaDetalleViaje, paginaTestimoniales } from "../controllers/paginasController.js";

	router.get("/viajes/:slug", paginaDetalleViaje);

En este caso, la URL, recibe un parámetro "slug", el  es requerido.

2) En el controlador "controllers\paginasController.js":

	// Muestra un viaje por su slug
	const paginaDetalleViaje = async (req, res) => {
		const { slug } = req.params;

		console.log("Detalle viaje: ", slug);

		try {
			const viaje = await Viaje.findOne({ where: { slug } });
			res.render("viaje", {
				pagina: "Información Viaje",
				viaje,
			});
		} catch (error) {
			console.log("Error al obtener el viaje: ", error);
		}
	};

Con "req.params", obtenemos los parámetros que se envian por URL, en este caso desestructuramos "slug", que es el nombre que definimos en el router para ese parámetro.

Con ".findOne({ where: { slug } })" buscamos en la BD un viaje cuyo slug sea igual al indicado, es lo mismo que tener:

	.findOne({ where: { slug: slug } })

Pero como el nombre del parámetro es igual a la variable, se simplifica.

Nota: para más info de este método de Sequelize, ir a:

	https://sequelize.org/docs/v6/core-concepts/model-querying-finders/#findone

Luego de obtener de la BD el resultado, renderizamos la vista del detalle, pasandole los datos correspondientes.

En el catch, tambien podemos renderizar una página de 404.

3) Renderizamos la vista del detalle "views\viaje.pug":

	extends layout/index.pug

	block contenido
		main.container.mt-5
			.row
				.col-md-5
					img.img-fluid(src=`/img/destinos_${viaje.imagen}_ln.jpg`, alt=`imagen viaje a ${viaje.titulo}`)
				.col-md-7
					h1 #{viaje.titulo}
					p
						|	#{viaje.fecha_ida} - #{viaje.fecha_vuelta}
					p.precio
						|	$#{viaje.precio} USD
					p
						|	#{viaje.disponibles} Disponibles
					p.card-text #{viaje.descripcion}
_______________________________________________________

	[7.9.1.5.3]. Múltiples consultas:
_______________________________________________________

Para hacer múltiples consultas al mismo tiempo a la BD, usamos promesas:

	const paginaInicio = async (req, res) => {
		// Consultar 3 viajes del modelo Viaje
		const promiseDB = [];

		promiseDB.push( Viaje.findAll({ limit: 3 }) );
		promiseDB.push( Testimonial.findAll({ limit: 3 }) );

		try {
			const resultado = await Promise.all( promiseDB );

			res.render("inicio", {
				pagina: "Inicio",
				clase: "home",
				viajes: resultado[0],
				testimoniales: resultado[1],
			});
		} catch (error) {
			console.log("Error al obtener los viajes: ", error);
		}
	};

Se crea un arreglo con las consultas a la BD, y con "Promise.all()", ejecutamos las promesas, la respuesta de estas, quedan en otro array llamado "resultado".

_______________________________________________________

	[7.9.2]. Mongoose y MongoDB:
_______________________________________________________

1) Instalamos el ORM Mongoose como dependencia:

	pnpm i mongoose

2) Para MongoDB, vamos a usar la versión gratuita en la nube, para usarla creamos cuenta:

	https://www.mongodb.com/

Es el mismo "MongoDB Atlas", luego ingresamos, y creamos un cluster. 

3) Al crear el cluster, en la opción "Connect", nos pide:

- "Add a connection IP address" --> Aca escogemos la ip de nuestro equipo para conectar con la BD, para el ejemplo escogemos "Allow Access from Anywhere", pero es una conexión NO SEGURA.

Esto lo podemos editar en: el panel lateral izquierdo, buscamos "Security" --> "Database & Network Access" --> "Network Access" --> "IP Access List".

- Creamos un usuario y contraseña de BD.

Esto lo podemos editar en: el panel lateral izquierdo, buscamos "Security" --> "Database & Network Access" --> "Database Access" --> "Database Users".

4) Escogemos el método de conexión.

A) En la opción "Access your data through tools", podemos escoger "Compass" que es el entorno gráfico de escritorio para gestionar la BD.

Copiamos el "connection string".

B) En la opción "Connect to your application", escogemos "Drivers", que es para conectar la aplicación backend que estamos desarrollando con Node.

Copiamos el "connection string".

5) "Compass": 

Una vez instalada la aplicación de escritorio, la abrimos y hacemos click en "+ Add new connection".

- En "URI", pegamos el "connection string", cambiando "<password>" por el correspondiente.

- En "Name", podemos darle un nombre a la conexión. Ejemplo: MongoDB Atlas

- En "Color", podemos escoger un color de la conexión.

- Podemos marcar el checkbox "Favorite this connection", para guardar la conexión si nos vamos a conectar seguido.

6) Al escoger nuestra conexión, damos click en "+ Create database":

- En "Database name": el nombre de nuestra base de datos. Ejemplo: "apv" (Administrador de Pacientes de Veterinaria).

- En "Collection Name": el nombre de la tabla, Ejemplo: "pacientes".

7) Aplicación Node:

En la raíz de nuestro proyecto, creamos una carpeta llamada "config", y dentro un archivo "db.js":

	import mongoose from "mongoose";

	const conectarDB = async () => {
		try {
			const db = await mongoose.connect(
				"mongodb+srv://usuario_db_root:<db_password>@cluster.algo.mongodb.net/?appName=Cluster"
			);
			const url = `${db.connection.host}:${db.connection.port}`;
			console.log(`MongoDB conectado en: ${url}`);
		} catch (error) {
			console.log(`Error: ${error.message}`);
			process.exit(1);
		}
	};

	export default conectarDB;

Este archivo trae la configuración de conexión a nuestra base de datos.

El método " mongoose.connect()" recibe por dentro el "connection string" de MongoDB Atlas.

Nota: no olvidar cambiar en el "connection string", "usuario_db_root" y "<db_password>" por los correspondientes.

8) En nuestro archivo principal de "express", "index.js", llamamos la conexión de la BD:

	import express from "express";
	import conectarDB from "./config/db.js";

	const app = express();

	// Definir puerto
	const PORT = process.env.PORT || 4000;

	// Conectar a la base de datos
	conectarDB();

	// Routing
	app.get("/", (req, res) => {
		res.send("Hello World!");
	});

	app.listen(PORT, () => {
		console.log(`Servidor funcionando en el puerto ${PORT}`);
	});
_______________________________________________________

	[7.9.2.1]. Información de la BD en variables de entorno:
_______________________________________________________

1) Para ocultar la información de la base de datos en variables de entorno, primero instalamos "dotenv":

	npm i dotenv

Dotenv es un módulo sin dependencias que carga variables de entorno desde un archivo .env a process.env.

Nota: para más info de Dotenv, ir a:

	https://github.com/motdotla/dotenv#readme

2) En la raíz del proyecto, creamos un archivo ".env" con los datos a proteger:

	MONGO_URI=mongodb+srv://usuario_db_root:<db_password>@cluster.algo.mongodb.net/nombreBaseDatos?appName=Cluster

Nota 1: Actualmente no se indica un nombre de la base de datos, sino un cluster. Para añadir una BD especifica:

	MONGO_URI=mongodb+srv://usuario_db_root:<db_password>@cluster.algo.mongodb.net/?appName=Cluster

Nota 2: Un cluster es un conjunto de servidores MongoDB distribuidos y conectados entre sí que trabajan juntos como una sola unidad.

3) En el archivo de configuración de conexión con la Base de Datos "config\db.js":

	import mongoose from "mongoose";
	import dotenv from 'dotenv';
	dotenv.config({ path: './.env' });

	const conectarDB = async () => {
		try {
			const db = await mongoose.connect(
			process.env.MONGO_URI
			);
			const url = `${db.connection.host}:${db.connection.port}`;
			console.log(`MongoDB conectado en: ${url}`);
		} catch (error) {
			console.log(`Error: ${error.message}`);
			process.exit(1);
		}
	};

	export default conectarDB;

Importamos "dotenv", con "dotenv.config" definimos la ruta al archivo ".env", y con "process.env.", llamamos las variables de entorno definidas.

_______________________________________________________

	[7.9.2.2]. Modelo:
_______________________________________________________

El modelo ("model"), es le encargado de solicitar datos a la BD y de la lógica para mostrar esos datos.

Para crear un modelo:

1) Creamos en la raíz del proyecto una carpeta llamada "models".

2) Dentro de la carpeta "models", creamos el modelo, por convención se pone la primera letra en mayuscula, como si fuera una clase.

Ejemplo: archivo "Veterinario.js":

	import mongoose from "mongoose";

	// Definimos el esquema
	const veterinarioSchema = mongoose.Schema({
		nombre: {
			type: String,
			required: true,
			trim: true,
		},
		password: {
			type: String,
			required: true,
			trim: true,
		},
		email: {
			type: String,
			required: true,
			trim: true,
			unique: true,
		},
		telefono: {
			type: String,
			trim: true,
			default: null,
		},
		web: {
			type: String,
			trim: true,
			default: null,
		},
		token: {
			type: String,
		},
		confirmado: {
			type: Boolean,
			default: false,
		}
	});

	// Definimos el modelo
	const Veterinario = mongoose.model('Veterinario', veterinarioSchema);

	export default Veterinario;

Aca definimos la estructura o esquema, es decir, los campos que va a tener (nombre, email, password, etc.) y el tipo de datos del campo. 

Con "required: true" indicamos que ese campo no debe estar vacio y que es requerido.

Con "default: null", indicamos que el valor por defecto es vacio, osea que no es requerido.\

Con "mongoose.model('Veterinario', veterinarioSchema)" definimos el modelo con nombre "Veterinario".

Nota 1: el "id" no es necesario especificarlo porque ya Mongoose asume que existe, y lo crea en la BD.

Nota 2: para más info de todos los tipos de datos disponibles, ir a:

	https://mongoosejs.com/docs/schematypes.html

_______________________________________________________

	[7.9.2.2.1]. Modelo con llave foránea:
_______________________________________________________

En el ejemplo que se esta desarrollando, cada veterinario registra un paciente, por lo que en los campos del paciente se debe guardar una referencia al "id" del veterinario (similar a una llave foránea lógica).

Ejemplo: creamos el modelo "backend\models\Paciente.js":

	import mongoose from "mongoose";

	const pacienteSchema = mongoose.Schema({
		nombre: {
			type: String,
			required: true,
			trim: true,
		},
		propietario: {
			type: String,
			required: true,
			trim: true,
		},
		email: {
			type: String,
			required: true,
			trim: true,
		},
		fechaAlta: {
			type: Date,
			required: true,
		},
		sintomas: {
			type: String,
			required: true,
		},
		veterinario: {
			type: mongoose.Schema.Types.ObjectId,
			ref: "Veterinario",
			required: true,
		},
	}, {
		timestamps: true,
	});

	const Paciente = mongoose.model("Paciente", pacienteSchema);

	export default Paciente;

En el campo "veterinario", indicamos con "type: mongoose.Schema.Types.ObjectId" el tipo de dato, y con "ref: "Veterinario"" hacemos referencia al modelo.

Adicional pasamos otro objeto con "timestamps: true", que crea automáticamente campos adicionales de "createdAt" y "updatedAt".

_______________________________________________________

	[7.9.2.3]. Almacenar registros en la BD:
_______________________________________________________

1) En nuestro archivo principal "backend\index.js", habilitamos que el servidor pueda enviar respuestas con JSON:

	app.use(express.json());

2) En el controlador "backend\controllers\veterinarioController.js" usamos el modelo, creamos una nueva instancia y luego la almacenamos en la BD:

	import Veterinario from "../models/Veterinario.js";

	const registrar = async (req, res) => {
		console.log("Registrando veterinario...", req.body);
		try {
			// Crear nuevo veterinario
			const veterinario = new Veterinario(req.body);
			const veterinarioGuardado = await veterinario.save();
			res.json(veterinarioGuardado);
		} catch (error) {
			console.log(error);
		}
	};

	const perfil = (req, res) => {
		res.json({
			msg: "Ver perfil veterinario...",
		});
	};

	export { registrar, perfil };

Con "new Veterinario(req.body)" creamos una instancia de "Veterinario", con los datos que nos envie el cliente (frontend ó Postman).

".save()" es un método de Mongoose que nos permite guardar en la BD.

Nota: aún faltan realizar más validaciones para verificar que no se repita el correo del usuario, que se hashee el password para que no sea visible, y generar un token único para enviar un email y confirmar la cuenta.
_______________________________________________________

	[7.9.2.3.1]. Validacion confirmar cuenta:
_______________________________________________________

Para confirmar la cuenta del usuario, en el modelo ya se creo un campo "token", falta generar un "token" único, para enviar un enlace con ese "token" al correo del usuario, y que al hacer click, se confirme su cuenta.

1) Creamos en la raíz del proyecto una carpeta llamada "helpers", y dentro de está un archivo "backend\helpers\generarId.js" encargado de generar el "token" único:

	const generartId = () => {
		return Date.now().toString(32) + Math.random().toString(32).substring(2);
	};

	export default generartId;

Nota: si hacemos más "helpers" o funciones de utilidad en nuestra aplicación, se recomienda un archivo para cada funcionalidad, con eso al momento de exportarla, solo lee la función que se necesita y no todo el archivo con X líneas de código.

2) En el modelo "backend/models/Veterinario.js", importamos y usamos nuestro generador de "tokens":

	import mongoose from "mongoose";
	import generarId from "../helpers/generarId.js";

	// Definimos el esquema de Veterinario
	const veterinarioSchema = mongoose.Schema({
		nombre: {
			type: String,
			required: true,
			trim: true,
		},

		// ...existing code...

		token: {
			type: String,
			default: generarId,
		},
		confirmado: {
			type: Boolean,
			default: false,
		}
	});

	// Definimos el modelo
	const Veterinario = mongoose.model('Veterinario', veterinarioSchema);

	export default Veterinario;

3) En el controlador "", creamos la función encargada de confirmar la cuenta:

	import Veterinario from "../models/Veterinario.js";

	const confirmar = async (req, res) => {
		const { token } = req.params;

		const usuarioConfirmar = await Veterinario.findOne({ token });

		if (!usuarioConfirmar) {
			const error = new Error("Token no válido");
			return res.status(404).json({ msg: error.message });
		}

		try {
			usuarioConfirmar.token = null;
			usuarioConfirmar.confirmado = true;

			await usuarioConfirmar.save();
			res.json({
				msg: "Usuario confirmado correctamente",
			});
		} catch (error) {
			console.log(error);
		}
	};

	export { registrar, perfil, confirmar };

Acá, con "req.params", recuperamos de la url(método GET) el "token".

Con "Veterinario.findOne({ token })" buscamos en la BD el usuario que tenga ese "token".

Si no encontramos el usuario, enviamos el error "Token no válido".

Si encuentra el usuario, queda almacenado como objeto en la constante "usuarioConfirmar". Luego en el "try/catch", tomamos el objeto, y al "token" lo dejamos vacio, y en "confirmado" igual a "true".

Despues tomamos el objeto ya modificado y lo guardamos en la BD con "save()" de Mongoose.

4) Importamos la función para confirmar en el router "backend\routes\veterinarioRoutes.js":

	import express from "express";
	import { registrar, perfil, confirmar } from "../controllers/veterinarioController.js";

	const router = express.Router();

	router.post("/", registrar);

	router.get("/perfil", perfil);

	router.get("/confirmar/:token", confirmar);

	export default router;

Acá tambien creamos la ruta que recibira por get el token de usuario para confirmar.

Nota: queda pendiente el envio del correo con el link de confirmación al usuario.
_______________________________________________________

	[7.9.2.3.2]. Hashear passwords de usuarios:
_______________________________________________________

Por seguridad es necesario al momento de guardar los password en la BD, encriptarlos o hashearlos, esto con el fin de tener mayor seguridad y que no se pueda leer el password del usuario en ningún momento.

Conceptos de hasheo:

Función hash: Un algoritmo que toma datos de longitud variable y los convierte en una cadena de texto de longitud fija, conocida como hash. 

Propiedades:

- Unidireccional: Es muy difícil revertir el hash para obtener los datos originales. 
- Determinista: La misma entrada siempre produce el mismo hash. 
- Sensible a los cambios: Un cambio mínimo en la entrada produce un hash completamente diferente.

Aplicaciones:

- Seguridad: Proteger contraseñas y verificar la integridad de archivos y mensajes. 
- Blockchain: Asegurar la integridad de los bloques, verificar transacciones y crear direcciones de criptomonedas.

Un "salt" es un valor aleatorio único por contraseña que se añade antes de hashear. Previene ataques con tablas precalculadas (rainbow tables) y hace que dos usuarios con la misma contraseña tengan hashes distintos.

Para hacer hash en NodeJs, existen diferentes librerias:

- bcrypt
- bcryptjs
- argon2
_______________________________________________________

	[7.9.2.3.2.1]. Hashear passwords con argon2:
_______________________________________________________

Ejemplo con argon2:

1) Instalamos la libreria argon2:

	pnpm install argon2

2) En el modelo "backend\models\Veterinario.js", importamos la libreria y hasheamos el pasword del usuario antes de guardarlo en la BD:

	import mongoose from "mongoose";
	import argon2 from "argon2";
	import generarId from "../helpers/generarId.js";

	// Definimos el esquema de Veterinario
	const veterinarioSchema = mongoose.Schema({
		// ...existing code...
	});

	// Hashear contraseña antes de guardar
	veterinarioSchema.pre("save", async function () {
		if (!this.isModified("password")) return;
		this.password = await argon2.hash(this.password);
	});

	// Método para comprobar contraseña
	veterinarioSchema.methods.comprobarPassword = async function(passwordFormulario) {
		return await argon2.verify(this.password, passwordFormulario);
	};

	// Definimos el modelo
	const Veterinario = mongoose.model("Veterinario", veterinarioSchema);

	export default Veterinario;

Usamos un hook de Mongoose llamado "pre", el cual nos permite hacer algo antes de alguna otra acción, en este caso antes de guardar. La función callback que enviamos como parámetro, tiene que estar definida con "function", no puede ser función flecha, ya que por dentro usamos "this", que en el contexto de "function" se refiere al esquema, y en un arrow function seria un contexto global.

Con "!this.isModified("password")", comprobamos si el campo de contraseña (password) no ha sido modificado. Si la contraseña no ha sido modificada, significa que otros campos en el documento se están actualizando, pero no la contraseña en sí. 

Por otro lado, si la contraseña ha sido modificada, la validación "this.isModified("password")" devolverá "true", lo que significa que la contraseña ha sido modificada y se debe realizar alguna acción adicional, como encriptarla antes de guardarla en la base de datos.

Esta comprobación la hacemos para no hashear dos veces la contraseña del usuario, ya que si lo hacemos, el usuario no podria ingresar porque el password no seria el mismo.

Luego hasheamos la contraseña con el método de argon2 "argon2.hash()".

Nota: argon2 genera un salt aleatorio por defecto y lo incluye dentro del string del hash. No hay que guardarlo aparte: guarda el string que devuelve argon2.hash. Se puede ajustar la longitud del salt (p. ej. 16 bytes) vía opciones, pero consume más recusros del servidor.

_______________________________________________________

	[7.9.2.3.2.2]. Hashear passwords con bcrypt:
_______________________________________________________

1) Instalamos la libreria:

	pnpm i bcrypt

2) En el modelo "backend\models\Veterinario.js", importamos la libreria y hasheamos el pasword del usuario antes de guardarlo en la BD:

	import mongoose from "mongoose";
	import bcrypt from "bcrypt";
	import generarId from "../helpers/generarId.js";

	// Definimos el esquema de Veterinario
	const veterinarioSchema = mongoose.Schema({
		// ...existing code...
	});

	// Hashear contraseña antes de guardar
	veterinarioSchema.pre("save", async function () {
		if (!this.isModified("password")) return;
		const salt = await bcrypt.genSalt(10);
		this.password = await bcrypt.hash(this.password, salt);
	});

	// Método para comprobar contraseña
	veterinarioSchema.methods.comprobarPassword = async function(passwordFormulario) {
		return await bcrypt.compare(this.password, passwordFormulario);
	};

	// Definimos el modelo
	const Veterinario = mongoose.model("Veterinario", veterinarioSchema);

	export default Veterinario;

_______________________________________________________

	[7.9.2.4]. Consultar la BD:
_______________________________________________________

Para buscar un registro en la BD, por alguno de sus campos, tambien usamos el modelo.

Ejemplo: En el controlador "backend\controllers\veterinarioController.js", buscamos por "email" si el usuario ya existe:

	import Veterinario from "../models/Veterinario.js";

	const registrar = async (req, res) => {
		// console.log("Registrando veterinario...", req.body);
		
		const { email } = req.body;
		// Prevenir registros duplicados
		const existeVeterinario = await Veterinario.findOne({ email });

		if (existeVeterinario) {
			const error = new Error("Usuario ya registrado");
			return res.status(400).json({ msg: error.message });
		}

		try {
			// Crear nuevo veterinario
			const veterinario = new Veterinario(req.body);
			const veterinarioGuardado = await veterinario.save();
			res.json(veterinarioGuardado);
		} catch (error) {
			console.log(error);
		}
	};

Con el método de Mongoose ".findOne({nombreCampo})" buscamos un registro que coincida con el campo.

Nota: Gracias a las nuevas caracteristicas de JavaScript, se reduce el código de:

	const existeVeterinario = await Veterinario.findOne({ email: email });

A:

	const existeVeterinario = await Veterinario.findOne({ email });

Esto es gracias a que llave y valor se llaman iguales.

_______________________________________________________

	[7.10]. JSON Web Token (JWT):
_______________________________________________________

Una vez que un usuario se autentica, inicia una sesión en el servidor, con esa sesión, verificamos que a que rutas tiene acceso el usuario y a cuales no, y tambien almacenamos cierta información del usuario.

JWT, o token web de JSON, es un estándar abierto que transmite información de forma segura entre partes a través de un objeto JSON. Es compacto y autocontenido, ya que su carga útil incluye toda la información necesaria, evitando así consultas innecesarias a la base de datos. Su principal uso es la autenticación y autorización de usuarios en aplicaciones web, APIs y servicios de inicio de sesión único (SSO).

Estructura de un JWT:

Un JWT está compuesto por tres partes separadas por puntos: 

- Encabezado (Header): Contiene información sobre el tipo de token y el algoritmo de firma utilizado.

- Carga útil (Payload): Almacena la información del usuario y sus reclamaciones o "claims" (como su identidad o permisos) en un objeto JSON.

- Firma (Signature): Se genera a partir del encabezado y la carga útil codificados, y una clave secreta. Esta firma garantiza la integridad del token, asegurando que no ha sido modificado.

Cómo funciona:

1) El usuario inicia sesión con sus credenciales. 
2) El servidor autentica al usuario y genera un JWT con la información del usuario. 
3) El JWT se envía al cliente. 
4) El cliente incluye este token en la cabecera Authorization de cada solicitud posterior. 
5) El servidor verifica la firma del token para autenticar la solicitud y conceder acceso a los recursos protegidos.

Ventajas:

- Seguridad: La firma digital verifica la autenticidad e integridad de los datos. 
Eficiencia: Al ser autocontenido, reduce la necesidad de consultar la base de datos en cada solicitud.

- Flexibilidad: Puede usarse en diferentes plataformas y es ideal para arquitecturas de microservicios.
_______________________________________________________

	[7.10.1]. Ejemplo JWT:
_______________________________________________________

1) Instalamos la dependencia "jsonwebtoken":

	pnpm i jsonwebtoken

2) En el archivo ".env" creamos la siguiente variable de entorno:

	JWT_SECRET=palabrasupersecreta456

Esta variable de entorno nos sirve para codificar y decodificar el JWT.

3) Dentro de la carpeta "helpers", creamos un archivo llamado "generarJWT.js":

	import jwt from "jsonwebtoken";

	const generarJWT = (id) => {
		return jwt.sign({ id }, process.env.JWT_SECRET, {
			expiresIn: "30d",
		});
	};

	export default generarJWT;

"generarJWT" recibe como parametro el "id" de usuario. El método "jwt.sign()" recibe tres parámetros, primero un objeto de lo que va a codificar, luego la variable de entorno con la palabra secreta para la codificación, y por ultimo un objeto donde indicamos cuando vence la sesión del usuario, en este caso 30 dias.

Nota 1: el objeto "{ id }" es lo mismo que tener "{ id: id }", pero tambien podemos pasarle otros campos, por ejemplo:

	{ 
		id,
		nombre: "Ricardo"
	}

No debemos pasar datos sencibles como contraseñas, números de tarjeta de credito, etc, ya que estos datos se pueden decodificar facilmente, una herramienta online para decodificar:

	https://www.jwt.io/

Nota 2: Si la aplicación que estamos desarrollando es por ejemplo para un banco, no conviene dejarle al JWT tanto tiempo para que expire, con algunos minutos es suficiente para que no quede abierta la sesión del usuario.

4) En el controlador encargado de la autenticación del usuario "backend\controllers\veterinarioController.js", importamos y generamos el JWT:

	import Veterinario from "../models/Veterinario.js";
	import generarJWT from "../helpers/generarJWT.js";

	// ...existing code...

	const autenticar = async (req, res) => {
		console.log(req.body);
		const { email, password } = req.body;

		// Comprobar si el usuario existe
		const usuario = await Veterinario.findOne({ email });
		if (!usuario) {
			const error = new Error("El usuario no existe");
			return res.status(404).json({ msg: error.message });
		}

		// Comprobar si el usuario está confirmado
		if (!usuario.confirmado) {
			const error = new Error("Tu cuenta no ha sido confirmada");
			return res.status(403).json({ msg: error.message });
		}

		// Comprobar su password
		if (await usuario.comprobarPassword(password)) {
			// Autenticar el usuario

			res.json({
				token: generarJWT(usuario._id),
			});
		} else {
			const error = new Error("La contraseña es incorrecta");
			return res.status(403).json({ msg: error.message });
		}
	};

	export { registrar, perfil, confirmar, autenticar };

En este caso al autenticar el usuario, el servidor le responde al cliente con el token.
_______________________________________________________

	[7.10.2]. Bearer token:
_______________________________________________________

Un "bearer token" o token de portador es un tipo de token de seguridad que autoriza el acceso a un recurso protegido; simplemente, "quien lo tiene, accede". Se utiliza en un encabezado Authorization de las solicitudes HTTP, típicamente en el formato Authorization: Bearer <token>, para que el servidor verifique que el portador del token tiene permiso para acceder a los datos solicitados.

Características clave:

- Acceso sin identificación adicional: El nombre "portador" (bearer) significa que quien presente el token tiene permiso para acceder al recurso sin necesidad de demostrar su identidad de otra forma.

- Uso común: Son un componente fundamental de protocolos como OAuth 2.0 y se usan con JWT (JSON Web Tokens).

- Encabezado HTTP: La forma estándar de enviarlo es en el encabezado Authorization de una solicitud HTTP.

- Seguridad: Son más seguros que métodos como la autenticación básica, ya que envían un token de acceso en lugar de credenciales de usuario en cada solicitud. Se recomienda usarlos solo con conexiones HTTPS.

- Obtención: Se generan después de que un cliente se autentica con éxito ante el servidor y se envían en solicitudes posteriores para acceder a recursos protegidos. 
_______________________________________________________

	[7.10.2.1]. Crear rutas protegidas - Middleware:
_______________________________________________________

Podemos crear rutas que solo un usuario ya autenticado tenga acceso:

1) Creamos una carpeta llamada "middleware".

2) Dentro de la carpeta "middleware" creamos un archivo llamado "authMiddleware.js":

	import jwt from "jsonwebtoken";
	import Veterinario from "../models/Veterinario.js";

	const checkAuth = async (req, res, next) => {
		let token;
		if (
			req.headers.authorization &&
			req.headers.authorization.startsWith("Bearer ")
		) {
			try {
				console.log("Aca el token: ",req.headers.authorization);
				token = req.headers.authorization.split(" ")[1];
				const decoded = jwt.verify(token, process.env.JWT_SECRET);
				console.log("Token decoded: ", decoded);

				// Agregar el veterinario a la request
				req.veterinario = await Veterinario.findById(decoded.id).select(
					"-password -token -confirmado -createdAt -updatedAt -__v"
				);
				return next();
			} catch (error) {
				const error1 = new Error("Token no válido");
				return res.status(403).json({ msg: error1.message });
			}
		}

		if (!token) {
			const error = new Error("Token no válido o inexistente");
			return res.status(403).json({ msg: error.message });
		}
		next();
	};

	export default checkAuth;

Primero importamos el JWT para validar y autenticar el usuario. Tambien importamos el modelo.

En la función "checkAuth", verificamos que en los "headers" de la petición venga la "authorization", y que esta empiece con "Bearer ".

Si es así, con el metodo "split", dividimos donde hay un espacio, y nos quedamos solo con el token, ya que en la petición del cliente (o de Postman), viene así:

	Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY5MmExN2RjNjc0OGI2ZDNjNDZmZjNhMCIsImlhdCI6MTc2NDY5NDg1MSwiZXhwIjoxNzY3Mjg2ODUxfQ.eBCpjhfim3o3Q2CVt9FU_EaP_CbLEdSJH5MkZRZP5BE

Luego con "jwt.verify()", le pasamos el "token" y la variable de entorno con la palabra secreta, para decodificar el "token". El "token" decodificado es algo así:

	{ id: '692a17dc6748b6d3c46ff3a0', iat: 1764694851, exp: 1767286851 }

Con el método de Mongoose "findById()", buscamos en la BD el usuario con ese "id", y con el método "select()", le pasamos los campos que queremos que excluya de la consulta, anteponiendo el signo menos(-) antes de cada campo. En este caso no nos interesa obtener datos sensibles como el password del usuario, y tampoco saber si esta confirmado o no, etc.

En vez de crear una constante "veterinario", y guardar los campos obtenidos de la base de datos, lo guardamos en la petición "req.veterinario", con eso creamos la sesión del usuario.

Con "return next();", pasamos al siguiente "middleware" (en este caso se va para la función "perfil" del controlador, que seria encargada de mostrarnos la vista del perfil del usuario).

Si dentro del "try/catch", al intentar verificar el "token", da con un token no valido, salta al "catch" y muestra el "error1".

Y en caso de que no exista "token", muestra el error "Token no válido o inexistente".

3) En el router "backend\routes\veterinarioRoutes.js", importamos y usamos nuestro middleware:

	import express from "express";
	import {
		registrar,
		perfil,
		confirmar,
		autenticar,
	} from "../controllers/veterinarioController.js";
	import checkAuth from "../middleware/authMiddleware.js";

	const router = express.Router();

	router.post("/", registrar);
	router.get("/confirmar/:token", confirmar);
	router.post("/login", autenticar);

	// Ruta protegida
	router.get("/perfil", checkAuth, perfil);

	export default router;

En este caso el middleware se ejecuta antes de la función "perfil" del controlador. Y solo entraria a esa función si el "token" que envia el cliente es valido.

4) En  el controlador "backend\controllers\veterinarioController.js":

	const perfil = (req, res) => {
		const { veterinario } = req;
		res.json({
			perfil: veterinario,
		});
	};

Aca obtenemos los datos del usuario desde la petición ("req").