
	NODE:
_______________________________________________________

INDICE:

[1]. Qué es Node
[2]. Qué es npm
[3]. Instalación
[4]. Iniciar proyecto Node
[5]. Instalar Dependencias
	[5.1]. Dependencias de desarrollo
		[5.1.1]. "nodemon"
		[5.1.2]. "pm2"
[6]. Variables de entorno
[7]. Qué es "express"
	[7.1]. Archivo base de "express"
	[7.2]. Habilitar modulos
	[7.3]. "Hola mundo!" en "express"
	[7.4]. "Routing" en "express"
		[7.4.1]. Métodos HTTP
		[7.4.2]. Peticiones GET y POST
	[7.5]. Template engines
		[7.5.1]. Instalando PUG
		[7.5.2]. Pasar variables hacia las vistas
		[7.5.3]. Crear Layout principal
	[7.6]. Servir archivos estáticos
	[7.7]. "middleware"
	[7.8]. "Controllers"
	[7.9]. ORM's y Bases de Datos
		[7.9.1]. Sequelize y MySQL
			[7.9.1.1]. Información de la BD en variables de entorno
			[7.9.1.2]. Modelo
			[7.9.1.3]. Comunicar vista con routing y controller
			[7.9.1.4]. Leer datos de un formulario
			[7.9.1.5]. Consultar la BD
				[7.9.1.5.1]. Limitar datos consulta
				[7.9.1.5.2]. Consultar la BD según URL
				[7.9.1.5.3]. Múltiples consultas

_______________________________________________________

	[1]. Qué es Node:
_______________________________________________________

Es un entorno de código abierto multiplataforma, que permite crear aplicaciones del lado del servidor en JavaScript.

Permite crear APIS, aplicaciones web e incluso acceder a archivos y leer sus contenidos.

Ventajas: velocidad y rendimiento, excelente para aplicaciones en tiempo real.

_______________________________________________________

	[2]. Qué es npm:
_______________________________________________________

"npm" o Node Package Manager, es una gran cantidad de paquetes y librerias de código abierto, ya listos para ser utilizados, entrte ellos paquetes para subir archivos, autenticación de usuarios, enviar emails, template engines, seguridad, etc.

Para ver la versión de "npm" instalada usamos:

	npm -v
_______________________________________________________

	[3]. Instalación:
_______________________________________________________

1) Para instalar Node:

	https://nodejs.org/es/

Nota: Se recomienda la versión LTS(Long Term Service).

2) Luego en consola (windows cmd o powershell), escribimos el comando:

	node -v

Esto nos mostrara la version de Node instalada.

Si queremos ejecutar codigo JavaScript en la conmsola de node escribimos:

	node

Y luego el codigo JavaScript como:

	console.log("Hola!!!");
_______________________________________________________

	[4]. Iniciar proyecto Node:
_______________________________________________________

1) Crear una carpeta para el proyecto, para el nombre del proyecto, seguimos las siguientes recomendaciones:

	A) Utiliza siempre minúsculas.
	B) No utilices espacios en el nombre. Usa guiones en su lugar.
	C) Evita el uso de carácteres especiales, signos de puntuación, etc...

2) Para llevar el control de versiones del proyecto con "Git", en consola de comandos, nos ubicamos en la carpeta del proyecto y usamos el comando:

	git init

Luego añadimos la URL de GitHub (u otro servicio) como repositorio remoto:

	git remote add origin https://github.com/landinezrichard/backend.git

Creamos un archivo ".gitignore", para ignorar archivos y carpetas que no se deben subir a github (Como la carpeta node_modules, ya que allí van las dependencias del proyecto y no se deben subir a github, ya que estas dependencias son binarios y su compilación depende del sistema operativo):

	node_modules
	*.log

Nota: tambien podemos crear el archivo ".gitignore", con una herramienta online:

	https://www.toptal.com/developers/gitignore

3) En la consola, ubicados en la carpeta del proyecto, escribimos el comando "npm init", el cual va a crear el archivo "package.json":

	npm init

El comando "npm init", hará algunas preguntas iniciales sobre nuestro proyecto:

	name: nombreproyecto
	version: 1.0
	description: Api RESTful para frameworks JavaScript
	entry point: index.js
	test comand:
	git repository:
	keywords: 
	autor: Ricardo Landínez <landinezrichard@gmail.com>
	license: BSD

Nota: en licencia tambien pódemos usar ISC, MIT.

IMPORTANTE: para que npm init no falle al momento del nombre del proyecto, no usar letras mayusculas, no usar espacios, evitar el uso de carácteres especiales, signos de puntuación, etc..

Tambien podemos iniciarlo con todo en default con:

	npm init -y

_______________________________________________________

	[5]. Instalar Dependencias:
_______________________________________________________

Podremos instalar paquetes de NPM en nuestros proyectos y/o en nuestro sistema. Se pueden instalar de dos formas:

- A nivel de proyecto: usar NPM como un gestor de dependencias de un proyecto, esto es, un sistema con el que controlamos que paquetes o librerías Javascript están instalados (y que versión), de modo que quedan asociados al proyecto en sí. Esto facilita que si un usuario diferente se descarga el proyecto, pueda gestionarlo fácil y rápidamente (instalar paquetes, actualizarlos, etc...).

- A nivel global: hay paquetes que son realmente utilidades que no se utilizan en proyectos, muy común en aplicaciones de línea de comandos (CLI) que usamos desde terminal. En esta modalidad, los paquetes se instalan a nivel del sistema (no en la carpeta del proyecto), por lo que están disponibles siempre que el usuario quiera utilizarlos, sin necesidad de tenerlo en cada proyecto.

Nota: para ver comandos de instalación de paquetes globales ir a:

	https://lenguajejs.com/npm/introduccion/instalaciones-globales/
_______________________________________________________

En este caso vamos a instalar paquetes a nivel de proyecto. Nos ubicamos dentro de la carpeta del proyecto, y usamos los comandos:

	npm install --save express

Con el flag "--save", indicamos que es una dependencia de nuestro proyecto, es decir, que el proyecto necesita la libreria para funcionar. Tambien hace que en el archivo "package.json" se grabe como dependencia y aparezca la versión instalada.

Tambien podemos ahorrarnos escribir todo el "install", y si no usamos el flag "--save", igual se instala como dependencia:

	npm i express

En nuestra carpeta de proyecto, aparece una carpeta llamada "node-modules", que es donde se descargan las librerias instaladas y las dependencias de estas.

Nota 1: para buscar algun paquete o ver más información de los paquetes:

	https://www.npmjs.com/

Nota 2: Si descargamos algun proyecto de otra persona, y necesitamos instalar sus dependencias (el proyecto debe tener el archivo "package.json"), usamos el comando:

	npm install
_______________________________________________________

	[5.1]. Dependencias de desarrollo:
_______________________________________________________

Podemos instalar dependencias de desarrollo (las que no se necesitan en producción), con el flag "--save-dev":

	npm install --save-dev nodemon

Para ahorrarnos escribir todo el flag "--save-dev":

	npm i -D nodemon

_______________________________________________________

	[5.1.1]. "nodemon":
_______________________________________________________

"nodemon" es una herramienta que ayuda a desarrollar aplicaciones basadas en node.js al reiniciar automáticamente la aplicación de node cuando se detectan cambios de archivo en el directorio.

	npm install --save-dev nodemon

Tambien se puede instalar de forma global:

    npm install -g nodemon

Luego ejecutamos en consola:

    nodemon index.js

Para usar "nodemon", agregamos un nuevo script al archivo "package.json":

	"scripts": {
		"dev": "nodemon index.js",
		"start": "node index.js"
	},

Luego en la consola corremos el script con:

	npm dev

De esta forma, al hacer cambios en "index.js" (que se creara más adelante), se recarga automaticamente el script en ejecución, sin necesidad de pausarlo (ctrl + C) y volverlo a correr.
_______________________________________________________

	[5.1.2]. "pm2":
_______________________________________________________

Para tener algo similar a "nodemon" en producción usamos "pm2":

    https://pm2.keymetrics.io/

Para instalarlo:

    npm install -g pm2

Para ejecutar nuestras apps:

    pm2 start index.js

Para balancear 4 instancias de la app:

    pm2 start api.js -i 4

Este ultimo comando es muy util por ejemplo para una API, para crear una instancia por cada nucleo del procesador del servidor.

Para monitorizar la app:

    pm2 monitor

Para ver todas las apps que estan corriendo:

    pm2 status

Para ver los "logs":

    pm2 logs

Nota: para salir de ver los "logs" (ctrl + C).

Parar la app:

    pm2 stop id

Nota: el id del proceso de la app que esta corriendo es el que vemos con "pm2 status"

_______________________________________________________

	[6]. Variables de entorno:
_______________________________________________________

Las variables de entorno sirven para almacenar datos de configuración como claves de API, contraseñas o URLs, permitiendo adaptar el comportamiento de un programa sin modificar su código fuente. 

Esto facilita la gestión de aplicaciones en diferentes entornos (como desarrollo y producción), mejora la seguridad al mantener información sensible fuera del código y permite que un programa sea más flexible y portátil. 
_______________________________________________________

Si tenemos un archivo, por ejemplo, "index.js", en donde leemos variables de entorno:

    let nombre = process.env.NOMBRE || 'sin nombre';
    let web = process.env.MI_WEB || 'no tengo web';

    console.log('Hola ' + nombre);
    console.log('Mi web es ' + web);

Aca accedemos a las variables de entorno que se encuentran en "process".

Con el or "||" definimos un valor por defecto, en caso que desde la consola no definamos la variable de entorno imprimiria este valor, si no usamos el or, saca un undefined.

Para pasarle las variables de entorno a nuestro archivo desde consola usamos:

    NOMBRE=Ricardo MI_WEB=loquesea.com node index.js

En consola nos sale:

    Hola Ricardo
    Mi web es loquesea.com

Si ejecutamos sin pasarle variable:

    node index.js

Sale en consola:

    Hola sin nombre
    Mi web es no tengo web

Nota: en PowerShell hay que definir primero las variables de entorno:

    $env:NOMBRE="Ricardo"

Y luego ejecutar:

    node index.js
_______________________________________________________

	[7]. Qué es "express":
_______________________________________________________

Es el framework más popular de Node, es la herramienta sobre la cual están desarrollados otros frameworks como MEAN, SAILS, LOOPBACK, GRAPHQL YOGA y otros.

Soporta los diferentes verbos o acciones de HTTP (POST, GET, PUT, PATCH, DELETE) en las rutas (routing).

Permite creación de aplicaciones MVC (Modelo Vista Controlador) para separar y organizar el código.

Soporta Middlewares (peticiones que se ejecutan en la tuberia de la petición).

"express" es una libreria que nos proporciona herramientas pequeñas y sólidas para servidores HTTP, lo que la convierte en una gran solución para aplicaciones de una sola página, sitios web, híbridos o API HTTP públicas. Nos va a servir para crear las diferentes rutas de nuestro proyecto.

"express" es como "Apache" en PHP.

Lo instalamos con:

	npm install --save express
_______________________________________________________

	[7.1]. Archivo base de "express":
_______________________________________________________

En la raíz del proyecto creamos el archivo "index.js":

	const express = require('express');

	// Crear la app
	const app = express();

	// Definir puerto
	const port = process.env.PORT || 4000;

	// Arrancar la app
	app.listen(port, () => {
		console.log(`Servidor funcionando en el puerto ${port}`);
	});

Este archivo usa la sintaxis "CommonJs", que es con la que empezo Node y muchas de sus librerias.

En el puerto, definimos que en local use el puerto 4000, pero si la variable de entorno del puerto está disponible, la usa. Esto ya queda listo y con soporte tanto en desarrollo como en producción.

Al ejecutar en consola:

	npm run dev

Podemos ver el mensaje:

	Servidor funcionando en el puerto 4000

_______________________________________________________

	[7.2]. Habilitar modulos:
_______________________________________________________

Para cambiar la sintaxis de "CommonJs" y usar "imports" y "exports" (modulois ECMAScript), en el archivo "package.json" agregamos:

	"type": "module",

Y luego en nuestro archivo base de "express", "index.js":

	import express from "express";

_______________________________________________________

	[7.3]. "Hola mundo!" en "express":
_______________________________________________________

Completamos el archivo "index.js":

	import express from "express";

	const app = express();

	// Definir puerto
	const port = process.env.PORT || 4000;

	// Routing
	app.get("/", (req, res) => {
		res.send("Hello World!");
	});

	app.listen(port, () => {
		console.log(`Servidor funcionando en el puerto ${port}`);
	});

Acá usamos la acción "GET", el callback recibe un "req" ("request" o petición) y un "res" ("response" o respuesta).

"req" --> la petición que se envia al servidor.

"res" --> la respuesta de "express".

Podemos ver el "Hello World!" en el navegador, en la siguiente ruta:

	http://localhost:4000/

_______________________________________________________

Tambien podemos responder con JSON:

	app.get("/", (req, res) => {
		res.json({
			id: 1
		});
	});

_______________________________________________________

Y responder con el renderizado de una vista:

	app.get("/", (req, res) => {
		res.render('nombreVista');
	});

_______________________________________________________

	[7.4]. "Routing" en "express":
_______________________________________________________

El "Routing" es por donde van a transitar (los "endpoints", donde se registran, donde llenan el formulario, donde consulatar la información, etc.) los usuarios de nuestro sitio web o aplicación.

1) Podemos definir varias rutas:

	// Routing
	app.get("/", (req, res) => {
		res.send("Hello World!");
	});

	app.get("/nosotros", (req, res) => {
		res.send("Nosotros");
	});

	app.get("/contacto", (req, res) => {
		res.send("Contacto");
	});

2) Cuando ya tenemos varias rutas, lo mejor es separar el Routing en otro archivo, para esto, creamos una carpeta llamada "routes", y dentro de esta un archivo "index.js":

	import express from "express";

	const router = express.Router();

	router.get("/", (req, res) => {
		res.send("Hello World!");
	});

	router.get("/nosotros", (req, res) => {
		res.send("Nosotros");
	});

	router.get("/contacto", (req, res) => {
		res.send("Contacto");
	});

	export default router;

Importamos "express", pero solo usamos el "Router" de esté, ya que solo puede existir una instancia de "express".

Nota: el archivo "index.js" lo podemos nombrar como queramos, por ejemplo "usuarioRoutes.js".

3) Ahora en nuestro archivo principal, importamos y usamos el "router":

	import express from "express";
	import router from "./routes/index.js";

	// Crear la app
	const app = express();

	// Definir puerto
	const port = process.env.PORT || 4000;

	// Routing
	app.use("/", router);

	// Arrancar la app
	app.listen(port, () => {
		console.log(`Servidor funcionando en el puerto ${port}`);
	});

Aca el método "use", soporta todos los verbos o acciones HTTP(GET, POST, etc.), resuelve cualquier petición a "/", buscando en el archivo de "routing".

Nota: como el "router" es un archivo que nosotros creamos y no una dependencia, es necesario indicar la extensión y la ruta del archivo para importarlo.

Podemos probar las rutas en el navegador, por ejemplo:

	http://localhost:4000/nosotros

_______________________________________________________

	[7.4.1]. Métodos HTTP:
_______________________________________________________

Los métodos HTTP que usamos son:

- GET --> Utilizado para mostrar información.
- POST --> Utilizado para enviar información.
- PUT / PATCH --> Utilizado para actualizar información.
- DELETE --> Utilizado para eliminar información.
_______________________________________________________

	[7.4.2]. Peticiones GET y POST:
_______________________________________________________

Al crear las rutas, hay que tener en cuenta que una ruta(url) solo puede existir una vez (no se puesde repetir dos veses "/nosotros" por ejemplo), sin embargo, se puede tener la misma ruta con diferente acción:

	router.get("/", (req, res) => {
		res.send("Hello World!");
	});

	router.post("/", (req, res) => {
		res.send("Para recibir datos del formulario");
	});

Tambien podemos tener el mismo resultado de la siguiente forma:

	router.route('/')
		.get(function(req, res) => {
			res.send("Hello World!");
		})
		.post(function(req, res) => {
			res.send("Para recibir datos del formulario");
		})

_______________________________________________________

	[7.5]. Template engines:
_______________________________________________________

"Template Engines" o Motores de Plantilla son tecnologías que nos permiten 
crear el código HTML y mostrar información contenida en variables de una 
forma más compacta y clara.

Pug, Handlebars, EJS son las opciones más populares para Node.js.

También es posible utilizar React, Angular, Svelte o Vue como tu 
Template Engine, reemplazando a los "template engines" pero necesitarás crear una API con respuestas JSON. 
_______________________________________________________

	[7.5.1]. Instalando PUG:
_______________________________________________________

1) Instalamos PUG como depenedencia:

	npm i pug

2) En nuestro archivo principal "index.js", habilitamos PUG como "template engine":

	// Habilitar PUG
	app.set("view engine", "pug");

3) Creamos una carpeta llamada "views", y dentro de está un archivo para la vista llamado "nosotros.pug":

	h1 Nosotros

4) En el "router", renderizamos la vista en su respectiva "url", en el archivo "routes\index.js":

	router.get("/nosotros", (req, res) => {
		res.render('nosotros');
	});
_______________________________________________________

	[7.5.2]. Pasar variables hacia las vistas:
_______________________________________________________

Podemos pasar variables hacia las vistas, por ejemplo desde el router le pasamos un objeto a la vista:

	router.get("/nosotros", (req, res) => {
		const variable = "Algun valor";
		res.render('nosotros', { variable });
	});

Luego en la vista "views\nosotros.pug":

	h1 Nosotros
	p Aquí muestro los datos #{variable}.
_______________________________________________________

	[7.5.3]. Crear Layout principal:
_______________________________________________________

Podemos crear un Layout principal, con el titulo de la página, el llamado a las hojas de estilos, etc, para poder reutilizarlo.

1) Creamos una carpeta llamada "layout" dentro de la carpeta "views".

2) Creamos dentro de la carpeta "layout" un archivo "index.pug":

	doctype html
	html(lang="es")
		head
			meta(charset="utf-8")
			meta(name="viewport", content="width=device-width, initial-scale=1, maximum-scale=1")
			title Agencia de Viajes
		body
			h1 Agencia de Viajes
			block contenido

3) Usamos el layout en el archivo "views\nosotros.pug":

	extends layout/index.pug

	block contenido
		p Nosotros

_______________________________________________________

	[7.6]. Servir archivos estáticos:
_______________________________________________________

Podemos servir archivos estáticos en "express", como archivos CSS, imagenes, fuentes, etc.

1) Creamos en la raíz del proyecto una carpeta llamada "public".

2) Dentro de la carpeta "public", creamos las carpetas "css", "img", "fonts", etc. con sus respectivos archivos.

3) En el archivo principal "index.js", definimos la carpeta "public":

	// Definir la carpeta publica
	app.use(express.static("public"));

4) Ya podemos usar archivos estaticos en las vistas:

	doctype html
	html(lang="es")
		head
			meta(charset="utf-8")
			meta(name="viewport", content="width=device-width, initial-scale=1, maximum-scale=1")
			title Agencia de Viajes
			link(rel='preconnect' href='https://fonts.googleapis.com')
			link(rel='preconnect' href='https://fonts.gstatic.com' crossorigin='')
			link(href='https://fonts.googleapis.com/css2?family=Covered+By+Your+Grace&family=Staatliches&display=swap' rel='stylesheet')
			link(rel="stylesheet", href="/css/bootstrap.css")
			link(rel="stylesheet", href="/css/style.css")
		body
			h1 Agencia de Viajes
			img(src="/img/cupon.jpg", alt="Cupon Agencia de Viajes")
			block contenido

_______________________________________________________

	[7.7]. "middleware":
_______________________________________________________

Un "middleware" actúa como una capa intermedia entre la solicitud del cliente y las rutas finales de la aplicación. Funcionan como un puente entre el servidor y la aplicación, interceptando y manipulando la solicitud antes de que se envíe a su destino final.

En el archivo principal "index.js":

	import express from "express";
	import router from "./routes/index.js";

	// Crear la app
	const app = express();

	// Definir puerto
	const port = process.env.PORT || 4000;

	// Habilitar PUG
	app.set("view engine", "pug");

	// Definir la carpeta publica
	app.use(express.static("public"));

	// Routing
	app.use("/", router);

	// Arrancar la app
	app.listen(port, () => {
		console.log(`Servidor funcionando en el puerto ${port}`);
	});

Cada "app.set", "app.use" y "app.listen" son "middlewares".

Podemos crear un "middleware" propio:

	// Obtener el año actual
	app.use( (req, res, next) => {
		const year = new Date();
		res.locals.actualYear = year.getFullYear();
		next();
	});

Vemos que en el callback, además del "req" ("request") y el "res" ("response"), resive un "next", que es con lo que le indicamos que, despues de realizar los calculos o lo que queramos, ya puede pasar al siguiente "middleware".

Nota: si no pasa al siguiente "middleware", podemos forzarlo con:

	return next();

"locals", es un objeto con variables internas de "express", y nos permite pasar valores de un archivo a la vista o de un archivo a otro.

Luego usamos nuestra variable en la vista:

	p.copyright.text-center.text-md-right &copy; Todos los derechos reservados. #{actualYear}
_______________________________________________________

	[7.8]. "Controllers":
_______________________________________________________

Los "Controllers" o controladores, son los encargados de solicitar al modelo ("model") los datos, y luego enviarlos a la vista ("view") para que está ultima los muestre.

1) En la raíz de nuestro proyecto creamos la carpeta "controllers".

2) Creamos dentro de la carpeta "controllers", el controlador, en este caso "usuarioController.js":

	const formularioLogin = (req, res) => {
		res.render("auth/login");
	};

	export { formularioLogin };

En este caso, le estamos quitando responsabilidades al "router".

Nota 1: el nombre del archivo tambien puede ser:

	"usuario.controller.js"

Esto ya depende de las convenciones que maneje el proyecto.

Nota 2: Si se necesita enviar datos a la vista, se hace ahora en el "controller".

3) En el "router" importamos el controlador:

	import express from "express";
	import { formularioLogin } from "../controllers/usuarioController.js";

	const router = express.Router();

	router.get("/login", formularioLogin);

	export default router;

_______________________________________________________

	[7.9]. ORM's y Bases de Datos:
_______________________________________________________

Un ORM (Object Relational Mapping), es una herramienta de programación que actúa como intermediario entre una aplicación y una base de datos relacional, facilitando la interacción con los datos sin necesidad de escribir código SQL directamente.

Convierte los objetos de un lenguaje de programación en el formato adecuado para ser almacenado en la base de datos y, a su vez, traduce los resultados de las consultas de la base de datos en objetos que la aplicación puede usar.

En MVC; un ORM se relaciona bastante con el Modelo

Node.js tiene una gran cantidad de ORM’s que se instalan como librería, algunos de los más populares son:

- Prisma
- Mongoose
- Sequelize
- TypeORM
- Bookshelf.js

_______________________________________________________

	[7.9.1]. Sequelize y MySQL:
_______________________________________________________

1) Instalamos el ORM Sequelize y MySQL2 como dependencias:

	npm i sequelize mysql2

Nota: debemos tambien instalar MySQl:

	https://www.mysql.com/downloads/

El "mysql2" que instalamos con Node, es el driver(controlador) para nuestra base de datos.

"Sequelize" tambien acepta otros motores de BD como Postgres, MariaDB, etc.

Nota: para más info de Sequelize, ir a:

	https://sequelize.org/

2) Ingresamos a MySQL en modo terminal:

	mysql -u root -p

3) Crear Base de Datos:

	CREATE DATABASE bienesraices_node_mvc;

4) En la raíz de nuestro proyecto, creamos una carpeta llamada "config", y dentro un archivo "db.js":

	import { Sequelize } from "sequelize";

	const db = new Sequelize('bienesraices_node_mvc', 'root', 'root', {
		host: 'localhost',
		port: 3306,
		dialect: 'mysql',
		define: {
			timestamps: true
		},
		pool: {
			max: 5,
			min: 0,
			acquire: 30000,
			idle: 10000
		},
	});

	export default db;

Este archivo trae la configuración de conexión a nuestra base de datos. En donde:

	const db = new Sequelize('nombreBaseDatos', 'usuarioBD', 'passwordBD', {objetoConfiguracion});

Acá creamos la instancia de Sequelize. En el Objeto de configuración tenemos:

	"timestamps" --> Hacemos que automáticamente en la tabla se agreguen dos columnas extras, de la fecha de creación del registro, y de la fecha de actualización del registro.

	"pool" --> el conecction pool, en donde:

	"max" --> el número de conexiones máximas por persona.

	"min" --> igualamos a cero(0) para indicar que cuando no haya actividad en el sitio se desconecta para liberar recursos.

	"acquire" --> en milisegundos, en este caso son "30 seg" para intentar crear la conexión antes de generar un error.

	"idle" --> en milisegundos, en este caso "10 seg", si no hay actividad en el sitio en ese tiempo, se finaliza la conexión a la BD.

5) En nuestro archivo principal de "express", "index.js", llamamos la conexión de la BD:

	import express from "express";
	import usuarioRoutes from "./routes/usuarioRoutes.js";
	import db from "./config/db.js";

	// Crear la app
	const app = express();

	// Conectar a la base de datos
	try {
		await db.authenticate();
		console.log('Conectado a la base de datos.');
	} catch (error) {
		console.error('No se pudo conectar a la base de datos:', error);
	}

_______________________________________________________

	[7.9.1.1]. Información de la BD en variables de entorno:
_______________________________________________________

Para ocultar la información de la base de datos en variables de entorno, primero instalamos "dotenv":

	npm i dotenv

Dotenv es un módulo sin dependencias que carga variables de entorno desde un archivo .env a process.env.

Nota: para más info de Dotenv, ir a:

	https://github.com/motdotla/dotenv#readme

2) En la raíz del proyecto, creamos un archivo ".env" con los datos a proteger:

	BD_NOMBRE=bienesraices_node_mvc
	BD_USUARIO=root
	BD_PASSWORD=root
	BD_HOST=localhost
	BD_PORT=3306

3) En el archivo de configuración de conexión con la Base de Datos "config\db.js":

	import { Sequelize } from "sequelize";
	import dotenv from 'dotenv';
	dotenv.config({ path: './.env' })

	const db = new Sequelize(process.env.BD_NOMBRE, process.env.BD_USUARIO, process.env.BD_PASSWORD, {
		host: process.env.BD_HOST,
		port: process.env.BD_PORT,
		dialect: 'mysql',
		define: {
			timestamps: true
		},
		pool: {
			max: 5,
			min: 0,
			acquire: 30000,
			idle: 10000
		}
	});

	export default db;

Importamos "dotenv", con "dotenv.config" definimos la ruta al archivo ".env", y con "process.env.", llamamos las variables de entorno definidas.
_______________________________________________________

	[7.9.1.2]. Modelo:
_______________________________________________________

El modelo ("model"), es le encargado de solicitar datos a la BD y de la lógica para mostrar esos datos.

Para crear un modelo:

1) Creamos en la raíz del proyecto una carpeta llamada "models".

2) Dentro de la carpeta "models", creamos el modelo, por convención se pone la primera letra en mayuscula, como si fuera una clase.

Ejemplo: archivo "Usuario.js":

	import { DataTypes } from "sequelize";
	import db from "../config/db.js";

	const Usuario = db.define("usuarios", {
		nombre: {
			type: DataTypes.STRING,
			allowNull: false,
		},
		email: {
			type: DataTypes.STRING,
			allowNull: false,
		},
		password: {
			type: DataTypes.STRING,
			allowNull: false,
		},
		token: DataTypes.STRING,
		confirmado: DataTypes.BOOLEAN,
	});

	export default Usuario;

Aca definimos el nombre de la tabla "usuarios", los campos que va a tener (nombre, email, password, etc.) y el tipo de datos del campo. Con "allowNull" indicamos que ese campo no debe estar vacio.

Nota 1: el "id" no es necesario especificarlo porque ya Sequelize asume que existe en la BD.

Nota 2: para más info de todos los tipos de datos disponibles, ir a:

	https://sequelize.org/docs/v6/core-concepts/model-basics/#data-types
_______________________________________________________

	[7.9.1.3]. Comunicar vista con routing y controller:
_______________________________________________________

1) Creamos la función en el controlador "controllers\usuarioController.js" y la exportamos:

	const registrar = (req, res) => {
		console.log('Registrando usuario...');
	};

	export { formularioLogin, formularioRegistro, registrar, formularioOlvidoPassword };

2) En el router "routes\usuarioRoutes.js", creamos la ruta, importamos y llamamos la función: 

	import { formularioLogin, formularioRegistro, registrar, formularioOlvidoPassword } from "../controllers/usuarioController.js";

	router.get("/registro", formularioRegistro);
	router.post("/registro", registrar);

En este caso recibe datos via POST de un formulario de registro de usuarios.

3) En la vista "views\auth\registro.pug", agregamos el método, y la acción en el formulario de registro:

	form.space-y-5(method="POST", action="/auth/registro")

_______________________________________________________

	[7.9.1.4]. Leer datos de un formulario:
_______________________________________________________

1) En nuestro archivo principal "index.js" habilitamos la lectura de los datos del formulario:

	// Habilitar lectura de datos de formularios
	app.use(express.urlencoded({ extended: true }));

Nota: está es la nueva forma de habilitar la lectura de datos del formulario, ya que antes "Express" no venia con esta funcionalidad y teniamos que usar otras librerias como "body-parser":

	let bodyParser = require("body-parser");
	
	// Middlewares
	// usar el body-parser
	app.use(bodyParser.urlencoded({extended:false}));
	app.use(bodyParser.json());

2) En el controlador "controllers\usuarioController.js", leemos los datos enviados por el formulario:

	const registrar = (req, res) => {
		console.log('Registrando usuario...', req.body);
	};

En consola podremos ver:

	Rergistrando usuario... {
		nombre: 'Ricardo',
		email: 'correo@correo.com',
		password: '123456',
		repetir_password: '123456'
	}

La "key" de los campos (nombre, email, password) corresponde al "name" de los campos en el formulario.

3) En el controlador es necesario validar los campos (que no esten vacios, etc.), antes de almacenar los datos en la BD.

Ejemplo:

	import { Testimonial } from "../models/Testimonial.js";

	const guardarTestimonial = async (req, res) => {
		const { nombre, correo, mensaje } = req.body;

		//Validar que los campos no esten vacios
		const errores = [];
		if (nombre.trim() === "") {
			errores.push({ mensaje: "El nombre esta vacio" });
		}
		if (correo.trim() === "") {
			errores.push({ mensaje: "El correo esta vacio" });
		}
		if (mensaje.trim() === "") {
			errores.push({ mensaje: "El mensaje esta vacio" });
		}

		if (errores.length > 0) {
			//Mostrar los errores en la vista
			res.render("testimoniales", {
				pagina: "Testimoniales",
				errores,
				nombre,
				correo,
				mensaje,
			});
		} else {
			//Almacenar el testimonial en la BD
			try {
				await Testimonial.create({
					nombre,
					correo,
					mensaje,
				});
				res.redirect("/testimoniales");
			} catch (error) {
				console.log(error);
			}
		}
	};

	export { guardarTestimonial };

_______________________________________________________

	[7.9.1.5]. Consultar la BD:
_______________________________________________________

Para consultar los datos de una BD, se hace directamente desde el controlador.

1) En el controlador "controllers\paginasController.js":

	import { Viaje } from "../models/Viaje.js";

	const paginaViajes = async (req, res) => {
		// Consultar BD
		const viajes = await Viaje.findAll();

		res.render("viajes", {
			pagina: "Viajes",
			viajes
		});
	};

Primero importamos el modelo, luego la función correspondiente del controlador la volvemos asincrona ("async").

Consultamos todos los registros de la tabla "viajes", con el modelo, y el metodo de "Sequelize" ".findAll()".

Luego le pasamos el array de "viajes" a la vista.

Nota: para más info de las consultas en Sequelize, ir a:

	https://sequelize.org/docs/v6/core-concepts/model-querying-basics/

2) En la vista "views\viajes.pug", iteramos por cada elemento del array:

	each viaje in viajes
		.col-md-6.col-lg-4.mb-4
			.card
				img.card-img-top(src=`/img/destinos_${viaje.imagen}.jpg` alt=`Imagen del viaje a ${viaje.titulo}`)
				.card-body
					h2.card-title #{viaje.titulo}
					p
						| #{viaje.fecha_ida} - #{viaje.fecha_vuelta}
					p
						| #{viaje.disponibles} Disponibles
					p.card-text #{viaje.descripcion.substr(0, 100)}...
					p.precio $#{viaje.precio}
					a.btn.btn-success.btn-block(href=`/viajes/${viaje.slug}`) Más información
_______________________________________________________

	[7.9.1.5.1]. Limitar datos consulta:
_______________________________________________________

Podemos limitar el número de resultados obtenidos de la BD:

	const paginaInicio = async (req, res) => {
		// Consultar 3 viajes del modelo Viaje
		try {
			const viajes = await Viaje.findAll({ limit: 3 });
			
			res.render("inicio", {
				pagina: "Inicio",
				clase: "home",
				viajes,
			});
		} catch (error) {
			console.log("Error al obtener los viajes: ", error);
		}
	};

En este caso al método "findAll()", le pasamos un objeto con "limit: 3", para limitar a solo tres resultados.
_______________________________________________________

	[7.9.1.5.2]. Consultar la BD según URL:
_______________________________________________________

Podemos consultar el detalle de un elemento visitando una url en especifico, por ejemplo:

	http://localhost:4000/viajes/viaje-italia

Para poder hacerlo:

1) En el router, creamos la nueva ruta:

	import { paginaInicio, paginaNosotros, paginaViajes, paginaDetalleViaje, paginaTestimoniales } from "../controllers/paginasController.js";

	router.get("/viajes/:slug", paginaDetalleViaje);

En este caso, la URL, recibe un parámetro "slug", el  es requerido.

2) En el controlador "controllers\paginasController.js":

	// Muestra un viaje por su slug
	const paginaDetalleViaje = async (req, res) => {
		const { slug } = req.params;

		console.log("Detalle viaje: ", slug);

		try {
			const viaje = await Viaje.findOne({ where: { slug } });
			res.render("viaje", {
				pagina: "Información Viaje",
				viaje,
			});
		} catch (error) {
			console.log("Error al obtener el viaje: ", error);
		}
	};

Con "req.params", obtenemos los parámetros que se envian por URL, en este caso desestructuramos "slug", que es el nombre que definimos en el router para ese parámetro.

Con ".findOne({ where: { slug } })" buscamos en la BD un viaje cuyo slug sea igual al indicado, es lo mismo que tener:

	.findOne({ where: { slug: slug } })

Pero como el nombre del parámetro es igual a la variable, se simplifica.

Nota: para más info de este método de Sequelize, ir a:

	https://sequelize.org/docs/v6/core-concepts/model-querying-finders/#findone

Luego de obtener de la BD el resultado, renderizamos la vista del detalle, pasandole los datos correspondientes.

En el catch, tambien podemos renderizar una página de 404.

3) Renderizamos la vista del detalle "views\viaje.pug":

	extends layout/index.pug

	block contenido
		main.container.mt-5
			.row
				.col-md-5
					img.img-fluid(src=`/img/destinos_${viaje.imagen}_ln.jpg`, alt=`imagen viaje a ${viaje.titulo}`)
				.col-md-7
					h1 #{viaje.titulo}
					p
						|	#{viaje.fecha_ida} - #{viaje.fecha_vuelta}
					p.precio
						|	$#{viaje.precio} USD
					p
						|	#{viaje.disponibles} Disponibles
					p.card-text #{viaje.descripcion}
_______________________________________________________

	[7.9.1.5.3]. Múltiples consultas:
_______________________________________________________

Para hacer múltiples consultas al mismo tiempo a la BD, usamos promesas:

	const paginaInicio = async (req, res) => {
		// Consultar 3 viajes del modelo Viaje
		const promiseDB = [];

		promiseDB.push( Viaje.findAll({ limit: 3 }) );
		promiseDB.push( Testimonial.findAll({ limit: 3 }) );

		try {
			const resultado = await Promise.all( promiseDB );

			res.render("inicio", {
				pagina: "Inicio",
				clase: "home",
				viajes: resultado[0],
				testimoniales: resultado[1],
			});
		} catch (error) {
			console.log("Error al obtener los viajes: ", error);
		}
	};

Se crea un arreglo con las consultas a la BD, y con "Promise.all()", ejecutamos las promesas, la respuesta de estas, quedan en otro array llamado "resultado".