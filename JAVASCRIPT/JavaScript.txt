
	JavaScript:
_______________________________________________________

INDICE:

[1]. Inclución de JavaScript
[2]. Impresión de datos
[3]. Variables y Comentarios
[4]. Estructuras de control
	[4.1]. Condicional if/else
	[4.2]. Operador ternario
	[4.3]. Switch
	[4.4]. Optional chaining
[5]. Arrays
	[5.1]. Acceso a los Elementos del Array
	[5.2]. Recorrido Arrays
		[5.2.1]. Recorrido con "forEach"
		[5.2.2]. Recorrido con ".map"
		[5.2.3]. Recorrido con ciclo "For In"
[6]. Funciones
	[6.0.1]. Parametros por default
	[6.1]. Funciones Anónimas
	[6.2]. Funciones Callbacks
	[6.3]. Funciones Autoejecutables
	[6.4]. Funciones Clausuras
	[6.5]. Funciones flecha
	[6.6]. Funciones para Strings
	[6.7]. Funciones para Arrays
		[6.7.1]. Ordenando Arrays
		[6.7.2]. Filtrando Arrays
		[6.7.3]. Buscando en Arrays
		[6.7.4]. Acumulador ".reduce"
	[6.8]. Funciones para Números
[7]. Objetos
	[7.1]. Acceso a las propiedades del objeto
		[7.1.1]. Agregar o eliminar propiedades del objeto
		[7.1.2]. Destructuring de objetos
			[7.1.2.1]. Destructuring de objetos anidados
	[7.2]. Copiar 2 Objetos | "Spread Operator"
	[7.3]. Métodos del objeto
		[7.3.1]. Acceso a los metodos del objeto
	[7.4]. Object .keys, .values y .entries
	[7.5]. JSON
		[7.5.1]. Convertir JSON a Objeto
		[7.5.2]. Convertir Objeto a JSON
	[7.6]. CLASES
		[7.6.1]. Métodos Estáticos
		[7.6.2]. Constructores
		[7.6.3]. Propiedades
			[7.6.3.1]. Ámbitos en una clase
			[7.6.3.2]. Propiedades Privadas
			[7.6.3.3]. Getters
			[7.6.3.4]. Setters
		[7.6.4]. Herencia
	[7.7]. Prototypes
	[7.8]. Binding
		[7.8.1]. Implicit Binding
		[7.8.2]. Explicit Binding
		[7.8.3]. New Binding y Window Binding
[8]. Elementos DOM
	[8.1]. Acceso a los Nodos(Métodos Clasicos)
	[8.2]. Acceso a los Nodos(Métodos Modernos)
	[8.3]. Contenido de los elementos
	[8.4]. Crear elementos
	[8.5]. Atributos de un elemento
		[8.5.1]. Atributo "Class" de un elemento
	[8.6]. Insertar Elementos
	[8.7]. Eliminar Elementos
	[8.8]. Elementos Relacionados
	[8.9]. Resumen Crear y Añadir Elementos
	[8.10]. Librerías para manejar Elementos
[9]. Eventos
	[9.1]. Manejador de Eventos
		[9.1.1]. Metodo "addEventListener()"
			[9.1.1.1]. Evento "DOMContentLoaded()"
		[9.1.2]. Metodo "removeEventListener()"
[10]. localStorage
	[10.1]. Obtener datos de "localStorage"
	[10.2]. Eliminar y actualizar datos de "localStorage"
[11]. Fechas
[12]. Sets, Maps y Symbols
	[12.1]. WeakSets
	[12.2]. Maps
	[12.3]. WeakMaps
	[12.4]. Symbols
	[12.5]. Iteradores
	[12.6]. Generadores
	[12.7]. Iteradores "entries", "values", "keys" y "default"
[13]. Módulos ECMAScript (ESM)
	[13.1]. Exportación de Módulos
	[13.2]. Importación de Módulos
	[13.3]. Convenciones de módulos ES
	[13.4]. Ejemplos
[14]. IndexedDB
	[14.1]. Crear IndexedDB
	[14.2]. Crear tablas en IndexedDB
	[14.3]. Crear registros
	[14.4]. Recorrer registros
	[14.5]. Actualizar un registro
	[14.6]. Eliminar un registro
[15]. API's en JavaScript
	[15.1]. Notification API
	[15.2]. Intersection Observer
	[15.3]. Detectar conexión a internet
	[15.4]. Ejecutar pantalla completa
	[15.5]. Detectar cuando se esta viendo la página web
	[15.6]. Speech API
[16]. Asincronía
	[16.0]. AJAX Peticiones HTTP
	[16.1]. XHR: "XMLHttpRequest"
		[16.1.1]. Propiedades XHR
		[16.1.2]. Métodos XHR
		[16.1.3]. Eventos XHR
	[16.2]. PROMESAS (promise)
	[16.3]. Fetch
		[16.3.1]. Cabeceras (Headers)
		[16.3.2]. Respuesta de la petición HTTP
		[16.3.3]. Métodos del objeto "response"
		[16.3.4]. Ejemplos
			[16.3.4.1]. Ejemplo usando promesas
	[16.4.0]. Try/catch
	[16.4]. Async/await
		[16.4.1]. Manejar múltiples awaits
		[16.4.2]. Async/await hacia una API con Fetch
	[16.5]. Política CORS



_______________________________________________________

	[1]. Inclución de JavaScript:
_______________________________________________________

JavaScript es un lenguaje de programación que se utiliza principalmente para crear páginas web dinámicas (con efectos, animaciones e interacción con el usuario).

Al igual que CSS, se puede incluir de 3 formas:

1) En línea:
	<p onclick="alert('Un mensaje de prueba')">Un párrafo de texto.</p>
    
2) Forma interna embebida:
	<head>
		<script type="text/javascript">
			alert("Un mensaje de prueba");
		</script>
	</head>
3) Archivo externo "pagina.html":

	<!DOCTYPE html>
	<html lang="es">
		<head>
			<meta charset="utf-8"/>
			<title>Incluir JavaScript archivo externo</title>
			<!--Scripts en el Head -->
			<script type="text/javascript" src="myScript.js">
			</script>
		</head>
		<body>
			<h1>Página Web</h1>
			<p id="demo">Este es un parrafo</p>
			<button type="button" onclick="myFunction()">Cambiar!!!</button>

			<!--Scripts en el Body -->
			<script type="text/javascript" src="myScript2.js">
			</script>
		</body>
	</html>

Archivo "myScript.js":

	function myFunction() {
  		document.getElementById("demo").innerHTML = "Parrafo cambiado.";
	}

Nota: Colocar scripts en la parte inferior del elemento "<body>" mejora la velocidad de visualización, porque la interpretación de los scripts ralentiza la visualización.
_______________________________________________________

	[2]. Impresión de datos:
_______________________________________________________

JavaScript puede "mostrar" datos de diferentes maneras:

- Escribir en un elemento HTML, usando "innerHTML".

	<!DOCTYPE html>
	<html>
	<body>
		<h1>My First Web Page</h1>
		<p>My First Paragraph</p>

		<p id="demo"></p>

		<script>
			document.getElementById("demo").innerHTML = 5 + 6;
		</script>

	</body>
	</html>

- Escribir en la salida HTML usando "document.write()".

	<!DOCTYPE html>
	<html>
	<body>
		<h1>My First Web Page</h1>
		<p>My first paragraph.</p>

		<script>
			document.write(5 + 6);
		</script>

	</body>
	</html>

Nota: Si usa "document.write()" después de cargar un documento HTML, eliminará todo el HTML existente. Por eso solo se debe usar para pruebas.

- Escribir en un cuadro de alerta, usando "window.alert()".

	<!DOCTYPE html>
	<html>
	<body>
		<h1>My First Web Page</h1>
		<p>My first paragraph.</p>

		<script>
			window.alert(5 + 6);
		</script>

	</body>
	</html>

Nota: En JavaScript, el objeto "window" es el objeto de alcance global, lo que significa que las variables, propiedades y métodos pertenecen por defecto al objeto "window". Esto también significa que especificar la palabra clave "window" es opcional.

- Escribir en la consola del navegador, usando "console.log()".

	<!DOCTYPE html>
	<html>
	<body>
		<script>
			console.log(5 + 6);
		</script>
	</body>
	</html>

Nota1: este se usa para fines de depuración(debugging).

Nota2: pulsar CTRL+SHIFT+I sobre la pestaña de la página web en cuestión, lo que nos llevará al Inspector de elementos.

Nota3: para más info de la consola ir a: 

	https://lenguajejs.com/javascript/introduccion/consola-de-javascript/
_______________________________________________________

	[3]. Variables y Comentarios:
_______________________________________________________

En un lenguaje de programación, las variables se utilizan para almacenar valores de datos.

JavaScript usa la palabra clave "var" para declarar variables.

Se utiliza un signo igual para asignar valores a las variables.

	//Comentario de una línea
	/*
		Comentario de varias lineas
	*/

	var x, y, z;       // Declarar variables
	x = 5; y = 34.6;      // Asignar valores
	z = x + y;         // Calcular valores

	var person = "Jackie Chan";
	var answer = 'Yes I am!';

	//Declaración de muchas variables en una sola sentencia
	var person = "John Doe", carName = "Volvo", price = 200;

Siempre que sea posible se debería utilizar "let" y "const", en lugar de var. Declarar variables mediante var se recomienda en fases de aprendizaje o en el caso de que se quiera mantener compatibilidad con navegadores muy antiguos utilizando ECMAScript 5.

"let" es para tener claridad en el ambito de la variable:

	// Opción 1: Bucle con let
	console.log("Antes: ", p); // Antes: undefined
	for (
		let p = 0;
		p < 3;
		p++ // - 0
	)
  		console.log("- ", p); // - 1
	// - 2
	console.log("Después: ", p); // Después: undefined

	// Opción 2: Bucle con var
	console.log("Antes: ", p); // Antes: undefined
	for (
		var p = 0;
		p < 3;
		p++ // - 0
	)
		console.log("- ", p); // - 1
	// - 2
	console.log("Después: ", p); // Después: 3 (WTF!)

Mientras que en el ciclo con "let", antes y despues del ciclo la variable "p" no está definida (ámbito local), en el ciclo con "var", vemos que fuera del ciclo "p" queda con el valor "3", y sigue existiendo fuera del ciclo (ámbito global).

En ECMAScript 2015 (ES6) se añade la palabra clave "const", que inicializada con un valor concreto, permite crear variables con valores que no pueden ser cambiados.

	const NAME = "Sandra";
_______________________________________________________

	[4]. Estructuras de control:
_______________________________________________________

Al hacer un programa necesitaremos establecer condiciones o decisiones, donde buscamos que el navegador realice una acción A si se cumple una condición o una acción B si no se cumple. 
_______________________________________________________

	[4.1]. Condicional if/else:
_______________________________________________________

Condición con alternativa:

	var nota = 7;
	console.log("He realizado mi examen. Mi resultado es el siguiente:");

	// Condición
	if (nota < 5) {
		// Acción A (nota es menor que 5)
		calificacion = "suspendido";
	} else {
		// Acción B: Cualquier otro caso a A (nota es mayor o igual que 5)
		calificacion = "aprobado";
	}

	console.log("Estoy", calificacion);
_______________________________________________________

	[4.2]. Operador ternario:
_______________________________________________________

Operador ternario (If/else abreviado)

	var nota = 7;
	console.log("He realizado mi examen. Mi resultado es el siguiente:");

	// Operador ternario: (condición ? verdadero : falso)
	var calificacion = nota < 5 ? "suspendido" : "aprobado";

	console.log("Estoy", calificacion);
_______________________________________________________

	[4.3]. Switch:
_______________________________________________________

Permite definir casos específicos a realizar en el caso de que la variable expuesta como condición sea igual a los valores que se especifican a continuación mediante los "case".

	var nota = 7;
	console.log("He realizado mi examen. Mi resultado es el siguiente:");

	switch (nota) {
		case 10:
			calificacion = "Insuficiente";
			break;
		case 9:
		case 8:
			calificacion = "Notable";
			break;
		case 7:
		case 6:
			calificacion = "Bien";
			break;
		case 5:
			calificacion = "Suficiente";
			break;
		case 4:
		case 3:
		case 2:
		case 1:
		case 0:
			calificacion = "Insuficiente";
			break;
		default:
			// Cualquier otro caso
			calificacion = "Nota errónea";
			break;
	}

	console.log("He obtenido un", calificacion);
_______________________________________________________

	[4.4]. Optional chaining:
_______________________________________________________

El "Optional chaining" (encadenamiento opcional), es un operador que permite acceder a propiedades o métodos, aunque su elemento padre no exista, ya que realiza una comprobación previa.

Ejemplo 1:

	const alertaPrevia = document.querySelector('.alert');
	
	if(alertaPrevia){
		alertaPrevia.remove();
	}

Podemos resumirlo usando el "Optional chaining" de la siguiente manera:

	const alertaPrevia = document.querySelector('.alert');
	// alertaPrevia.remove(); // sin el "Optional chaining", y si el elemento no existe, genera error, ya que intenta acceder al método ".remove()" de "null".
	
	alertaPrevia?.remove(); // hace la comprovación igual que el "if", si no existe no marca error

Ejemplo 2: tenemos un objeto y accedemos a una de sus propiedades

	const pokemon1 = {
		name: "Pikachu",
		role: "Pokémon ratón",
		attrs: {
			life: 100,
			power: 25
		},
		movements: {
			mov1: "Agilidad",
			mov2: "Chispazo",
			mov3: "Impactrueno",
			mov4: "Bola Voltio"
		}
	}

	console.log(pokemon1.movements.mov4); // imprime "Bola Voltio"

Ahora tenemos otro objeto, pero si no hacemos una comprobación de si la propiedad existe, tendriamos un error:

	const pokemon2 = {
		name: "Magikarp",
		role: "Pokémon pez",
		attrs: {
			life: 100,
			power: 5
		},
		movements: {
			mov1: "Azote",
			mov2: "Salpicadura",
			mov3: "Placaje"
		}
	}

	//console.log(pokemon2.movements.mov4); // undefined
	console.log(pokemon2.movements?.mov4); // tambien undefined, pero no generaria error en caso de querer accceder a la propiedad que no existe

_______________________________________________________

	[5]. Arrays:
_______________________________________________________

Un array es una variable especial, que puede contener más de un valor a la vez.

	//Delcaramos el array "nombres"
	var nombres = ["Sara", "Laura", "Pedro"];

	//Tambien se puede declarar dividiendolo en multiples lineas
	var nombres = [
		"Sara",
		"Laura",
		"Pedro"
	];

	//Otra forma de declararlo vacio
	var nombres = [];

	//otra forma de declararlo
	var nombres = new Array();

La palabra clave "new" solo complica el código. También puede producir algunos resultados inesperados:

	var points = new Array(40, 100);  // Crea un array con dos elementos. (40 y 100)

Si se remueve uno de los elementos:

	var points = new Array(40);  // Crea un array con 40 elementos indefinidos. !!!!!
_______________________________________________________

	[5.1]. Acceso a los Elementos del Array:
_______________________________________________________
Accede a un elemento del array haciendo referencia al número de índice.

Los índices del array comienzan con 0.

	var nombre = nombres[0];

Para cambiar un elemento del array:

	nombres[2] = "Maria";

Se puede acceder al array completo haciendo referencia al nombre del array:

	document.getElementById("demo").innerHTML = nombres; //imprime "Sara,Laura,Pedro".

Nota: para más info de los arrays(matrices):

	https://www.w3schools.com/js/js_arrays.asp
_______________________________________________________

	[5.2]. Recorrido Arrays:
_______________________________________________________

	var nombres = ["Sara", "Laura", "Pedro"];

	for(var i=0; i<nombres.length; i++){
		document.write(nombres[i]+'<br/>');
	}

Nota: En JavaScript, se pueden incluir etiquetas Html o estilos CSS.
_______________________________________________________

	[5.2.1]. Recorrido con "forEach":
_______________________________________________________

El recorrido con el metodo ".forEach()" llama una función("callback") para cada elemento del array:

	nombres.forEach(miFuncion);

	function miFuncion(valor, indice, array) {
		document.write(valor +'<br/>');
	}

En este caso llamamos la función "callback" que escribimos aparte. Está función toma 3 argumentos, el valor del item, el indice del item, y el propio array.

Cuando se usa un solo argumento(ejemplo: "valor"), podemos omitir los otros.

En el siguiente ejemplo declaramos la función dentro del mismo "forEach":

	nombres.forEach(function(nombre){
		document.write(nombre +'<br/>');
	});

Nota: La funcion dentro del "forEach" es una función callback. Tambien es una función anonima (sin nombre).

- Recorrido con función de flecha:

	nombres.forEach((nombre)=> {
		document.write(nombre +'<br/>');
	});

_______________________________________________________

	[5.2.2]. Recorrido con ".map":
_______________________________________________________

La función ".map", es casi igual al recorrido de un ciclo "forEach", la diferencia es que ".map" devuelve un nuevo array.

	const carrito = [
		{ nombre: 'Monitor 20 pulgadas', precio: 500 },
		{ nombre: 'Tablet', precio: 200 },
		{ nombre: 'Celular', precio: 700 }
	]

	const nuevoArreglo = carrito.map( function (producto){
		return `${producto.nombre} - Precio: ${producto.precio}`;
	});

	console.log(nuevoArreglo);

_______________________________________________________

	[5.2.3]. Recorrido con ciclo "For In":
_______________________________________________________

- Recorrido ciclo "For In":

	for(indice in array){…}

Ejemplo:

	var dias=["Lunes","Martes","Miércoles","Jueves","Viernes","Sábado", "Domingo"];

	for (i in dias){
		alert(dias[i]);
	}
_______________________________________________________

	[6]. Funciones:
_______________________________________________________

Una función de JavaScript es un bloque de código diseñado para realizar una tarea en particular.

Una función de JavaScript se ejecuta cuando "algo" lo invoca (lo llama).

	function name(parameter1, parameter2, parameter3) {
  		//code to be executed
	}

Los parámetros de la función se enumeran entre paréntesis () en la definición de la función.

Los argumentos de función son los valores recibidos por la función cuando se invoca.

Dentro de la función, los argumentos (los parámetros) se comportan como variables locales.

	function multiplica(p1, p2) {
		return p1 * p2;  //Retorna el producto de p1 y p2
	}

	var x = multiplica(4, 3);   // Lllamado a la función, el valor que retorne se guarda en "x"

Otro ejemplo de funciones:

	function MostrarDatos(nombre, edad){
		//comillas invertidas --> Alt+ 96
		var plantilla = `
			<h2>Caja de Datos</h2>
			<p>Mi nombre es ${nombre} y mi edad es de ${edad} años.</p>  
		`;

		return plantilla;
	}

	function imprimir(){
		var datos = document.getElementById("datos");
		datos.innerHTML = MostrarDatos("Pedro", 25);
	}

	//ejecutar funcion
	imprimir();

Nota: Las comillas invertidas o backticks se introducen en ECMAScript 6.

_______________________________________________________

	[6.0.1]. Parametros por default:
_______________________________________________________

Podemos indicar valores por defecto para parametros que el usuario no envia como argumentos:

	function saludar(nombre = 'usuario', apellido = '') {
		console.log(`Hola ${nombre} ${apellido}`);
	}

	saludar('Ricardo', 'Landinez'); // imprime: "Hola Ricardo Landinez"
	saludar('Juan'); // imprime: "Hola Juan "
	saludar(); // imprime: "Hola usuario"

_______________________________________________________

	[6.1]. Funciones Anónimas:
_______________________________________________________

Las funciones anónimas o funciones lambda son un tipo de funciones que se declaran sin nombre de función y se alojan en el interior de una variable y haciendo referencia a ella cada vez que queramos utilizarla.

Crea una función mediante expresión (a través de una variable):

	// Función anónima "saludo"
	var saludo = function () {
		return "Hola";
	};

	saludo; // ƒ () { return "Hola"; }
	saludo(); // "Hola"

Otro ejemplo, pasando parametro:

	var factorial=function (num){
		var fac=1;
		for(num;num>0;num--){
			fac=fac*num;
		}
		alert(fac);
	}

	factorial(5);

La diferencia fundamental entre las funciones por declaración y las funciones por expresión es que estas últimas sólo están disponibles a partir de la inicialización de la variable. Si «ejecutamos la variable» antes de declararla, nos dará un error.
_______________________________________________________

	[6.2]. Funciones Callbacks:
_______________________________________________________

Un callback (llamada hacia atrás) es pasar una función B por parámetro a una función A, de modo que la función A puede ejecutar esa función B de forma genérica desde su código, y nosotros podemos definirlas desde fuera de dicha función:

	// fB = Función B
	var fB = function () {
		console.log("Función B ejecutada.");
	};

	// fA = Función A
	var fA = function (callback) {
		callback();
	};

	fA(fB);

Esto nos podría permitir crear varias funciones para utilizar a modo de callback y reutilizarlas posteriormente con diferentes propósitos. De hecho, los callbacks muchas veces son la primera estrategia que se suele utilizar en Javascript para trabajar la asincronía.

	// fB = Función B (callback)
	var fB = function () {
		console.log("Función B ejecutada.");
	};

	// fError = Función Error (callback)
	var fError = function () {
		console.error("Error");
	};

	// fA = Función A
	var fA = function (callback, callbackError) {
		var n = ~~(Math.random() * 5);
		if (n > 2) callback();
		else callbackError();
	};

	fA(fB, fError); // Si ejecutamos varias veces, algunas darán error y otras no

Podemos planear ejecutar la función fA() cambiando los callbacks según nos interese, sin necesidad de crear funciones con el mismo código repetido una y otra vez.

Nota: ahora usar mejor "Promesas".
_______________________________________________________

	[6.3]. Funciones Autoejecutables:
_______________________________________________________

Para crear una función y ejecutarla sobre la marcha, sólo tenemos que envolver entre paréntesis la función anónima en cuestión (no necesitamos que tenga nombre, puesto que no la vamos a guardar) y luego, ejecutarla:

	// Función autoejecutable
	(function () {
		console.log("Hola!!");
	})();

	// Función autoejecutable con parámetros
	(function (name) {
		console.log(`¡Hola, ${name}!`);
	})("Ricardo");

Si la función autoejecutable devuelve algún valor con return, a diferencia de las funciones por expresión, en este caso lo que se almacena en la variable es el valor que devuelve la función autoejecutada:

	var saludo = function () {
		return "Hola";
	};

	saludo; // ƒ () { return "Hola"; }
	saludo(); // "Hola"
	typeof saludo; // "function"

	var f = (function (name) {
		return `¡Hola, ${name}!`;
	})("Ricardo");

	f; // "¡Hola, Ricardo!"
	typeof f; // "string"
_______________________________________________________

	[6.4]. Funciones Clausuras:
_______________________________________________________

Una clausura o cierre se define como una función que «encierra» variables en su propio ámbito (y que continúan existiendo aún habiendo terminado la función).

	// Clausura: Función incr()
	var incr = (function () {
		var num = 0;
		return function () {
			num++;
			return num;
		};
	})();

	typeof incr; // "function"
	incr(); // 1
	incr(); // 2
	incr(); // 3

Tenemos una función anónima que es también una función autoejecutable. Aunque parece una función por expresión, no lo es, ya que la variable "incr" está guardando lo que devuelve la función anónima autoejecutable, que a su vez, es otra función diferente.

La «magia» de las clausuras es que en el interior de la función autoejecutable estamos creando una variable "num" que se guardará en el ámbito de dicha función, por lo tanto existirá con el valor declarado: 0.

En la variable "incr" tenemos una función por expresión que además conoce el valor de una variable "num", que sólo existe dentro de "incr". Si nos fijamos en la función que devolvemos, lo que hace es incrementar el valor de "num" y devolverlo. Como la variable "incr" es una clausura y mantiene la variable en su propio ámbito, veremos que a medida que ejecutamos "incr()", los valores de "num" (que estamos devolviendo) conservan su valor y se van incrementando.
_______________________________________________________

	[6.5]. Funciones flecha:
_______________________________________________________

Las Arrow functions, funciones flecha o «fat arrow» son una forma corta de escribir funciones que aparece en Javascript a partir de ECMAScript 6. Básicamente, se trata de reemplazar eliminar la palabra function y añadir => antes de abrir las llaves:

	var func = function () {
		return "Función tradicional.";
	};

	var func = () => {
		return "Función flecha.";
	};

Las ventajas de las funciones flecha son:

	- Si el cuerpo de la función sólo tiene una línea, podemos omitir las llaves ({}).
	- Además, en ese caso, automáticamente se hace un "return" de esa única línea, por lo que podemos omitir también el "return".
	- En el caso de que la función no tenga parámetros, se indica como en el ejemplo anterior: () =>.
	- En el caso de que la función tenga un solo parámetro, se puede indicar simplemente el nombre del mismo: e =>.
	- En el caso de que la función tenga 2 ó más parámetros, se indican entre paréntesis: (a, b) =>.
	- Si queremos devolver un objeto, que coincide con la sintaxis de las llaves, se puede englobar con paréntesis: ({name: 'Ricardo'}).

	var func = () => "Función flecha."; // 0 parámetros: Devuelve "Función flecha"

	var func = (e) => e + 1; // 1 parámetro: Devuelve el valor de e + 1

	var func = (a, b) => a + b; // 2 parámetros: Devuelve el valor de a + b
_______________________________________________________

	[6.6]. Funciones para Strings:
_______________________________________________________

".length" --> calcula la longitud de una cadena de texto.

	var mensaje="Hola Mundo";
	var num_letras=mensaje.length; //num_letras=10

".concat()" --> concatena igual que el "+":

	mensaje1="Hola";
	mensaje2=mensaje1.concat(" mundo"); //mensaje2="Hola mundo"

".toUpperCase()" --> pasa todo a mayúsculas.

	mensaje2=mensaje1.toUpperCase(); //mensaje2="HOLA"

".toLowerCase()" --> pasa a minúsculas.

".charAt(posicion)" --> obtiene el carácter que se encuentra en la posición indicada.

	var letra = mensaje1.charAt(0); // letra = "H"
	letra = mensaje1.charAt(2); // letra = "l"

".indexOf(caracter)" --> indica la posición del carácter dado. Devuelve la primera posición empezando a contar desde la izquierda. 

Si la cadena no tiene el carácter devuelve un -1
	
	var mensaje1 = "Hola";
	var posicion = mensaje1.indexOf('a'); // posicion = 3
	posicion = mensaje1.indexOf('b'); // posicion = -1

".lastIndexOf(caracter)" --> análoga a la función "indexOf()", devuelve la última posición del carácter.

".substring(inicio,final)" --> extrae un pedazo de la cadena. El parámetro "final" es opcional.

	var mensaje = "Hola Mundo";
	var porcion = mensaje.substring(2); // porcion = "la Mundo"
	porcion = mensaje.substring(1,8); // porcion = "ola Mun"
	porcion = mensaje.substring(-2); // porcion = "Hola Mundo"

".split(separador)" --> convierte una cadena de texto en un array de cadenas de texto.

	var mensaje = "Hola pollo, perro conejo ";
	var palabras = mensaje.split(" ");
	// palabras = ["Hola", "pollo,", "perro", "conejo"];
	
	var palabra = "Hola";
	var letras = palabra.split(""); // letras = ["H", "o", "l", "a"]

Nota: para ver más funciones para texto ir a:

	https://www.w3schools.com/js/js_string_methods.asp
_______________________________________________________

	[6.7]. Funciones para Arrays:
_______________________________________________________

".length" --> indica la cantidad de elementos.

".concat()" --> concatena elementos de varios arrays.
	
	var array1 = [1, 2, 3];
	var array2 = array1.concat(4, 5, 6); // array2 = [1, 2, 3, 4, 5, 6]

".join(separador)" --> función contraria a .split(). Une los elementos.

	var array = ["hola", "mundo"];
	var mensaje = array.join(""); // mensaje = "holamundo"
	mensaje = array.join(" "); // mensaje = "hola mundo"

".pop()" --> elimina y devuelve el último elemento.

	var array = [1, 2, 3];
	var ultimo = array.pop();
	// array = [1, 2] ultimo=3

".push()" --> añade al final.

	array.push(4);
	// array = [1, 2, 4]

".shift()" --> elimina y devuelve el primer elemento.
	var primero = array.shift();
	// array = [2, 4] primero=1

".unshift()" --> añade al principio.
	
	array.unshift(0);
	// array = [0, 2, 4]

".reverse()" --> Invierte el orden de elementos del array.

	var array = [1, 2, 3];
	array.reverse();
	// array = [3, 2, 1]

".splice()" --> sirve para ajustar(empalmar o unir) un array.

Por ejemplo para añadir nuevos elementos al medio del array:

	var fruits = ["Banana", "Orange", "Apple", "Mango"];

	fruits.splice(2, 0, "Lemon", "Kiwi");

	//el array "fruits" queda así: ["Banana","Orange","Lemon","Kiwi","Apple","Mango"].

El primer parametro (2) define la posición donde  donde se deben agregar nuevos elementos (empalmados).

el segundo parametro (0) define cuántos elementos deben eliminarse.

El resto de los parámetros ("Lemon", "Kiwi") definen los nuevos elementos que se agregarán.

El método splice () devuelve un array con los elementos eliminados:

	var fruits = ["Banana", "Orange", "Apple", "Mango"];
	var removed = fruits.splice(2, 2, "Lemon", "Kiwi");
	//la variable "removed" queda con ["Apple", "Mango"]

Tambien podemos remover un elemento del array sin dejar agujeros en él:

	var fruits = ["Banana", "Orange", "Apple", "Mango"];
	fruits.splice(0, 1);
	// remueve el primer elemento de "fruits"

Nota: para más info de las funciones para arrays:

	https://www.w3schools.com/js/js_array_methods.asp
_______________________________________________________

Esta función es de ECMAScript 5, y no la soportan navegadores antiguos:

	Array.isArray(nombreArray) --> nos indica si una variable es un array.

		var fruits = ["Banana", "Orange", "Apple", "Mango"];
		document.getElementById("demo").innerHTML = Array.isArray(fruits);
		//imprime "true"
_______________________________________________________

	[6.7.1]. Ordenando Arrays:
_______________________________________________________

El método "sort()" ordena un array alfabéticamente:

	var fruits = ["Banana", "Orange", "Apple", "Mango"];
	fruits.sort();
	// el array "fruits" queda así: ["Apple","Banana","Mango","Orange"]

Por defecto, la función "sort()" ordena los valores como cadenas(strings).

Sin embargo, si los números se ordenan como cadenas, "25" es mayor que "100", porque "2" es mayor que "1".

Debido a esto, el método "sort()" producirá resultados incorrectos al ordenar números.

Puede solucionar esto proporcionando una función de comparación:

	var points = [40, 100, 1, 5, 25, 10];
	points.sort(function(a, b){return a - b});
	//el array points queda [1,5,10,25,40,100]

Nota: para ver más sobre el metodo "sort()", y ordenar arrays con objetos ir a:

	https://www.w3schools.com/js/js_array_sort.asp
_______________________________________________________

	[6.7.2]. Filtrando Arrays:
_______________________________________________________

El método ".filter()" crea un nuevo array con elementos del array que pasan una prueba.

Este ejemplo crea un nuevo array a partir de elementos con un valor mayor que 18:

	var numbers = [45, 4, 9, 16, 25];
	var over18 = numbers.filter(myFunction);

	function myFunction(value, index, array) {
		return value > 18;
	}

	// "over18" queda así: [45,25]

Nota: en este ejemplo la función "callback" no utiliza los parámetros de "index" y "array", por lo que pueden omitirse.

	function myFunction(value) {
		return value > 18;
	}
_______________________________________________________

	[6.7.3]. Buscando en Arrays:
_______________________________________________________

- El método "includes()" comprueba si el elemento se encuentra en el array, devuelve "true" o "false":

	const meses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo'. 'Junio'. 'Julio'];
	console.log( meses.includes('Diciembre') ); //imprime: "false"

- Para comprobar si un elemento se encuentra en un array de objetos, en vez de "includes()" usamos ".some":

	const carrito = [
		{ nombre: 'Monitor 20 pulgadas', precio: 500 },
		{ nombre: 'Tablet', precio: 200 },
		{ nombre: 'Celular', precio: 700 }
	]

	const existe = carrito.some( producto => producto.nombre === 'Celular'); // devuelve: "true"

- El método "indexOf()" busca en un array un valor de un elemento y devuelve su posición.

	array.indexOf(item, start);

El argumento "item" es requerido, el item a buscar.
El argumento "start" es opcional, dónde comenzar la búsqueda, los valores negativos comenzarán en la posición dada contando desde el final y buscarán hasta el final.

	var fruits = ["Apple", "Orange", "Apple", "Mango"];
	var a = fruits.indexOf("Apple");
	document.getElementById("demo").innerHTML = "Apple is found in position " + a;
	//imprime: "Apple is found in position 0"

Nota: devuelve un "-1" si no encuentra nada. Si el elemento está presente más de una vez, devuelve la posición de la primera aparición.

El metodo ".lastIndexOf()" es igual a "indexOf()", pero devuelve la posición de la ultima ocurrencia.

- El método ".find()" devuelve el valor del primer elemento del array que pasa una función de prueba.

Este ejemplo encuentra (devuelve el valor de) el primer elemento que es mayor que 18:

	var numbers = [4, 9, 16, 25, 29];
	var first = numbers.find(myFunction);

	function myFunction(value, index, array) {
		return value > 18;
	}

	//"first" = 25

- El método ".findIndex()" devuelve el índice del primer elemento de matriz que pasa una función de prueba.

Este ejemplo encuentra el índice del primer elemento que es mayor que 18:

	var numbers = [4, 9, 16, 25, 29];
	var first = numbers.findIndex(myFunction);

	function myFunction(value, index, array) {
		return value > 18;
	}
	//first = 3

Otro ejemplo, encontramos el indice del mes de abril:

	const meses = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo'. 'Junio'. 'Julio'];
	
	const indice = meses.findIndex( mes => mes === 'Abril' );
	console.log(indice); // imprime: "3"

Devuelve "-1" en caso de que no encuentre el elemento.

Nota: para ver más metodos de iteración de arrays ir a:

	https://www.w3schools.com/js/js_array_iteration.asp

_______________________________________________________

	[6.7.4]. Acumulador ".reduce":
_______________________________________________________

El método ".reduce(ƒ, initial)", ejecuta ƒ con cada elemento (de izq a der), acumulando el resultado. Es un metodo reductor o acumulador, nos sirve por ejemplo para hacer una sumatoria de multiples valores, entregando un unico resultado.

Ejemplo:

	const carrito = [
		{ nombre: 'Monitor 20 pulgadas', precio: 500 },
		{ nombre: 'Tablet', precio: 200 },
		{ nombre: 'Celular', precio: 700 },
		{ nombre: 'Audifonos', precio: 300 },
		{ nombre: 'Teclado', precio: 100 },
	]

	// con un forEach:
	let total = 0;
	carrito.forEach( producto => total += producto.precio );\
	console.log(total);

	// con reduce:
	let resultado = carrito.reduce( (total, producto) => total + producto.precio, 0 );
	console.log(resultado);

_______________________________________________________

	[6.8]. Funciones para Números:
_______________________________________________________

"NaN" --> (Not a Number), indica un valor numérico no definido (EJ: 0/0)

	var num1=0;
	var num2=0;
	alert(num1/num2); // se muestra el valor NaN

"isNaN()" --> permite proteger la aplicación de posibles valores numéricos no definidos.

	if(isNaN(num1/2)){
		alert("La división no está definida para los números indicados");
	}else{
		alert("La división es igual a "+num1/num2);
	}

"Infinity" --> hace referencia al valor numérico infinito.
	var num1=10;
	var num2=0;
	alert(num1/num2); // se muestra el valor Infinity.

"toFixed(digitos)" --> devuelve el # con los decimales indicados, y realiza los redondeos necesarios.

	var numero1 = 4564.34567;
	numero1.toFixed(2); // 4564.35
	numero1.toFixed(6); // 4564.345670
	numero1.toFixed(); // 4564

Nota: para más info de variables numericas y metodos para números:

	https://www.w3schools.com/js/js_numbers.asp

	https://www.w3schools.com/js/js_number_methods.asp

	https://www.w3schools.com/js/js_math_reference.asp
_______________________________________________________

	[7]. Objetos:
_______________________________________________________

Podemos definir objetos, como por ejemplo un automóvil.

Un automóvil tiene propiedades como el peso y el color, y métodos como iniciar y detener.

Todos los automóviles tienen las mismas propiedades, pero los valores de las propiedades difieren de un automóvil a otro.

Todos los automóviles tienen los mismos métodos, pero los métodos se realizan en diferentes momentos.

Los objetos tambien son variables, pero contienen más valores.

Los objetos de JavaScript se escriben con llaves {}.

Las propiedades de los objetos se escriben como pares "nombre:valor", separados por comas.

	const car = {
		type:"Fiat", 
		model:"500", 
		color:"white"
	};

Nota 1: Esta forma de crear objetos es un "object literal", y no es reutilizable, hay otra forma llamada "object constructor", creando una función con el nombre de la clase y usando la palabra "new":

	function Car (type, model, color){
		this.type = type; 
		this.model = model; 
		this.color = color;
	}

	const fiat = new Car("Fiat", "500", "white");

Nota 2: si tenemos una variable cuyo nombre es el mismo nombre de la clave del objeto, podemos solo especificar la variable, por ejemplo:

	let color = 'rojo';

	const car2 = {
		type:"Audi", 
		model:"A3", 
		color
	}

Es equivalente a:

	const car2 = {
		type:"Audi", 
		model:"A3", 
		color: color
	}

_______________________________________________________

	[7.1]. Acceso a las propiedades del objeto:
_______________________________________________________

Se puede acceder a las propiedades del objeto de dos formas:

	nombreObjeto.nombrePropiedad

O tambien con:

	nombreObjeto["nombrePropiedad"]

Ejemplo:

	document.getElementById("demo").innerHTML = 
	car.type + " " + car[color];

	//imprime "Fiat white"
_______________________________________________________

	[7.1.1]. Agregar o eliminar propiedades del objeto:
_______________________________________________________

Para agregar una nueva propiedad al objeto usamos:

	car.imagen = "imagen.jpg";

Para eliminar una propiedad del objeto:

	delete car.color;
_______________________________________________________

	[7.1.2]. Destructuring de objetos:
_______________________________________________________

Para acceder a una propiedad de un objeto y guardarla en ena variable, antes se hacia:

	const type = car.type;

Con destructuring de objetos lo hacemos así:

	const { type } = car;

Si necesitamos acceder a más de una propiedad del objeto y guardar estas en variables, lo hacemos en la misma línea:

	const { type, model } = car;
	console.log(type);
	console.log(model);

_______________________________________________________

	[7.1.2.1]. Destructuring de objetos anidados:
_______________________________________________________

Si tenemos el siguiente objeto:

	const car = {
		type:"Fiat", 
		model:"500", 
		color:"white",
		info: {
			medidas: {
				length: "2mts",
				weight: "800kgs"
			},
			fabricacion:{
				pais:"Italia"
			}
		}
	}

Para desestructurar los objetos anidados hacemos:

	const { type, info: { fabricacion } } = car;
	console.log(type);
	console.log(fabricacion);

Nota: accedemos solo a la variable "fabricacion", para crear una variable "info" (objeto con sub-objetos medidas y fabricacion):

	const { type, info, info: { fabricacion } } = car;

Si queremos acceder al valor de "pais":

	const { type, info: { fabricacion: { pais } } } = car;
	console.log(pais);

_______________________________________________________

	[7.2]. Copiar 2 Objetos | "Spread Operator":
_______________________________________________________

1) Si tenemos los siguientes objetos:

	const producto = {
		nombre: "Monitor 20 pulgadas",
		precio: "300",
		disponible: "true"
	}

	const medidas = {
		peso: '1kg',
		medida: '1m'
	}

Y queremos fusionarlos en un solo objeto, lo hacemos de la siguiente forma:

	const resultado = Object.assign(producto, medidas);

	console.log(resultado);

	/*
		Imprime:
			{
				nombre: 'Monitor 20 pulgadas', 
				precio: '300', 
				disponible: 'true', 
				peso: '1kg', 
				medida: '1m'
			}
	*/

Nota: Al usar el método .assign() para combinar 2 objetos se modifica el objeto original que va como primer argumento. Para evitarlo, mejor usar el "Spread Operator".

2) Otra forma de hacer lo mismo, es usando el "Spread Operator" o "Rest Operator":

	const resultado2 = { ...producto, ...medidas };

Nota: El "Spread Operator", crea una copia de "producto" y de "medidas", por lo que no altera los objetos originales, tambien lo podemos usar para añadir nuevos elementos en un array.

_______________________________________________________

	[7.3]. Métodos del objeto:
_______________________________________________________

Los métodos son acciones que se pueden realizar en objetos.

Los métodos se almacenan en propiedades como definiciones de funciones.

	var person = {
		firstName:"John",
		lastName:"Doe",
		age:50,
		eyeColor:"blue",
		fullName: function() {
			return this.firstName + " " + this.lastName;
		}
	};

En la definición de la función, "this" se refiere al "propietario" de la función.

En este ejemplo, "this" es el objeto persona que "posee" la función "fullName".

En otras palabras, "this.firstName" significa la propiedad firstName de este objeto.
_______________________________________________________

	[7.3.1]. Acceso a los metodos del objeto:
_______________________________________________________

Se puede acceder al metodo del objeto de la siguiente forma:

	nombreObjeto.nombreMetodo()

Ejemplo:

	document.getElementById("demo").innerHTML = person.fullName(); //imprime "John Doe"
_______________________________________________________

	[7.4]. Object .keys, .values y .entries:
_______________________________________________________

Con el siguiente objeto:

	const producto = {
		nombre: "Monitor 20 pulgadas",
		precio: "300",
		disponible: "true"
	}

1) Usando el metodo estatico "Object.keys", vamos a obtener un array con los nombres de las propiedades(keys|claves) del objeto:

	console.log( Object.keys(producto) );
	// imprime: ["nombre", "precio", "disponible"]

Nota: este metodo tambien lo podemos usar para saber si un objeto esta vacio.

2) Con el metodo "Object.values" obtenemos un array de sus valores:

	console.log(Object.values(producto));
	// imprime: ["Monitor 20 pulgadas", "300", "true"]

3) Con el metodo "Object.entries" obtenemos un array de arrays con cada par clave valor:

	console.log(Object.entries(producto));
	// imprime:  Array [Array ["nombre", "Monitor 20 pulgadas"], Array ["precio", "300"], Array ["disponible", "true"]]
_______________________________________________________

	[7.5]. JSON:
_______________________________________________________

Cuando trabajamos con mucha cantidad de información, se puede volver necesario aislar el código de programación de los datos. De esta forma, podemos guardar información en un fichero independiente, separado del archivo donde tenemos el código de nuestro programa. Así, si necesitamos actualizar o modificar datos, no tenemos que tocar el código de nuestro programa.

JSON son las siglas de JavaScript Object Notation, y no es más que un formato ligero de datos, con una estructura (notación) específica, que es totalmente compatible de forma nativa con Javascript.

	{
		"name": "Manz",
		"life": 99,
		"dead": false,
		"props": ["invisibility", "coding", "happymood"],
		"senses": {
			"vision": 50,
			"audition": 75,
			"taste": 40,
			"smell": 50,
			"touch": 80
		}
	}

Todos los textos deben estar con comillas dobles, y solo se pueden utilizar tipos de datos como "string", "number", "object", "array", "boolean" o null.

¿Cuál es la diferencia entre JSON y un objeto de JavaScript?

Aunque es similar la estructura, la principal diferencia es que un JSON es un string es decir, es un texto.

El formato JSON es más restrictivo que un objeto de JavaScript:

- Siempre comillas dobles "", simples '' NO.
- Valores numéricos en decimal.
- No admite valores undefined.
- No admite comentarios.

Nota: para poner varios objetos JSON en un archivo JSON, los ponemos dentro de un array ([]), es decir cada objeto seria un elemento del array.
_______________________________________________________

	[7.5.1]. Convertir JSON a Objeto:
_______________________________________________________

	var str = '{ "name": "Manz", "life": 99 }';

	var obj = JSON.parse(str);

	obj.name; // 'Manz'
	obj.life; // 99
_______________________________________________________

	[7.5.2]. Convertir Objeto a JSON:
_______________________________________________________

	var obj = {
		name: "Manz",
		life: 99,
		saludar: function () {
			return "Hola!";
		},
	};

	var str = JSON.stringify(obj);

	str; // '{"name":"Manz","life":99}'

Las funciones no están soportadas por JSON, por lo que si intentamos convertir un objeto que contiene métodos o funciones, "JSON.stringify()" devolverá un "string" omitiendo las propiedades que contengan funciones.
_______________________________________________________

	[7.6]. CLASES:
_______________________________________________________

Aunque Javascript no soporta clases de forma nativa, en ECMAScript 6 se introduce la posibilidad de usar clases como en otros lenguajes, aunque internamente Javascript traduce estas clases al sistema basado en prototipos que usa en realidad.

Una clase es un molde que nos permite crear varios objetos a partir de ese "molde".

	// Declaración de clase
	class Animal {
		// Métodos
		hablar() {
			return "Cuak";
		}
	}

	// Creación de una instancia u objeto
	var pato = new Animal();
	pato.hablar(); // 'Cuak'

	var donald = new Animal();
	donald.hablar(); // 'Cuak'

Nota: los nombres de las clases deben siempre empezar en mayúsculas.
_______________________________________________________

	[7.6.1]. Métodos Estáticos:
_______________________________________________________

Para usar un método de una clase, como por ejemplo" hablar()", debemos crear el objeto basado en la clase haciendo un "new" de la clase. Lo que se denomina crear un objeto o una instancia de la clase. 
En algunos casos, nos puede interesar crear métodos estáticos en una clase porque para utilizarlos no hace falta crear ese objeto, sino que se pueden ejecutar directamente sobre la clase genérica:

	class Animal {
		static despedirse() {
			return "Adiós";
		}

		hablar() {
			return "Cuak";
		}
	}

	Animal.despedirse(); // 'Adiós'

Los métodos estáticos se suelen utilizar para crear funciones de apoyo que realicen tareas concretas o genéricas, que queremos incluir en la clase porque están relacionadas con la clase en cuestión.
_______________________________________________________

	[7.6.2]. Constructores:
_______________________________________________________

Se le llama constructor a un tipo especial de método de una clase, que se ejecuta automáticamente a la hora de hacer un "new" de dicha clase. 

Una clase solo puede tener un constructor, y en el caso de que no se especifique un constructor a una clase, tendrá uno vacío de forma implícita.

	// Declaración de clase
	class Animal {
		// Método que se ejecuta al hacer un "new"
		constructor() {
			console.warn("Ha nacido un pato.");
		}
		// Métodos
		hablar() {
			return "Cuak";
		}
	}

	// Creación de una instancia u objeto
	var pato = new Animal(); // 'Ha nacido un pato'

Nota: En un constructor no se puede utilizar nunca un return, puesto que al hacer un new se devuelve siempre el propio objeto creado.
_______________________________________________________

	[7.6.3]. Propiedades:
_______________________________________________________

Una propiedad es una variable con información que guarda el objeto.

	class Animal {
		constructor(n = "pato") {
			this.nombre = n;
		}

		hablar() {
			return "Cuak";
		}
		quienSoy() {
			return "Hola, soy " + this.nombre + ". ~" + this.hablar();
		}
	}

	// Creación de objetos
	var pato = new Animal();
	pato.quienSoy(); // 'Hola, soy pato. ~Cuak'

	var donald = new Animal("Donald");
	donald.quienSoy(); // 'Hola, soy Donald. ~Cuak'

Las propiedades se definen en el interior del constructor, precedido de la palabra clave "this" (que hace referencia a «este» elemento, es decir, la clase).

Nota: la palabra clave "this", usada fuera de una clase devolverá el objeto Window(referencia al objeto global de la pestaña actual). 

Las propiedades internas de la clase pueden ser modificadas externamente, simplemente sobreescribiendo la propiedad:

	var pato = new Animal("Donald");
	pato.quienSoy(); // 'Hola, soy Donald'

	pato.nombre = "Paco";
	pato.quienSoy(); // 'Hola, soy Paco'
_______________________________________________________

	[7.6.3.1]. Ámbitos en una clase:
_______________________________________________________

Dentro de una clase tenemos dos tipos de ámbitos: ámbito de método y ámbito de clase.

- Ámbito dentro de un método. Si declaramos variables o funciones dentro de un método con var, let o const, estos elementos existirán sólo en el método en cuestión. Además, no serán accesibles desde fuera del método:

	class Clase {
		constructor() {
			var name = "Ricardo";
			console.log("Constructor: " + name);
		}

		metodo() {
			console.log("Método: " + name);
		}
	}

	var c = new Clase(); // 'Constructor: Ricardo'

	c.name; // undefined
	c.metodo(); // 'Método:

Nota: la variable "name" solo se muestra cuando se hace referencia a ella dentro del "constructor()" que es donde se creó y donde existe.

- Ámbito de clase. Podemos crear propiedades precedidas por "this.", lo que significa que estas propiedades tendrán alcance en toda la clase, tanto desde el constructor, como desde otros métodos del mismo:

	class Clase {
		constructor() {
			this.name = "Ricardo";
			console.log("Constructor: " + this.name);
		}

		metodo() {
			console.log("Método: " + this.name);
		}
	}

	var c = new Clase(); // 'Constructor: Ricardo'

	c.name; // 'Ricardo'
	c.metodo(); // 'Método: Ricardo'

En este caso, podemos comprobar que si se puede acceder a la propiedad desde cualquier lugar de la clase.

Nota 1: las propiedades también pueden ser modificadas desde fuera de la clase, simplemente asignándole otro valor.

Ejemplo:

	c.name = "Jorge";

_______________________________________________________

	[7.6.3.2]. Propiedades Privadas:
_______________________________________________________

En una clase podemos indicar propiedades y metodos privados:

	class Cliente {

		constructor(nombre, saldo) {
			this.nombre = nombre;
			this.saldo = saldo; 
			this._tipoSangre = "X";
		}

		mostrarInformacion() {
			console.log(`Cliente ${this.nombre}, tu saldo es de $${this.saldo}`);
		}

		_metodoPrivado() {
			console.log("Método Privado");
		}
	}

	const pedro = new Cliente('Pedro', 400);
	pedro.mostrarInformacion();

El guion bajo es una convención en JavaScript (y otros lenguajes) para indicar que:

- Atributos o métodos "privados": No deberían ser accedidos ni modificados directamente desde fuera de la clase.

En el ejemplo:

	"_tipoSangre" --> es solo para uso interno de la clase.

	"_metodoPrivado()" --> es un método auxiliar, no parte de la API pública de la clase.

En JavaScript moderno existe la sintaxis de campos privados reales usando "#", pero el guion bajo sigue siendo común por compatibilidad y legibilidad.

	class Cliente {

		#tipoSangre;

		constructor(nombre, saldo) {
			this.nombre = nombre;
			this.saldo = saldo; 
			this.tipoSangre = "X";
		}

		mostrarInformacion() {
			console.log(`Cliente ${this.nombre}, tu saldo es de $${this.saldo} y su tipo de sangre es ${this.#tipoSangre}`);
		}

		_metodoPrivado() {
			console.log("Método Privado");
		}
	}

	const sara = new Cliente('Sara', 300);
	sara.#tipoSangre; //esto genera error

_______________________________________________________

	[7.6.3.3]. Getters:
_______________________________________________________

Los "getters" son la forma de definir propiedades computadas de lectura en una clase.

Las propiedades computadas son un tipo de propiedades a las que queremos realizarle ligeros cambios antes de guardarla o antes de obtenerla.

	class Animal {
		constructor(n) {
			this._nombre = n;
		}

		get nombre() {
			return "Sr. " + this._nombre;
		}

		hablar() {
			return "Cuak";
		}
		quienSoy() {
			return "Hola, soy " + this.nombre;
		}
	}

	// Creación de objetos
	var donald = new Animal("Donald");

	donald.nombre; // 'Sr. Donald'
	donald.nombre = "Pancracio"; // 'Pancracio'
	donald.nombre; // 'Sr. Donald'

Nota: las propiedades con "get" no se pueden cambiar, son de sólo lectura.
_______________________________________________________

	[7.6.3.4]. Setters:
_______________________________________________________

El "setter", es muy similar al "getter", pero en lugar de leer la información, la modifica:

	class Animal {
		constructor(n) {
			this.nombre = n;
		}

		get nombre() {
			return "Sr. " + this._nombre;
		}

		set nombre(n) {
			this._nombre = n.trim();
		}

		hablar() {
			return "Cuak";
		}
		quienSoy() {
			return "Hola, soy " + this.nombre;
		}
	}

	// Creación de objetos
	var donald = new Animal("Donald");

	donald.nombre; // 'Sr. Donald'
	donald.nombre = "   Lucas  "; // '   Lucas  '
	donald.nombre; // 'Sr. Lucas'

Podemos realizar tareas sobre los parámetros del "setter" antes de guardarlos en la propiedad interna. En este ejemplo, realizamos un "trim()" para limpiar posibles espacios antes de guardar esa información.
_______________________________________________________

	[7.6.4]. Herencia:
_______________________________________________________

A partir de ECMAScript 6 podemos utilizar las clases y «extender clases»:

	// Clase padre
	class Forma {
		constructor() {
			console.log("Soy una forma geométrica.");
		}

		gritar() {
			console.log("YEP!!");
		}
	}

	// Clases hijas
	class Cuadrado extends Forma {
		constructor() {
			super();
			console.log("Soy un cuadrado.");
		}
	}

	class Circulo extends Forma {
		constructor() {
			super();
			console.log("Soy un círculo.");
		}
	}

	class Triangulo extends Forma {
		constructor() {
			super();
			console.log("Soy un triángulo.");
		}
	}

La clase padre "Forma" muestra un mensaje en su constructor y tiene un método gritar(). Cada clase hija extiende a su clase padre, por lo que la clase "Cuadrado" será una mezcla de la clase "Forma" más la clase "Cuadrado". El método especial "super()" llama al constructor de la clase padre, por lo que si creamos varios objetos, funcionarán en cascada, mostrando primero el texto del constructor del padre, y luego el texto del constructor del hijo:

	var c1 = new Cuadrado();
	// 'Soy una forma geométrica.'
	// 'Soy un cuadrado.'
	c1.gritar();
	// 'YEP!!'
	var t1 = new Triangulo();
	// 'Soy una forma geométrica.'
	// 'Soy un triángulo.'
	t1.gritar();
	// 'YEP!!'

Nota: es obligatorio llamar a "super()" en el constructor de la clase hija antes de realizar ninguna tarea.

La palabra clave "super()" hace referencia a la superclase, es decir, a clase padre.

"super()" también se puede utilizar en métodos para llamar de forma opcional u obligatoria a métodos del padre para que hagan tareas complementarias o parciales.

	class Padre {
		tarea() {
			console.log("Tarea del padre...");
		}
	}

	class Hijo extends Padre {
		tarea() {
			super.tarea();
			console.log("Tarea del hijo...");
		}
	}

En el caso de que la clase "Hijo" no tuviera método "tarea()" heredaría dicho método de su clase padre, ejecutándolo. En el caso del ejemplo anterior, tiene un método "tarea()" en la clase "Hijo" que sobreescribe el método "tarea()" del padre, realizando únicamente el código indicado en esa clase hija. Sin embargo, la diferencia radica en lo siguiente:

- Si se indica "super.tarea()" (donde "tarea" es el nombre del método de la clase padre), esto llamará y ejecutará el método de la clase "Padre", y al terminar, continua realizando el código del método de la clase hija. Es el caso del ejemplo anterior.

- Si no se indica "super.tarea()", el método "tarea()" de la clase hijo sobreescribe al de la clase "Padre", ocultándolo y ejecutando sólo el código de la clase hija.

_______________________________________________________

	[7.7]. Prototypes:
_______________________________________________________

Los prototypes en JavaScript resuelven varios problemas relacionados con la eficiencia y la estructura del código, especialmente cuando se trabaja con objetos y clases. 

Nota: mejor usar "Clases", que son más faciles de usar en vez de prototypes.

Algunos de los problemas que resuelven son:

- Eficiencia de Memoria: Sin prototypes, cada instancia de un objeto tendría su propia copia de cada método. Esto puede llevar a un uso ineficiente de la memoria, especialmente si hay muchas instancias de un mismo objeto. Con prototypes, los métodos son compartidos entre todas las instancias del objeto, reduciendo el consumo de memoria.

	// Sin prototypes
	function Persona(nombre) {
		this.nombre = nombre;
		this.saludar = function() {
			console.log(`Hola, soy ${this.nombre}`);
		}
	}
	
	const persona1 = new Persona('Ana');
	const persona2 = new Persona('Juan');
	
	// Con prototypes
	function Persona(nombre) {
		this.nombre = nombre;
	}
	
	Persona.prototype.saludar = function() {
		console.log(`Hola, soy ${this.nombre}`);
	}
	
	const persona1 = new Persona('Ana');
	const persona2 = new Persona('Juan');

En el primer caso, cada instancia (persona1 y persona2) tiene su propia copia del método saludar, mientras que en el segundo caso, todas las instancias comparten el mismo método a través del prototype.

- Herencia y Reutilización de Código: Los prototypes permiten una forma más simple y eficiente de heredar propiedades y métodos entre objetos. Esto facilita la reutilización de código y la creación de jerarquías de objetos.

	function Animal(nombre) {
		this.nombre = nombre;
	}
	
	Animal.prototype.hablar = function() {
		console.log(`${this.nombre} hace un ruido.`);
	}
	
	function Perro(nombre, raza) {
		Animal.call(this, nombre); // Hereda el constructor de Animal
		this.raza = raza;
	}
	
	Perro.prototype = Object.create(Animal.prototype); // Hereda métodos de Animal
	Perro.prototype.constructor = Perro;
	
	Perro.prototype.ladrar = function() {
		console.log(`${this.nombre} ladra.`);
	}
	
	const rex = new Perro('Rex', 'Labrador');
	rex.hablar(); // Rex hace un ruido.
	rex.ladrar(); // Rex ladra.

En este ejemplo, Perro hereda de Animal, lo que permite a los perros usar el método hablar de Animal y también definir su propio método ladrar.

- Organización y Mantenimiento del Código: El uso de prototypes ayuda a organizar mejor el código, especialmente en aplicaciones grandes, al separar la lógica compartida y la específica de las instancias.

	// Definición de la clase
	function Coche(marca, modelo) {
		this.marca = marca;
		this.modelo = modelo;
	}
	
	// Métodos compartidos a través del prototype
	Coche.prototype.arrancar = function() {
		console.log(`${this.marca} ${this.modelo} está arrancando.`);
	};
	
	Coche.prototype.detener = function() {
		console.log(`${this.marca} ${this.modelo} se ha detenido.`);
	};
	
	const coche1 = new Coche('Toyota', 'Corolla');
	const coche2 = new Coche('Honda', 'Civic');
	
	coche1.arrancar(); // Toyota Corolla está arrancando.
	coche2.arrancar(); // Honda Civic está arrancando.

Aquí, los métodos arrancar y detener están definidos una vez en el prototype y son compartidos por todas las instancias de Coche, lo que facilita la lectura y el mantenimiento del código.
_______________________________________________________

	[7.8]. Binding:
_______________________________________________________

"Binding" se refiere a una vinculación o conexión entre dos cosas. En informática y programación: Es una "ligadura" que asocia un nombre con un valor, dato o recurso.
_______________________________________________________

	[7.8.1]. Implicit Binding:
_______________________________________________________

El "Implicit Binding", lo usamos en un objeto con la palabra reservada "this", para indicar de donde tomar los datos que necesita.

Ejemplo:

	// Implicit binding le dira de forma clara a la palabra this donde encontrar sus valores
	const usuario = {
		nombre: 'Juan',
		edad: 20,
		informacion() {
			console.log(`Mi Nombre es ${this.nombre} y mi edad es ${this.edad}`);
		}, 
		mascota: {
			nombre: 'Hook',
			edad: 1, 
			informacion() {
				console.log(`Mi Nombre es ${this.nombre} y mi edad es ${this.edad}`);
			}
		}
	}

	usuario.informacion();
	usuario.mascota.informacion();

_______________________________________________________

	[7.8.2]. Explicit Binding:
_______________________________________________________

Podemos tambien indicarle a una función ya creada, de donde tomar datos externos para su funcionamiento con "Explicit Binding", esto lo hacemos con los metodos ".call", ".apply" o ".bind".

Ejemplo:

	// Explicit binding

	function persona(el1, el2) {
		console.log(`Mi Nombre es: ${this.name} & I  listen: ${el1} & ${el2} `);
	}
	const informacion = {
		name: 'Juan',
		job: 'Developer'
	}
	const musicaFavorita = ['Heavy Metal', 'Rock'];

	// (1)
	persona.call(informacion, musicaFavorita[0], musicaFavorita[1]);

	// (2)
	persona.apply(informacion, musicaFavorita);

	// (3)
	const nuevaFn = persona.bind(informacion, musicaFavorita[0], musicaFavorita[1]);
	nuevaFn();

(1) El método llamado ".call", existe en todas las funciones de Javascript, y se le puede pasar un objeto o arreglo dentro de la función. 

NOTA IMPORTANTE: en ".call" se tiene que pasar cada elemento del array de forma individial, con su posición.

(2) Con ".apply", es exactamente igual a ".call", existe en todas las funciones pero toma un array completo.

(3) Con ".bind" va a ser como ".call" en que se le pasa cada argumento de forma individual, pero crea una nueva función.

_______________________________________________________

	[7.8.3]. New Binding y Window Binding:
_______________________________________________________

El "new binding", se da cuando se crea un nuevo objeto con el "object constructor", se tiene acceso a la palabra "this" via un nuevo objeto con "new":

	function Auto(model, color) {
		this.model = model;
		this.color = color;
	}
	const auto = new Auto('Camaro', 'Negro');
	console.log(auto);

El "Window binding", es cuando al objeto global "window", le aasignamos una nueva propiedad, y esta queda en este objeto de forma global, porque primero intenta obtener la variable con el nombre de esa propiedad, y si no existe la busca en el objeto "window":

	window.color = 'negro';
	function hola() {
		console.log(color);
	}

	hola();

_______________________________________________________

	[8]. Elementos DOM:
_______________________________________________________

Document Object Model. Los navegadores, cuando abrimos una pág. web, automáticamente generan un árbol de nodos.

DOM, transforma todos los documentos HTML en arboles de nodos.

Si tenemos el siguiente archivo HTML:

	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>Página Sencilla</title>
		</head>
		<body>
			<h1>Ejercicio</h1>
			<p>Parrafo</p>
			<p>Otro <strong>parrafo</strong></p>
		</body>
	</html>

Se transforma en el siguiente árbol de nodos:

					-------------
					| Documento |
					|   HTML    |
					-------------
		__________________|___________________
		|									 |
	 ------------						------------
	 | Elemento |						| Elemento |
	 |  "head"  |						|  "body"  |
   __------------__  			________------------_______
   |			  |				|			|			  |
----------- -----------	 ------------  ------------  ------------
|Elemento | |Elemento |	 | Elemento |  | Elemento |  | Elemento | 
| "meta"  | | "title" |	 |   "h1"   |  |   "p"    |  |   "p"    |
----------- -----------	 ------------  ------------  ------------
				|			 |			 |			  |      |
		-----------  ------------- ----------- -------- ---------- 
		|  Texto  |  | Texto     | |  Texto  | | Texto| | Elem.  |       
		|"Página  |  |"Ejercicio"| |"Parrafo"| |"Otro"| |"strong"|
		|Sencilla"|  ------------- ----------- -------- ----------
		-----------                                          |
														-----------
														|Texto    |
														|"parrafo"|
														-----------

- Cada rectángulo es un nodo.
- El nodo raíz, siempre es documento.
- Cada etiqueta HTML, se transforma en un nodo de tipo "elemento".		
_______________________________________________________

	[8.1]. Acceso a los Nodos(Métodos Clasicos):
_______________________________________________________

Se hace a través de funciones del DOM; y solo cuando la pág. a cargado
completamente.

Los metodos para obtener los nodos son:

- "getElementById(id)" --> Busca el elemento por "id" (el "id" es único para c/elemento). Devuelve un solo elemento. Si no, devuelve null.

- "getElementsByClassName(class)" --> Busca elementos por su clase.

- "getElementsByName(name)" --> Busca elementos con atributo "name".

- "getElementsByTagName(tag)" --> Busca elementos por su propia etiqueta HTML.

"getElementsByClassName(class)", "getElementsByName(name)", "getElementsByTagName(tag)" devuelven siempre un array con todos los elementos encontrados que encajen con el criterio, y en el caso de no encontrar ninguno, devolverán un "array" vacío ([]).

	var elem = document.getElementById("page"); // Elemento con id="page"

	var elems = document.getElementsByClassName("info"); // Elementos con class="info"
	var elems = document.getElementsByName("nickname"); // Elementos con name="nickname"
	var elems = document.getElementsByTagName("div"); // Elementos <div>
_______________________________________________________

	[8.2]. Acceso a los Nodos(Métodos Modernos):
_______________________________________________________

Usando selectores CSS podemos buscar cualquier elemento HTML de forma facil. Los metodos de búsqueda son:

- "querySelector(sel)" --> Busca el primer elemento que coincide con el selector CSS "sel". Si no, null.

- "querySelectorAll(sel)" --> devuelve un array con todos los elementos que coinciden con el selector CSS. Si no, devuelve un "array" vacío ([]).

	var elem = document.querySelector("#page"); // Elemento con id="page"
	var elem = document.querySelector(".main .info"); // Elemento class="info" en class="main"

	var elems = document.querySelectorAll(".info"); // Todos con class="info"
	var elems = document.querySelectorAll('[name="nickname"]'); // Elementos name="nickname"
	var elems = document.querySelectorAll("div"); // Elementos <div>

Al hacer busqueda de elementos y guardarlos en una variable, podemos seguir usando los metodos de forma recursiva:

	var parrafos=document.querySelectorAll("p");
	var primerParrafo=parrafos[0];
	var enlaces=primerParrafo.querySelectorAll("a");
	// saca un array con todos los enlaces.
_______________________________________________________

	[8.3]. Contenido de los elementos:
_______________________________________________________

Al obtener un elemento, es posible acceder a su contenido. Tenemos varias propiedades:

	".nodeName" -->	Devuelve el nombre del nodo (etiqueta si es un elemento HTML). Sólo lectura.

	".textContent" --> Devuelve el contenido de texto del elemento. Se puede asignar para modificar.

	".innerHTML" --> Devuelve el contenido HTML del elemento. Se puede asignar para modificar.

	".outerHTML" --> Idem a "innerHTML" pero incluyendo el HTML del propio elemento HTML.

	".innerText" --> Versión no estándar de "textContent" de Internet Explorer con diferencias. Evitar.

	".outerText" --> Versión no estándar de "textContent/outerHTML" de Internet Explorer. Evitar.

Si usamos la propiedad "nodeName" en un elemento HTML, nos devuelve el nombre de la etiqueta en mayúsculas.

La propiedad "textContent" nos devuelve el contenido de texto de un elemento HTML. Es útil para obtener (o cambiar) sólo el texto dentro de un elemento, obviando etiquetas HTML.

La propiedad "innerHTML" nos permite hacer lo mismo, pero interpretando el código HTML y renderizando sus elementos.

	var div = document.querySelector(".info"); // Elemento HTML con class="info"

	div.textContent = "Hola a todos"; // Modifica o añade texto dentro del elemento
	div.textContent; // 'Hola a todos'

	div.innerHTML = "<strong>Importante</strong>"; // Interpreta el HTML
	div.innerHTML; // '<strong>Importante</strong>'
	div.textContent; // 'Importante'

Nota: La propiedad "innerHTML" revisa, comprueba y parsea el etiquetado escrito al utilizar la asignación. Si en el ejemplo anterior nos olvidamos de escribir el cierre </strong> de la etiqueta, "innerHTML" automáticamente lo cerrará. Esto puede provocar algunas incongruencias si el código es incorrecto o una disminución de rendimiento en textos muy grandes que hay que preprocesar.

La propiedad "outerHTML" es muy similar a "innerHTML". Mientras que "innerHTML" devuelve el código HTML del interior de un elemento HTML, "outerHTML" devuelve también el código HTML del propio elemento en cuestión. Esto puede ser muy útil para reemplazar un elemento HTML combinándolo con "innerHTML".

	var data = document.querySelector(".data");

	data.innerHTML = "<h1>Tema 1</h1>";
	data.textContent; // 'Tema 1'
	data.innerHTML; // '<h1>Tema 1</h1>'
	data.outerHTML; // '<div class="data"><h1>Tema 1</h1></div>'
_______________________________________________________

	[8.4]. Crear elementos:
_______________________________________________________

Para crear elementos disponemos de los siguientes metodos:

- "createElement(tag, options)" --> Crea y devuelve un elemento HTML tag. El elemento creado, está aislado de la página HTML, para modificar e insertar más tarde en una posición determinada.

	var div = document.createElement("div"); // <div></div>
	var span = document.createElement("span"); // <span></span>
	var img = document.createElement("img"); // <img>

- "createComment(text)" --> Crea y devuelve un nodo de comentarios HTML con el texto text.

	var c = document.createComment("Comentario"); // <!--Comentario-->

- "createTextNode(text)" --> Crea y devuelve un nodo HTML con el texto text.

	var c = document.createTextNode("Hola"); // 'hola'

- "cloneNode(deep)" --> Clona el nodo HTML y devuelve una copia.

	var div = document.createElement("div");
	div.textContent = "Elemento 1";

	var div2 = div; // NO se está haciendo una copia
	div2.textContent = "Elemento 2";

	div.textContent; // 'Elemento 2'

Cuando hacemos "var div2 = div;", no hacemos una copia, sino una referencia a la variable "div". Para solucionar esto hacemos:

	var div = document.createElement("div");
	div.textContent = "Elemento 1";

	var div2 = div.cloneNode(); // Ahora si estamos clonando
	div2.textContent = "Elemento 2";

	div.textContent; // 'Elemento 1'

El método "cloneNode(deep)" acepta un parámetro "deep" (booleano) opcional por defecto para indicar el tipo de clonación. En el caso de establecerlo a "true", clonará también sus hijos, lo que se conoce como una clonación profunda (Deep Clone). En caso contrario, no clonará sus hijos, lo que se conoce como una clonación superficial (Shallow clone).

- "isConnected" --> Indica si el nodo HTML está conectado con el documento HTML.

Nota: los metodos vistos hasta el momento, crean elementos, pero no los insertan en el documento HTML.
_______________________________________________________

	[8.5]. Atributos de un elemento:
_______________________________________________________
	
Cuando se accede a un nodo, tambien es posible cambiar y acceder a sus
atributos y propiedades (incluidas propiedades de CSS).

Ej.1: obtener la dirección URL de un enlace (etiqueta <a>).
	
	//en el HTML tenemos:
	//<a id="enlace" href="http://www.__.com">Enlace</a>

	var enlace=document.getElementById("enlace");
	alert(enlace.href); //muestra http://www.__.com

Ej.2: Le asignamos valores como propiedades de objetos al elemento creado:

	var div = document.createElement("div");
	div.id = "page";
	div.className = "data"; // Ojo, class es una palabra reservada de Javascript
	div.style = "color: red";

En algunos casos esto se puede complicar, ya que por ejemplo la palabra class (para crear clases) o la palabra for (para bucles) son palabras reservadas de Javascript y no se podrían utilizar para crear atributos. Por eso tenemos métodos para utilizar en un elemento HTML y referirnos a sus atributos:

- "hasAttribute(attr)" --> Indica si el elemento tiene el atributo "attr".

- "hasAttributes()" -->	Indica si el elemento tiene atributos.

- "getAttributeNames()" --> Devuelve un array con los atributos del elemento.

- "getAttribute(attr)" --> Devuelve el valor del atributo "attr" del elemento o null si no existe.

- "removeAttribute(attr)" --> Elimina el atributo "attr" del elemento.

- "setAttribute(attr, value)" --> Añade o cambia el atributo "attr" al valor value.

- "getAttributeNode(attr)" --> Idem a "getAttribute()" pero devuelve el atributo como nodo.

- "removeAttributeNode(attr)" --> Idem a "removeAttribute()" pero devuelve el atributo como nodo.

- "setAttributeNode(attr, value)" --> Idem a "setAttribute()" pero devuelve el atributo como nodo.

	// <div id="page" class="info data dark" data-number="5"></div>
	var div = document.querySelector("#page");

	div.hasAttribute("data-number"); // true
	div.hasAttributes(); // true (tiene 3)

	div.getAttributeNames(); // ['id', 'data-number', 'class']
	div.getAttribute("id"); // 'page'
	div.removeAttribute("id"); // Elimina el atributo id. No devuelve nada.
	div.setAttribute("id", "page"); // Vuelve a añadirlo.

Los tres últimos métodos, "getAttributeNode()", "removeAttributeNode()" y "setAttributeNode()" son versiones idénticas a las anteriores, sólo que devuelven el nodo afectado, útil si queremos guardarlo en una variable y seguir trabajando con él.
_______________________________________________________

	[8.5.1]. Atributo "Class" de un elemento:
_______________________________________________________	

Al margen de tener que utilizar "className" en lugar de "class", lo que puede dar lugar a confusiones y equivocaciones, trabajar con clases utilizando atributos puede ser poco apropiado, ya que recordemos que un elemento HTML puede tener varias clases. En el caso de sobreescribir con una asignación una clase, eliminaríamos las anteriores.

Para trabajar más cómodamente, existe un sistema muy interesante para trabajar con clases: el objeto propiedad "classList", que devuelve la lista de clases del elemento. Además, incorpora una serie de métodos especiales que nos harán muy sencillo trabajar con clases:
	
- "classList" --> Devuelve la lista de clases del elemento HTML.

- "classList.item(n)" --> Devuelve la clase número n del elemento HTML.

- "classList.add(c1, c2, ...)" --> Añade las clases c1, c2... al elemento HTML.

- "classList.remove(c1, c2, ...)" --> Elimina las clases c1, c2... del elemento HTML.

- "classList.contains(clase)" --> Indica si la clase existe en el elemento HTML.

- "classList.toggle(clase)" --> Si la clase no existe, la añade. Si no, la elimina. Devuelve "true" si añade la clase y "false" si la elimina.

- "classList.toggle(clase, expr)" --> Si "expr" es "true", añade clase. Si no, la elimina.

- "classList.replace(old, new)" --> Reemplaza la clase "old" por la clase "new". Devuelve "true" si realiza el cambio con éxito.

	// <div id="page" class="info data dark" data-number="5"></div>
	var div = document.querySelector("#page");

	div.classList; // ['info', 'data', 'dark']
	div.classList.add("uno", "dos"); // No devuelve nada. Añadimos 'uno' y 'dos'
	div.classList.remove("uno", "dos"); // No devuelve nada. Eliminamos 'uno' y 'dos'
	div.classList.item(1); // 'data'
	div.classList.contains("info"); // Devuelve `true` (existe la clase)
	div.classList.toggle("info"); // Devuelve `false` (elimina 'info')
	div.classList.toggle("info"); // Devuelve `true` (no existía, añade 'info')
	div.classList.replace("dark", "light"); // Devuelve `true` (se hizo el cambio)

Nota: la propiedad "classList" aunque parece un "array" no lo es, es un elemento que actúa como un "array", por lo que puede carecer de algunos métodos o propiedades concretos.
_______________________________________________________

	[8.6]. Insertar Elementos:
_______________________________________________________

Para añadir los elementos al documento HTML, se puede realizar mediante los siguientes métodos:

- "appendChild(node)" --> Añade como hijo, el nodo "node". Devuelve el nodo insertado.

	var div = document.createElement("div");
	div.textContent = "Esto es un div insertado con JS.";

	var app = document.querySelector("#app"); // <div id="app"></div>
	app.appendChild(div);

Este método inserta el elemento como un hijo y al final de todos los elementos hijos que existan.

- "insertAdjacentElement(pos, elem)" --> Inserta el elemento "elem" en la posición "pos". Si falla, null.

- "insertAdjacentHTML(pos, str)" --> Inserta el código HTML "str" en la posición "pos".

- "insertAdjacentText(pos, text)" --> Inserta el texto "text" en la posición "pos".

- "insertBefore(new, node)" --> Inserta el nodo "new" antes de "node" y como hijo del nodo actual.

El parámetro "new" es el nodo a insertar, mientras que "node" puede ser:

	-"null" insertando "new" después del último nodo hijo.
	-un nodo de referencia, insertando "new" antes de dicho "node" de referencia.

Los métodos de la familia "insertAdjacent" son bastante más versátiles. Tenemos tres versiones diferentes: "insertAdjacentElement()" donde insertamos un objeto, "insertAdjacentHTML()" donde insertamos el código HTML directamente (similar a como lo hacemos con "innerHTML") y por último "insertAdjacentText()" donde insertamos un texto específico. En las tres versiones, debemos indicar un  "pos" como primer parámetro para indicar en que posición vamos a insertar el contenido:

- "beforebegin": El elemento se inserta antes de la etiqueta HTML de apertura.
- "afterbegin": El elemento se inserta dentro de la etiqueta HTML, antes de su primer hijo.
- "beforeend": El elemento se inserta dentro de la etiqueta HTML, después de su último hijo. Es el equivalente a usar "appendChild()".
- "afterend": El elemento se inserta después de la etiqueta HTML de cierre.

	var div = document.createElement("div");
	div.textContent = "Ejemplo";

	var app = document.querySelector("#app"); // <div id="app">App</div>

	// Opción #1 Antes del elemento:
	app.insertAdjacentElement("beforebegin", div);
	// <div>Ejemplo</div> <div id="app">App</div>

	// Opción #2 Antes del primer hijo:
	app.insertAdjacentElement("afterbegin", div);
	// <div id="app"> <div>Ejemplo</div> App</div>

	// Opción #3 Después del último hijo:
	app.insertAdjacentElement("beforeend", div);
	// <div id="app">App <div>Ejemplo</div> </div>

	// Opción #4 Después del elemento:
	app.insertAdjacentElement("afterend", div);
	// <div id="app">App</div> <div>Ejemplo</div>

La diferencia entre las versiones de los métodos es la que podemos ver a continuación:

	// Inserta el elemento HTML div creado con "createElement"
	app.insertAdjacentElement("beforebegin", div);

	// Inserta el código HTML pasado por parámetro
	app.insertAdjacentHTML("beforebegin", '<div id="app"></div>');

	// Inserta un nodo con el texto pasado por parámetro
	app.insertAdjacentText("beforebegin", "Hola a todos");
_______________________________________________________

	[8.7]. Eliminar Elementos:
_______________________________________________________

Los métodos más para eliminar o reemplazar elementos son:

- "remove()" --> Elimina el propio nodo de su elemento padre. No devuelve nada.

	var div = document.querySelector(".deleteme");
	div.remove();

Nota: cuando se elimina un nodo, se eliminan todos sus hijos.

- "removeChild(node)" --> Elimina y devuelve el nodo hijo "node".

	// <p id="provisional">…</p>
	var parrafo=document.querySelector("#provisional");
	parrafo.parentNode.removeChild(parrafo);

El método ".removeChild", se invoca desde el elemento padre del nodo.
Para acceder al padre de este elemento o cualquier otro se usa:

	"nodoHijo.parentNode"

- "replaceChild(new, old)" --> Reemplaza el nodo hijo old por "new". Devuelve "old".
_______________________________________________________

	[8.8]. Elementos Relacionados:
_______________________________________________________

Existen unas propiedades para navegar por la jerarquía de elementos HTML relacionados.

El primer grupo de propiedades nos permiten acceder a elementos HTML:

- "children" --> Devuelve una lista ("array") de elementos HTML hijos.

- "parentElement" --> Devuelve el padre del elemento o "null" si no tiene.

- "firstElementChild" --> Devuelve el primer elemento hijo.

- "lastElementChild" --> Devuelve el último elemento hijo.

- "previousElementSibling" --> Devuelve el elemento hermano anterior o "null" si no tiene.

- "nextElementSibling" --> Devuelve el elemento hermano siguiente o "null" si no tiene.

Ejemplo de uso de las propiedades teniendo el siguiente documento HTML:

	<html>
		<body>
			<div id="app">
				<div class="header">
					<h1>Titular</h1>
				</div>
				<p>Párrafo de descripción</p>
				<a href="/">Enlace</a>
			</div>
		</body>
	</html>

Podemos «navegar» por la jerarquía de elementos, moviéndonos entre elementos padre, hijo o hermanos:

	document.body.children.length; // 1
	document.body.children; // [div#app]
	document.body.parentElement; // <html>

	var app = document.querySelector("#app");

	app.children; // [div.header, p, a]
	app.firstElementChild; // <div class="header">
	app.lastElementChild; // <a href="...">

	var a = app.querySelector("a");

	a.previousElementSibling; // <p>
	a.nextElementSibling; // null

El segundo grupo de propiedades son equivalentes pero trabajando a nivel de nodos HTML:

- "childNodes" --> Devuelve una lista de nodos hijos. Incluye nodos de texto y comentarios.

- "parentNode" --> Devuelve el nodo padre del nodo o "null" si no tiene.

- "firstChild" --> Devuelve el primer nodo hijo.

- "lastChild" --> Devuelve el último nodo hijo.

- "previousSibling" --> Devuelve el nodo hermano anterior o null si no tiene.

- "nextSibling" --> Devuelve el nodo hermano siguiente o null si no tiene.

A nivel de nodos HTML, los textos (¡y espacios en blanco entre elementos HTML!) influyen:

	document.body.childNodes.length; // 3
	document.body.childNodes; // [text, div#app, text]
	document.body.parentNode; // <html>

	var app = document.querySelector("#app");

	app.childNodes; // [text, div.header, text, p, text, a, text]
	app.firstChild.textContent; // '                             '
	app.lastChild.textContent; // '                             '

	var a = app.querySelector("a");

	a.previousSibling; // #text
	a.nextSibling; // #text
_______________________________________________________

	[8.9]. Resumen Crear y Añadir Elementos:
_______________________________________________________

Consta de 4 pasos:

(1) Crear un nodo de tipo "Element" para representar el elemento.

	.createElement(etiqueta);

	var parrafo=document.createElement("p");

(2) Crear un nodo del tipo "Text" que represente el contenido del elemento.

	.createTextNode(contenido);

	var contenido=document.createTextNode("Hola Mundo!");

(3) Añadir el nodo "Text", como hijo del nodo "Element".

	.nodoPadre.appendChild(nodoHijo);

	parrafo.appendChild(contenido);

(4) Añadir el nodo "Element" a la pág. en forma de hijo del nodo correspondiente al lugar donde se quiere insertar el elemento.

	document.body.appendChild(parrafo);
_______________________________________________________

	[8.10]. Librerías para manejar Elementos:
_______________________________________________________

En muchos casos, el rendimiento no es tan importante como para trabajar a tan bajo nivel, por lo que podemos utilizar algunas librerías de terceros que nos facilitan el trabajo, nos permiten programar más rápidamente y la perdida de rendimiento es aceptable en comparación con el trabajo que podría llevar.

	- SuperDOM: https://github.com/szaranger/superdom

	- Voyeur.js: http://adriancooney.ie/voyeur.js/

	- HtmlJs: https://nhanfu.github.io/htmljs/api/index.html

	- Re:DOM: https://redom.js.org/
_______________________________________________________

	[9]. Eventos:
_______________________________________________________

Un evento HTML, es creado cuando el navegador hace algo, o el usuario hace algo.

Hay muchos tipos de eventos, como: hacer clic en un botón, pasar el mouse encima, arrastrar y soltar, presionar una tecla, etc.

Un evento en JavaScript es un objeto.

El nombre de c/evento se construye mediante el prefijo "on", seguido del nombre en ingles de la acción asociada al evento.

Ej: "onclick"

Algunos de los eventos más importantes definidos para JavaScript son:

	"onblur" --> Deseleccionar el elemento.

	"onchange" --> Deseleccionar un elemento que se ha modificado.

	"onclick" --> Pinchar y soltar el ratón.

	"ondblclick" --> Pinchar dos veces seguidas con el ratón.

	"onfocus" --> Seleccionar un elemento.

	"onkeydown" --> Pulsar una tecla (sin soltar).

	"onkeypress" --> Pulsar una tecla.

	"onkeyup" --> Soltar una tecla pulsada.

	"onload" --> La página se ha cargado completamente.

	"onmousedown" --> Pulsar (sin soltar) un botón del ratón.

	"onmousemove" --> Mover el ratón.

	"onmouseout" --> El ratón "sale" del elemento (pasa por encima de otro elemento).

	"onmouseover" --> El ratón "entra" en el elemento (pasa por encima del elemento).

	"onmouseup" --> Soltar el botón que estaba pulsado en el ratón.

	"onreset" --> Inicializar el formulario (borrar todos sus datos).

	"onresize" --> Se ha modificado el tamaño de la ventana del navegador.

	"onselect" --> Seleccionar un texto.

	"onsubmit" --> Enviar el formulario.

	"onunload" --> Se abandona la página (por ejemplo al cerrar el navegador).

Nota: para ver una tabla con estos eventos y a que elementos estan definidos ir a:

	https://uniwebsidad.com/libros/javascript/capitulo-6/modelo-basico-de-eventos-2
_______________________________________________________

	[9.1]. Manejador de Eventos:
_______________________________________________________

Se refiere a las funciones o código JavaScript que se define para cada evento.

Los manejadores se pueden indicar de 3 formas:

(1) Manejadores como atributos de los elementos HTML:
	
	<div id="contenidos" style="width:150px; height:60px;border:thin solid silver" onmouseover="this.style.borderColor='black';" onmouseout="this.style.borderColor='silver';">
		Contenido del div…
	</div>

"this" hace referencia al elemento HTML que ha provocado el evento.

(2) Manejadores como funciones JavaScript externas:

	<div style="width:150px; height:60px; border:thin solid silver" onmouseover="resalta(this)"onmouseout="resalta(this)">
		Contenido del div…
	</div>

	<script>
	function resalta(elemento) {
		switch(elemento.style.borderColor) {
			case 'silver':
			case 'silver silver silver silver':
			case '#c0c0c0': 
				elemento.style.borderColor = 'black';
				break;
			//Firefox
			case 'black':
			// IE
			case 'black black black black':
			//Opera
			case '#000000':
				elemento.style.borderColor = 'silver';
			break;
		}
	}
	</script>

El inconveniente de usar funciones externas, es que toca pasar la variable "this" como parámetro a la función.

Se usan muchos "case", debido a la interpretación de "borderColor", por parte de los navegadores.

(3) Manejadores Semánticos: Es la mejor forma, ya que no ensucia el código HTML. Y dentro de las funciones externas asignadas sí se puede utilizar la variable "this" para referirse al elemento que provoca el evento.

Para usar este método la pág. se debe cargar completamente antes de que se puedan usar las funciones DOM.

Para asegurarse que el código JavaScript se ejecute después de cargar la pág. se usa:

	window.onload=function(){
		...
	}

Así el manejador semántico quedaría:

	//Función externa
	function muestraMensaje(){
		alert('Gracias por pinchar');
	}

	//verificar que se carga la pág.
	window.onload=function(){
		//Asignar la función externa al elemento
		document.getElementById("pinchable").onclick=muestraMensaje;
	}

	//Elemento HTML
	<input id="pinchable" type="button" value="Pinchame y veras!"/>
_______________________________________________________

	[9.1.1]. Metodo "addEventListener()":
_______________________________________________________

El metodo "addEventListener()", añade un manejador de eventos al elemento especificado:

	element.addEventListener(event, function, useCapture);

El primer parámetro es el tipo de evento (como "clic" o "mousedown" o cualquier otro evento DOM de HTML).

El segundo parámetro es la función que queremos llamar cuando ocurre el evento.

El tercer parámetro es un valor booleano que especifica si se debe utilizar la propagación o la captura de eventos. Este parámetro es opcional.

	function resalta(elEvento){
		…
	}
	
	window.addEventListener("load",inicio);
	
	function inicio(){
		document.getElementById("seccion").addEventListener("mouseover",resalta,false);
		
		document.getElementById("seccion").addEventListener("mouseout",resalta);
	}

Nota: No se utiliza el prefijo "on" para el evento. Utilice "click" en lugar de "onclick".

Para ver las ventajas del metodo "addEventListener()" ir a:

	https://www.w3schools.com/js/js_htmldom_eventlistener.asp

_______________________________________________________

	[9.1.1.1]. Evento "DOMContentLoaded()":
_______________________________________________________

El evento "DOMContentLoaded" se ejecuta una vez que es descargado todo el HTML, no espera a que otros elementos, como imágenes, submarcos y scripts asíncronos, terminen de cargarse.

	document.addEventListener("DOMContentLoaded", () => {
		console.log("Documento Listo");
	});

Si usamos:

	console.log(1);

	document.addEventListener("DOMContentLoaded", () => {
		console.log(2);
	});

	console.log(3);

en la consola veriamos 1, 3, 2.

Nota: Se debe usar un evento diferente, "load", solo para detectar una página completamente cargada. Es un error común usar "load" cuando "DOMContentLoaded" sería más apropiado.

_______________________________________________________

	[9.1.2]. Metodo "removeEventListener()":
_______________________________________________________

Elimina los controladores de eventos que se han añadido con el método "addEventListener()":

	window.addEventListener("load",function(){
		alert("La pág. se cargó");
	});

	var boton = document.getElementById("miBoton");

	boton.addEventListener("click",boton_click);

	function boton_click(){
		alert("Bienvenido");
		boton.removeEventListener("click",boton_click);
	}

	// El HTML es:
	/*
		<body>
			<button id="miBoton">Haz clic </button>
		</body>
	*/
_______________________________________________________

	[10]. localStorage:
_______________________________________________________

La API web "localStorage", nos permite guardar datos en el navegador del usuario, de forma que cuando cierre el navegador o recargue la página, esos datos persistan.

"localStorage" tiene limite de 5mb. es una buena solución para almacenar poca información (como un carrito de compras abandonado o un JSON Web Token).

	localStorage.setItem('clave', 'valor');

Ejemplo:

	localStorage.setItem('nombre', 'Ricardo');

Nota 1: Para ver los datos guardados en el navegador, vamos a :

	Inspector --> Aplicación --> Almacenamiento Local

Nota 2: en "localStorage", solo podemos almacenar "strings", para guardar objetos o arrays, toca convertirlos a "string".

Ejemplo objeto:

	const producto = {
		nombre: "Monitor 27 pulgadas",
		precio: 300
	}

	const productoString = JSON.stringify( producto );
	
	localStorage.setItem('producto', productoString);

Ejemplo array:

	const meses = ["Enero", "Febrero", "Marzo"];

	localStorage.setItem('meses', JSON.stringify( meses ) );

_______________________________________________________

	[10.1]. Obtener datos de "localStorage":
_______________________________________________________

Para obtener los datos almacenados, usamos ".getItem()" con la clave(key) previamente guardada.

	const nombre = localStorage.getItem('nombre'); // 'Ricardo'

Para los objetos y arrays, es necesario parsearlos, ya que estan guardados en "string":

	const producto = localStorage.getItem('producto');
	console.log(JSON.parse(producto) );

	const meses = localStorage.getItem('meses');
	const mesesArray = JSON.parse(meses);
	console.log(mesesArray);
_______________________________________________________

	[10.2]. Eliminar y actualizar datos de "localStorage":
_______________________________________________________

- Para eliminar datos usamos el metodo ".removeItem('clave')":

	localStorage.removeItem('nombre');

- Para actualizar, tenemos que obtener la clave, parsearla, actualizar el valor, convertirla nuevamente en "string" y luego almacenarla:

	const mesesArray = JSON.parse( localStorage.getItem('meses') );

	mesesArray.push('Abril');

	localStorage.setItem('meses', JSON.stringify(mesesArray) );

- Para eliminar todas las claves almacenadas en "localStorage" usamos el metodo ".clear()":

	localStorage.clear();
_______________________________________________________

	[11]. Fechas:
_______________________________________________________

Las fechas en JavaScript, las creamos en un objeto gracias a "Date()":

	// Obtiene la fecha del momento actual.
	const fechaActual = new Date();

	// Obtenemos la fecha 30 de Enero de 2018, a las 23h 30m 14seg
	// Convierte el texto con formato YYYY/MM/DD HH:MM:SS a una fecha.
	const date = new Date("2018/01/30 23:30:14");

	// Creamos una fecha pasando cada uno de sus componentes numéricos*
	// new Date(y, m, d, h, min, s, ms)
	const date = new Date(2018, 0, 30, 23, 30, 14, 0);

Nota: si se especifica la fecha con formato new Date(y, m, d, h, min, s, ms), el número de mes se indica de 0 a 11 (0 --> Enero, 11 --> Diciembre). 

"Date()" tambien tiene diferentes metodos:

- .getDay() --> Devuelve el día de la semana (0 --> Domingo, 6 --> Sábado).

- .getFullYear() --> Devuelve el año con 4 cifras.

- .getMonth() --> Devuelve la representación interna del mes (0 --> Enero, 11 --> Diciembre).

- .getDate() --> Devuelve el día del mes.

- .getHours() --> Devuelve la hora (Formato militar: 23 en lugar de 11).

- .getMinutes() --> Devuelve los minutos.

- .getSeconds() --> Devuelve los segundos.

- .getMilliseconds() --> Devuelve los milisegundos.

- .getTime() --> Devuelve el UNIX Timestamp: segundos transcurridos desde 1/1/1970.

- .getTimezoneOffset() --> Diferencia horaria (en min) de la hora local respecto a UTC.

Ejemplos:

	const date = new Date("2018/01/30 15:30:10.999");

	date.getDay();            // 2 (Martes)
	date.getDate();           // 30
	date.getMonth();          // 0 (Enero)
	date.getFullYear();       // 2018
	date.getHours();          // 15
	date.getMinutes();        // 30
	date.getSeconds();        // 10
	date.getMilliseconds();   // 999
	date.getTimezoneOffset(); // 0
	date.getTime();           // 1517326210999 (Tiempo Unix)

Nota: tambien se cuentan con metodos "setter", por ejemplo:

	date.setDate(15);           // Cambia a 15/01/2018 15:30:10.999 (Devuelve 1516030210999)
	date.setMonth(1);           // Cambia a 15/02/2018 15:30:10.999 (Devuelve 1518708610999)
	date.setFullYear(2020);     // Cambia a 15/02/2020 15:30:10.999 (Devuelve 1581780610999)
	date.setHours(21);          // Cambia a 15/02/2020 21:30:10.999 (Devuelve 1581802210999)
	date.setMinutes(00);        // Cambia a 15/02/2020 21:00:10.999 (Devuelve 1581800410999)
	date.setSeconds(3);         // Cambia a 15/02/2020 21:00:03.999 (Devuelve 1581800403999)
	date.setMilliseconds(79);   // Cambia a 15/02/2020 21:00:03.079 (Devuelve 1581800403079)
	date.setTime(872817240000); // Cambia a 29/08/1997 02:14:00.000 (Devuelve 872817240000)

Además de cambiar la fecha del objeto "Date", estos métodos devuelven un numero en tiempo Unix de la fecha modificada.

Nota: Existen librerias que nos permiten formatear y trabajar con fechas de una mejor forma a "Date":

	- Luxon: https://moment.github.io/luxon/#/
	- Day.js: https://day.js.org/

Para vero otras librerias:

	https://lenguajejs.com/javascript/fechas/date-fechas-nativas/#librer%C3%ADas-para-fechas

_______________________________________________________

	[12]. Sets, Maps y Symbols:
_______________________________________________________

Un "Set" permite crear una lista de valores sin duplicados.

	const carrito = new Set();

	// Agregrar elementos al set:
	carrito.add('Camisa');
	carrito.add('Pokemon');
	carrito.add('Cartas');
	carrito.add('Tennis');

	// Lo siguiente no funciona, porque ya existe en el set:
	carrito.add('Camisa');

	// verificar tamaño del set:
	console.log( carrito.size ); // imprime: 4

	// verificar que un valor este dentro del set:
	console.log( carrito.has('Camisa') ); // imprime: true

	console.log( carrito.has('Guitarra') ); // imprime: false

	// Eliminar valor del set:
	carrito.delete('Cartas');

	// Al intentar eliminar un valor que no esta dentro del set, retorna false:
	console.log( carrito.delete('Juguete') ); // imprime: false

	// Eliminar todos los valores del set:
	carrito.clear();

	// Iterar en el set:
	carrito.forEach( (producto, index ) => {
		console.log("Producto:", producto, " Indice: ", index);
	});

Nota: en los sets solo tenemos valores, por lo tanto el "index" en el ciclo "forEach", imprimen el mismo producto.

Los "Sets" nos pueden servir para eliminar valores duplicados de un array:

	const numeros = [10, 20, 30, 40, 50, 10, 20];

	const noDuplicados = new Set(numeros);

	console.log(noDuplicados); // imprime: [10, 20, 30, 40, 50]

_______________________________________________________

	[12.1]. WeakSets:
_______________________________________________________

Los "Sets" pueden almacenar cualquier valor (objetos, numeros, booleanos, etc). En los "WeakSets" (Set Debil) solo se almacenan objetos.

	const weakset = new WeakSet();

	const cliente = {
		nombre: 'Juan',
		saldo: 100
	};

	weakset.add(cliente);

	console.log(weakset.has(cliente) ); // imprime: true

	console.log(weakset.has(cliente2) ); // genera error ya que "cliente2" no esta definido

	console.log(weakset.size ); // undefined, no tiene método size

Nota: los "WeakSets" no son iterables (no método forEach).

_______________________________________________________

	[12.2]. Maps:
_______________________________________________________

Los "Maps" son listas ordenadas en llave y valor. Tanto su llave como su valor pueden ser cualquier tipo de dato.

Los "Maps" tienen mejor performance que un objeto, en cuestiones de agregar, quitar elementos y recorrerlos.

	const cliente = new Map();

	cliente.set('nombre', 'Karen');
	cliente.set('tipo', 'Premium');
	cliente.set('saldo', 3000);
	cliente.set(true, true);
	cliente.set([0], true);

	console.log(cliente);

	console.log(cliente.size ); // imprime: 5

	console.log(cliente.has('nombre') ); // imprime: true

	console.log(cliente.get('nombre') ); // imprime: Karen

	// Elimina la clave y el valor
	cliente.delete('saldo');

	// Borrar todas las claves valor:
	cliente.clear();

	// Iniciar un "Map" con valores:
	const paciente = new Map([ ['nombre', 'algo'], ['cuarto', 'No definido'] ]);

	// Asiganar al Map ya creado:
	paciente.set('dr', 'doctor asigando');

	// Sobre escribir un valor:
	paciente.set('nombre', 'Antonio');

	// Iterar en el Map:
	paciente.forEach( (datos, llave) => {
		console.log(llave, ':', datos)
	});
_______________________________________________________

	[12.3]. WeakMaps:
_______________________________________________________

Los "WeakMaps" al igual que los "WeakSets", no tienen método "size", ni son iterables y solo aceptan objetos.

	const producto = {
		idProducto: 10
	}

	const weakmap = new WeakMap();

	weakmap.set(producto, 'Computador');

	console.log( weakmap );

	/*
	Imprime:

		WeakMap {{…} => 'Computador'}
			[[Entries]]
				0 : {Object => "Computador"}
					key	: {idProducto: 10}
					value : "Computador"
			[[Prototype]] : WeakMap
	*/

	console.log( weakmap.has(producto) ); // imprime: true
	console.log( weakmap.get(producto) ); // imprime: Computador
	console.log( weakmap.delete(producto) ); // imprime: true

_______________________________________________________

	[12.4]. Symbols:
_______________________________________________________

Un "Symbol" permite crear identificadores únicos. Además, es inmutable, por lo que no podemos modificarlo intencional ni accidentalmente.

	const sym = Symbol();
	const sym2 = Symbol();

	sym === sym2 // false (son símbolos diferentes)

	const nombre = Symbol();
	const apellido = Symbol();

	const persona = {};

	// Agregar nombre y apellido como llaves del objeto
	persona[nombre] = 'Juan';
	persona[apellido] = 'De la Torre';
	persona.tipoCliente = 'Premium';
	persona.saldo = 500;

	console.log(persona);

	// Las propiedades que utilizan un symbol no son iterables
	for(let i in persona){
		console.log(i);
	}

	// Definir una descripción del Symbol:
	const nombreCliente = Symbol('Nombre del Cliente');
	const cliente = {};

	cliente[nombreCliente] = 'Pedro';

	console.log(cliente); // imprime: {Symbol(Nombre del Cliente): 'Pedro'}
	console.log(cliente[nombreCliente]); // imprime: Pedro
	console.log(nombreCliente); // imprime: Symbol(Nombre del Cliente)

Nota: para más información de los Symbols:

	https://lenguajejs.com/javascript/tipos/symbols/

_______________________________________________________

	[12.5]. Iteradores:
_______________________________________________________

Podemos crear nuestro propio iterador para recorrer elementos.

	function crearIterador(carrito) {
		let i = 0;

		return {
			siguiente: () => {
				const fin = ( i >= carrito.length);
				const valor = !fin ? carrito[i++] : undefined;

				return {
					fin,
					valor
				}
			}
		}
	}

	const carrito = ['Producto 1', 'Producto 2', 'Producto 3'];

	// utilizar el iterador
	const recorrerCarrito = crearIterador(carrito);

	console.log(recorrerCarrito.siguiente());
	console.log(recorrerCarrito.siguiente());
	console.log(recorrerCarrito.siguiente());
	console.log(recorrerCarrito.siguiente());
_______________________________________________________

	[12.6]. Generadores:
_______________________________________________________

Los generadores tambien nos permiten iterar sobre listados.

1) Para iterar elementos estaticos(los definimos dentro del generador):
	
	function *crearGenerador(){
		yield 1;
		yield 'Ricardo';
		yield 3+3;
		yield true;
	}

	const iterador = crearGenerador();

	console.log(iterador); // imprime: crearGenerador {<suspended>}
	console.log( iterador.next() ); // imprime: {value: 1, done: false}
	console.log( iterador.next().value ); // imprime: Ricardo
	console.log( iterador.next() ); // imprime: {value: 6, done: false}
	console.log( iterador.next().value ); // imprime: true
	console.log( iterador.next() ); // imprime: {value: undefined, done: true}
	console.log(iterador); // imprime: crearGenerador {<closed>}

Los generadores tienen las siguientes caracteristicas:

- Tienen un asterisco(*) antes de su nombre.
- Usa la palabra reservada 'yield' para iterar cada elemento.
- En su prototype podemos ver el método "next()", el cual itera y retorna un objeto por cada elemento del listado definido con "yield".
- Accedemos al valor de cada elemento con ".next().value".
- En cada iteración el generador esta suspendido, y con "next()" se despierta, itera y se vuelve a suspender.
- Al terminar de iterar todos los elementos, se cierra el generador.

2) Para iterar elementos dinámicos:

	function *generadorCarrito( carrito ){
		for(let i = 0; i < carrito.length; i++){
			yield carrito[i];
		}
	}

	const carrito = ['Producto 1', 'Producto 2', 'Producto 3'];

	const iterador = generadorCarrito(carrito);

	console.log( iterador.next() ); // imprime: {value: 'Producto 1', done: false}
	console.log( iterador.next() ); // imprime: {value: 'Producto 2', done: false}
	console.log( iterador.next() ); // imprime: {value: 'Producto 3', done: false}
	console.log( iterador.next() ); // imprime: {value: undefined, done: true}

_______________________________________________________

	[12.7]. Iteradores "entries", "values", "keys" y "default":
_______________________________________________________

Para los "arrays", los "Sets" y los "Maps", podemos iterarlos con diferentes metodos, que nos devolveran las parejas clave, valor o solo alguno de los dos:

	const ciudades = ['Londres', 'New York', 'Madrid', 'Paris'];
	const ordenes = new Set([123, 231, 131, 102]);
	const datos = new Map();

	datos.set('nombre', 'Sara');
	datos.set('prefesion', 'Modelo');

// Entries iterator

	for(let entry of ciudades.entries() ) {
		console.log(entry);
	}

	/*
		ARRAY
		Imprime pares clave valor:

		[0, 'Londres']
		[1, 'New York']
		[2, 'Madrid']
		[3, 'Paris']
	*/

	for(let entry of ordenes.entries() ) {
		console.log(entry);
	}

	/*
		SET
		Imprime pares clave valor, en este caso genera las claves o indices con los mismos valores:

		[123, 123]
		[231, 231]
		[131, 131]
		[102, 102]
	*/

	for(let entry of datos.entries() ) {
		console.log(entry);
	}

	/*
		MAP
		Imprime pares clave valor:

		['nombre', 'Sara']
		['prefesion', 'Modelo']
	*/

// Values iterator

	for(let value of ciudades.values() ) {
		console.log(value);
	}

	/*
		ARRAY
		Imprime solo valores:

		Londres
		New York
		Madrid
		Paris
	*/

	for(let value of ordenes.values() ) {
		console.log(value);
	}

	/*
		SET
		Imprime solo valores:

		123
		231
		131
		102
	*/

	for(let value of datos.values() ) {
		console.log(value);
	}

	/*
		MAP
		Imprime solo valores:

		Sara
		Modelo
	*/

// Keys iterator

	for(let keys of ciudades.keys() ) {
		console.log(keys);
	}

	/*
		ARRAY
		Imprime solo las claves o indices:

		0
		1
		2
		3
	*/

	for(let keys of ordenes.keys() ) {
		console.log(keys);
	}

	/*
		SET
		Imprime solo las claves o indices (en este caso los mismos valores):

		123
		231
		131
		102
	*/

	for(let keys of datos.keys() ) {
		console.log(keys);
	}

	/*
		MAP
		Imprime solo las claves o indices:

		nombre
		profesion
	*/

// Default iterator

	for(let ciudad of ciudades) {
		console.log(ciudad);
	}

	/*
		ARRAY
		Imprime solo valores (igual que .values):

		Londres
		New York
		Madrid
		Paris
	*/

	for(let orden of ordenes) {
		console.log(orden);
	}

	/*
		SET
		Imprime (igual que .values):

		123
		231
		131
		102
	*/

	for(let dato of datos) {
		console.log(dato);
	}

	/*
		MAP
		Imprime pares clave valor (igual que .entries):

		['nombre', 'Sara']
		['prefesion', 'Modelo']
	*/

_______________________________________________________

	[13]. Módulos ECMAScript (ESM):
_______________________________________________________

Permite la importación y exportación de código entre diferentes ficheros Javascript.

Para trabajar con módulos tenemos a nuestra disposición las siguientes palabras clave:

- "export" --> Exporta uno o varios elementos (variables, funciones, clases...) del fichero actual.

- "import" --> Importa uno o varios elementos (variables, funciones, clases...) desde otro fichero ".js".

Mediante la palabra clave "export" crearemos un objeto (módulo de exportación) que contendrá una o varias propiedades. En estas propiedades podremos guardar variables, funciones o clases. Si dicho módulo ya existe, podremos ir añadiendo más propiedades. 

Por otro lado, con la palabra clave "import" podremos leer dichos módulos de otros ficheros y utilizar sus propiedades en nuestro código.
_______________________________________________________

	[13.1]. Exportación de Módulos:
_______________________________________________________

Existen varias formas de exportar código mediante la palabra clave export :

	export { name }; --> Añade el elemento name al módulo de exportación.

	export { n1, n2, n3... }; --> Añade los elementos indicados ( n1 , n2 , n3 ...) al módulo de exportación.

	export * from './file.js'; --> Añade todos los elementos del módulo "file.js" al módulo de exportación.

	export declaration; --> Declara una variable, función o clase y la añade al módulo de exportación.

	export default declaration; --> Declara una función o clase y la añade al módulo de exportación.

Es posible renombrar los elementos sobre la marcha utilizando "as" seguido del nuevo nombre. Además, si se indica "default" como nuevo nombre, ese elemento será la exportación por defecto. Sólo puede haber una exportación por defecto por fichero.

	let number = 4;
	const saludar = () => "¡Hola!";
	const goodbye = () => "¡Adiós!";
	class Clase {}

	export {
		number
	}; // Se crea un módulo y se añade number

	export {
		saludar,
		goodbye as despedir
	}; // Se añade saludar y despedir al módulo

	export {
		Clase as
		default
	}; // Se añade Clase al módulo (default)

	export {
		saludar as otroNombre
	}; // Se añade otroNombre al módulo

También es posible exportar variables, funciones o clases simplemente incluyendo la palabra "export" a la izquierda de la línea de su declaración:

	export const f1 = () => 42; // Se crea un módulo y se añade f1

	export default function f2() {
		return "Manz";
	} // Se añade f2 al módulo (default)

Nota: en el caso de utilizar una exportación por defecto en una declaración, no es posible utilizar "var" , "let" o "const" . Tampoco es posible usar "export" dentro de funciones, bucles o contextos específicos.
_______________________________________________________

	[13.2]. Importación de Módulos:
_______________________________________________________

Existen varias formas de importar código utilizando "import", con la que podemos cargar un módulo de exportación de otro fichero Javascript, con todos los elementos exportados que contiene.

	import nombre from './file.js'; --> Importa sólo el elemento por defecto de "file.js" en "nombre".

	import { nombre } from './file.js'; --> Importa sólo el elemento "nombre" de "file.js".

	import { n1, n2.. } from './file.js'; --> Importa los elementos indicados desde "file.js".

	import * as obj from './file.js'; --> Importa todos los elementos de "file.js" en el objeto "obj".

	import './file.js'; -->	No importa elementos, pero ejecuta el código de "file.js".

Al igual que con la exportación, también se puede renombrar elementos utilizando "as" seguido del nuevo nombre.

En el primer caso, importamos el elemento por defecto desde el módulo "file.js" y lo guardamos en la variable "nombre". En el segundo y tercer caso, importamos los elementos indicados en el interior de los corchetes, desde el módulo "file.js".

En el cuarto caso, importamos todos los elementos del módulo externo "file.js" en un objeto de nombre "obj" (es obligatorio indicar el nombre) y en el quinto caso, no importamos elementos, pero leemos el código del módulo y lo ejecutamos.
_______________________________________________________

	[13.3]. Convenciones de módulos ES:
_______________________________________________________

Si queremos utilizar "import" y "export" desde el navegador directamente, deberemos añadir los archivos con módulos con la etiqueta <script> utilizando el atributo type="module" . Estas etiquetas de módulos se cargan en diferido, o lo que es lo mismo, como si fueran un <script defer> :

	<script type="module" src="file.js"></script>

Por norma general, a los archivos Javascript con módulos se les pone la extensión ".js", aunque también se pueden encontrar con otra extensión como ".es2015" o ".mjs".

Se aconseja utilizar las rutas UNIX en los export e import , ya que son las que tienen mejor soporte, tanto en navegadores como en NodeJS. También se pueden indicar rutas absolutas para cargar directamente desde el navegador:

	// Incorrecto
	import { elemento } from "module.mjs";
	import { elemento } from "folder/module.mjs";

	// Correcto
	import { elemento } from "./module.mjs"; // misma carpeta del .js
	import { elemento } from "/module.mjs"; // carpeta raíz
	import { elemento } from "../module.mjs"; // carpeta anterior al .js
	import { ceil } from "https://unpkg.com/lodash-es@4.17.11/lodash.js";

Se aconseja realizar las exportaciones al final de los ficheros Javascript. Aunque no es obligatorio, esto mejora la legibilidad de código, ya que siempre te esperas que los "export" aparezcan al final del código.

_______________________________________________________

	[13.4]. Ejemplos:
_______________________________________________________

1) Archivo "js/cliente.js":

	export const nombreCliente = 'Pedro';
	export const ahorro = 200;

	export function mostrarInformacion() {
		console.log(`Cliente: ${nombreCliente}, Ahorro: ${ahorro}`);
	}

	export function tieneSaldo(ahorro){
		if(ahorro > 0){
			console.log('Si tiene saldo');
		}else{
			console.log('El cliente no tiene saldo');
		}
	}

	export class Cliente {
		constructor(nombre, ahorro){
			this.nombre = nombre;
			this.ahorro = ahorro;
		}

		mostrarInformacion(){
			return `Cliente: ${this.nombre}, Ahorro: ${this.ahorro}`
		}
	}

	export default function nuevaFuncion() {
		console.log('Este es el export default');
	}

Archivo "js/app.js":

	import nuevaFuncion, { nombreCliente, ahorro, mostrarInformacion, tieneSaldo, Cliente } from "./cliente.js";

	console.log(nombreCliente);
	console.log(ahorro);

	mostrarInformacion();

	tieneSaldo(ahorro);

	const cliente = new Cliente('Alejandra', 120);

	console.log(cliente.mostrarInformacion());

	nuevaFuncion();

Archivo "index.html":

	<script src="js/app.js" type="module"></script>

Nota 1: al importar sin usar bundles(webpack, vite, etc.) es necesario indicar la extensión del archivo (.js).

Nota 2: Solo puede existir un "export default" por archivo, y al importarlo debe estar fuera de las llaves ({}).

Nota 3: Cuando en un archivo tenemos una variable global, definida con "let", con los modulos es tratada como una constante, por lo que debemos cambiar su definición a un objeto. Ejemplo:

	export let editando = false;
	export let algo;

Lo cambiamos por:

	export let editando = {
		value: false
	};

	export let algo = {
		value: null
	};

Con la variable "algo", la cual esta declarada, pero aún no se ha definido su valor (undefined), usamos la misma tecniva, pero en el objeto asignamos "null" al "value" del objeto.

Luego donde lo importemos podemos asignarle un valor haciendo referencia a "value":

	editando.value = true;
	algo.value = "Algun valor";
_______________________________________________________

	[14]. IndexedDB:
_______________________________________________________

"IndexedDB" es una API en JavaScript para almacenar grandes cantidades de datos estructurados (es una base de datos local).

A diferencia de "localStorage" puede almacenar strings, booleans, incluso archivos, cualquier tipod e dato soportado por JavaScript.

No tiene limites conocidos, aunque los archivos de más de 50mb va a preguntar por permisos. ("localStorage" tiene limite de 5mb).

"IndexedDB" es una base de datos completa, pero los datos siguen siendo visibles para cualquiera, por lo que no se recomienda almacenar passwords o tarjetas de crédito.

Para consultar la "IndexedDB" en los navegadores:

- Firefox: Abrir inspector, ir a "Almacenamiento", y buscar "Db indexada".
- Chrome:  Abrir inspector, ir a "Aplicación", en "Almacenamiento" buscar "IndexedDB".

_______________________________________________________

	[14.1]. Crear IndexedDB:
_______________________________________________________

Crearemos una base de datos para un CRM:

	let DB;

	document.addEventListener('DOMContentLoaded', () => {
		crmDB();
	});

	function crmDB(){
		//Crear base de datos version 1.0
		let crmDB = window.indexedDB.open('crm', 1);

		// Si hay un error
		crmDB.onerror = function () {
			console.log('Hubo un error a la hora de crear la BD');
		}

		// Si se creo bien
		crmDB.onsuccess = function () {
			console.log('Base de datos creada!!!');
			DB = crmDB.result;
		}

		// Configuración de la base de datos
		crmDB.onupgradeneeded = function () {
			console.log('Este método solo se ejecuta una vez...');
		}
	}

Con el método ".open" le indicamos el nombre y la versión de la base de datos.

Con el metodo ".onupgradeneeded" indicamos la configuración de la base de datos (las tablas, los ids, etc). este método solo se ejecuta una vez.

Nota: Al revisar el navegador, vemos la base de datos creada, en eset caso con el nombre 'crm', su versión "1", en almacenamiento de objetos tiene "0", porque aún no se han creado tablas. Y tambien podemos eliminarla o actualizarla.

_______________________________________________________

	[14.2]. Crear tablas en IndexedDB:
_______________________________________________________

Para crear las tablas y sus campos usamos:

	// Configuración de la base de datos
	crmDB.onupgradeneeded = function (e) {
		const db = e.target.result;

		// Crear un objectStore (tabla)
		const objectStore = db.createObjectStore('crm', {
			keyPath: 'crm',
			autoIncrement: true
		});

		// Definir las columnas
		objectStore.createIndex('nombre', 'nombre', { unique: false });
		objectStore.createIndex('email', 'email', { unique: true });
		objectStore.createIndex('telefono', 'telefono', { unique: false });

		console.log('Columnas creadas!!!');
	}

Nota: recordar que el método ".onupgradeneeded" se ejecuta una sola vez, entonces si no se ejecuta, toca borrar la base de datos en el inspector del navegador.

"createObjectStore" crea y devuelve un objeto "IDBObjectStore".

El primer parámetro de "createObjectStore" es el nombre del objeto "IDBObjectStore" y no el nombre de la base de datos. Este nombre puede ser cualquier nombre que desees darle.

"keyPath" es una propiedad opcional que define la clave principal del objeto "IDBObjectStore". Esta clave se utiliza para identificar de forma única cada entrada en el almacén de objetos. Puede ser una cadena que representa el nombre de una propiedad en los objetos almacenados, o un array de cadenas si se desea utilizar una combinación de propiedades como clave principal.

En "IndexedDB" un "Object Store" se puede pensar como una tabla en una base de datos relacional, y cada objeto almacenado en el "Object Store" se puede pensar como una fila en la tabla.

El "keyPath" en IndexedDB es similar a una clave primaria en una base de datos relacional. Es una propiedad del objeto almacenado que se usa como clave para identificar de manera única el objeto. Al crear un "Object Store" en "IndexedDB", se especifica una propiedad como "keyPath", lo que significa que esta propiedad se usará como clave para identificar el objeto. También es importante tener en cuenta que el "keyPath" puede ser una propiedad única o una combinación de propiedades que identifiquen de manera única el objeto.

Con "objectStore.createIndex", indicamos el nombre de la columna, el 'keyPathColumna' nos sirve para definir como se va a hacer la consulta de esa columna, y finalmente indicamos si es una columna unica(como un id) o no:

	objectStore.createIndex('nombreColumna', 'keyPathColumna', { unique: false });

_______________________________________________________

	[14.3]. Crear registros:
_______________________________________________________

Para crear registros en la tabla, lo hacemos a través de una transacción:

	let DB;

	document.addEventListener("DOMContentLoaded", () => {
		crmDB();

		setTimeout(() => {
			const nuevoCliente = {
				nombre: "Juan Perez",
				email: "juanperez@example.com",
				telefono: "123456789",
			};
			crearCliente(nuevoCliente);

			const nuevoCliente2 = {
				nombre: "Pedro Gomez",
				email: "pedrogomez@example.com",
				telefono: "987654321",
			};
			crearCliente(nuevoCliente2);
		}, 5000);
	});

	function crmDB() {

		...

		// Si se creo bien
		crmDB.onsuccess = function () {
			console.log("Base de datos creada!!!");

			DB = crmDB.result;
		};
	}

	function crearCliente(nuevoCliente) {
		let transaction = DB.transaction(["crm"], "readwrite");

		transaction.oncomplete = function () {
			console.log("Cliente creado correctamente");
		};

		transaction.onerror = function () {
			console.log("Hubo un error al crear el cliente");
		};

		const objectStore = transaction.objectStore("crm");

		const peticion = objectStore.add(nuevoCliente);

		console.log("Petición: ", peticion);
	}

Primero creamos una variable global "DB", para almacenar la base de datos si se creo bien.

Con "setTimeout" llenamos los registros despues de 5 segundos de haber creado la base de datos.

La función "crearCliente" es la encargada de crear la transacción, que en este caso su tipo de "readwrite", pero tambien hay de "readonly".

_______________________________________________________

	[14.4]. Recorrer registros:
_______________________________________________________

Para recorrer los registros de la tabla, en vez de usar "forEach", usamos un 'cursor':

	function leerClientes() {
		// Leer de indexedDB
		const objectStore = DB.transaction("crm").objectStore("crm");

		// Validar si hay registros
		const totalRegistros = objectStore.count();
		totalRegistros.onsuccess = (e) => {
			console.log(`Total de registros: ${e.target.result}`);
		};

		// Recorrer registros
		objectStore.openCursor().onsuccess = (e) => {
			const cursor = e.target.result;
			// console.log(e.target.result);

			if (cursor) {
				const { nombre, email, telefono } = cursor.value;

				// acá podemos crear HTML o lo que queramos con los datos ya desestructurados
				console.log(`Nombre: ${nombre}, Email: ${email}, Teléfono: ${telefono}`);

				// Ir al siguiente elemento
				cursor.continue();
			}
		};
	}

_______________________________________________________

	[14.5]. Actualizar un registro:
_______________________________________________________

Para actualizar un registro tambien usamos una transacción y el método "put":

	function actualizarCliente(id, clienteActualizado) {
		let transaction = DB.transaction(["crm"], "readwrite");

		transaction.oncomplete = function () {
			console.log("Cliente actualizado correctamente");
		};

		transaction.onerror = function () {
			console.log("Hubo un error al actualizar el cliente");
		};

		const objectStore = transaction.objectStore("crm");

		const peticion = objectStore.put({ ...clienteActualizado, crm: id });

		console.log("Petición de actualización: ", peticion);
	}

	actualizarCliente(1, {
		nombre: "Juan Perez Actualizado",
		email: "juanperezactualizado@example.com",
		telefono: "1234567890",
    });

Se utiliza el método "put" de un "objectStore" en "IndexedDB" para actualizar o insertar un registro en la base de datos. El objeto que se guarda se crea combinando todas las propiedades del objeto "clienteActualizado" usando el operador spread (...), y luego se le asigna o sobrescribe la propiedad "crm" con el valor de "id".

En detalle, "objectStore.put()" sirve tanto para agregar un nuevo registro como para actualizar uno existente, dependiendo de si la clave primaria ("crm" en este caso) ya existe en la base de datos. Si existe, el registro se actualiza; si no, se crea uno nuevo. El resultado de la operación se almacena en la constante "peticion", que es una solicitud (IDBRequest) que permite manejar eventos como éxito o error de la operación.

Un posible "gotcha" es que si el objeto "clienteActualizado" ya tiene una propiedad "crm", esta será sobrescrita por el valor de "id" debido al orden en que se combinan las propiedades. Además, es importante asegurarse de que el valor de "id" sea válido y único si se espera que actúe como clave primaria.

_______________________________________________________

	[14.6]. Eliminar un registro:
_______________________________________________________

Para eliminar un registro, es muy parecido a la actualización, pero con el método "delete":

	function eliminarCliente(id) {
		let transaction = DB.transaction(["crm"], "readwrite");

		transaction.oncomplete = function () {
			console.log("Cliente eliminado correctamente");
		};

		transaction.onerror = function () {
			console.log("Hubo un error al eliminar el cliente");
		};

		const objectStore = transaction.objectStore("crm");

		const peticion = objectStore.delete(id);

		console.log("Petición de eliminación: ", peticion);
	}

	eliminarCliente(2);

El "id" es el identificador del registro a eliminar.

_______________________________________________________

	[15]. API's en JavaScript:
_______________________________________________________

Una API, o Interfaz de Programación de Aplicaciones(Application Programming Interface), es un conjunto de reglas y protocolos que permite a diferentes aplicaciones de software comunicarse entre sí para intercambiar datos, funcionalidades y servicios. Es como un intermediario que facilita la interacción entre dos sistemas, permitiendo que uno acceda a las funciones o datos del otro de manera estructurada y eficiente, sin necesidad de conocer los detalles internos de su funcionamiento.

En términos más simples, una API actúa como un menú en un restaurante: el cliente (una aplicación) no necesita saber cómo se cocina cada plato (el funcionamiento interno del sistema), solo necesita saber qué platos están disponibles (las funciones de la API) y cómo pedirlos (los parámetros de la API). 

Nota: para ver todas la API's disponibles de JavaScript ir a:

	https://developer.mozilla.org/en-US/docs/Web/API
_______________________________________________________

	[15.1]. Notification API:
_______________________________________________________

Podemos enviar notificaciones desde nuestra web, siempre y cuando el usuario acepte recibirlas. Las notificaciones se envian desde el navegador al sistema nativo del usuario.

	// solicitamos permiso para mostrar notificaciones
	const notificarBtn = document.querySelector('#notificar');

	notificarBtn.addEventListener('click', () => {
		Notification
			.requestPermission()
			.then((resultado) => {
				console.log('El resultado es: ', resultado);
		});
	});

	const verNotificacionBtn = document.querySelector('#verNotificacion');

	verNotificacionBtn.addEventListener('click', () => {
		if(Notification.permission === 'granted') {
			const notificacion = new Notification('¡Hola!', {
				body: 'Esta es una notificación de prueba',
				icon: 'img/notification.png'
			});

			notificacion.onclick = () => {
				window.open('https://www.google.com');
			};
		}
	});

La "Notification API" retorna una promesa, los posibles valores que duevuelve son:

	denied --> el usuario rechaza que se muestren las notificaciones.

	granted --> el usuario acepta que se muestren las notificaciones.

	default --> la elección del usuario es desconocida y, por lo tanto, el navegador actuará como si el valor fuera denegado.

Podemos incluir una imagen personalizada en la notificación, y tambien redirigir a alguna web, cuando el usuario hace click en la notificación.

En el archivo "index.html" solo hay dos botones:

	<button type="button" id="notificar">
        Notificarme!!
    </button>

    <button type="button" id="verNotificacion">
        Ver Notificación
    </button>

Para más info de la "Notification API" ir a:

	https://developer.mozilla.org/en-US/docs/Web/API/Notification

_______________________________________________________

	[15.2]. Intersection Observer:
_______________________________________________________

"Intersection Observer" nos permite crear un observador, el cual nos notificara cuando un elemento sea visible en pantalla, muy util para cargar elementos cuando se haya hecho scroll al final, cargar imagenes con lazy loading, o añadir animaciones cuando el usuario vea una sección en especifico de nuestra app.

	document.addEventListener('DOMContentLoaded', () => {

		const observer = new IntersectionObserver((entries) => {
			entries.forEach(entrada => {
				if (entrada.isIntersecting) {
					console.log('Es visible!!!');
				}
			});
		});

		observer.observe(document.querySelector('.observado'));

	});

_______________________________________________________

	[15.3]. Detectar conexión a internet:
_______________________________________________________	

Podemos detectar si el usuario tiene o no conexión a internet:

	window.addEventListener('online', actualizarEstado);

	window.addEventListener('offline', actualizarEstado);

	function actualizarEstado() {
		if(navigator.online){
			console.log('Si hay conexión a Internet');
		}else{
			console.log('No hay conexión a Internet');
		}
	}

_______________________________________________________

	[15.4]. Ejecutar pantalla completa:
_______________________________________________________	

Podemos abrir la app a pantalla completa:

	const abrirBtn = document.querySelector('#abrir-pantalla-completa');

	const salirBtn = document.querySelector('#salir-pantalla-completa');

	abrirBtn.addEventListener('click', pantallaCompleta);

	salirBtn.addEventListener('click', cerrarPantallaCompleta);

	function pantallaCompleta() {
		document.documentElement.requestFullscreen();
	}

	function cerrarPantallaCompleta(){
		document.exitFullscreen();
	}

_______________________________________________________

	[15.5]. Detectar cuando se esta viendo la página web:
_______________________________________________________	

Podemos detectar cuando el usuario esta viendo la página web actual, esto es útil por ejemplo, para pausar un vídeo cuando el usuario cambie de pestaña del navegador.

	document.addEventListener('visibilitychange', () => {
		if(document.visibilityState === 'visible'){
			console.log('ejecutar la función para reproducir el vídeo');
		}else {
			console.log('ejecutar la función para pausar el vídeo');
		}
	});
_______________________________________________________

	[15.6]. Speech API:
_______________________________________________________	

La API de reconocimeinto de voz nos permite transcribir a texto lo que el usuario hable a través del microfono, requiere que el usuario de permisos.

	const salida = document.querySelector('#salida');
	const startRecord = document.querySelector('#microfono');

	startRecord.addEventListener('click', ejecutarSpeechAPI);

	function ejecutarSpeechAPI() {
		const SpeechRecognition = webkitSpeechRecognition || SpeechRecognition;
		const recognition = new SpeechRecognition();

		recognition.start();

		recognition.onstart = function(){
			salida.classList.add('mostrar');
			salida.textContent = 'Escuchando...';
			console.log('Iniciando reconocimiento de voz...');
		};

		recognition.onspeechend = function() {
			// salida.textContent = 'Se dejo de grabar...';
			console.log('Se dejo de grabar...');
			recognition.stop();
		};

		recognition.onresult = function(e){
			console.log(e.results[0][0]);

			const { confidence, transcript } = e.results[0][0];

			const speech = document.createElement('P');
			speech.innerHTML = `Grabado: ${transcript}`;

			const seguridad = document.createElement('P');
			seguridad.innerHTML = `Seguridad: ${Math.round(confidence * 100)}%`;

			salida.appendChild(speech);
			salida.appendChild(seguridad);
		}
	}

En el archivo "index.html" solo tenemos un botón y un div para indicar lo que se dijo:

	<button type="button" id="microfono">
        Speech Recognition API
    </button>

    <div id="salida" class="ocultar"></div>
_______________________________________________________

	[16]. Asincronía:
_______________________________________________________

Definimos la sincronía como algo secuencial, en la ejecución de código, serian tareas que se ejecutan una detrás de otra, algunas veces con estas tareas podemos tener código bloqueante, es decir código que depende de otros, como por ejemplo un click de ratón del usuario, que hace que se quede en espera en esa tarea, y no ejecuta la tarea que sigue.

Para evitar esto, tenemos la asincronía.

Ejemplos de tareas asincronas:

- Descargarse un archivo .json de otra web.
- Reproducir un .mp3 desde otra web.
- Un botón o campo de datos donde el usuario debe activar un mecanismo.
- Una orden al sintetizador de voz del navegador para que lea un mensaje.
- Una comunicación con un sensor del smartphone.

Para gestionar la asincronía desde JavaScript, tenemos los siguientes mecanismos:

- "callbacks" --> con funciones callback (evitar callback hell, mejor promesas).
- "AJAX" --> ya algo viejo, mejor usar "fetch".
- "promesas" --> Mecanismo moderno para gestionar la asincronía de forma no bloqueante.
- "async/await" --> Una forma simplificada de manejar promesas, pero bloqueante.
- "top-level await" --> Una variación de la anterior, donde no es necesario usar async en determinados contextos.

_______________________________________________________

	[16.0]. AJAX Peticiones HTTP:
_______________________________________________________

Una petición HTTP es como suele denominarse a la acción por parte del navegador de solicitar a un servidor web un documento o archivo, ya sea un fichero ".html", una imagen, una tipografía, un archivo ".js", etc. Gracias a dicha petición, el navegador puede descargar ese archivo, almacenarlo en un caché temporal de archivos del navegador y, finalmente, mostrarlo en la página actual que lo ha solicitado.

AJAX (Asynchronous Javascript and XML / JavaScript Asíncrono + XML). Es una modalidad que se basa en que la petición HTTP se realiza desde Javascript, de forma transparente al usuario, descargando la información y pudiendo tratarla sin necesidad de mostrarla directamente en la página.

Actualmente en vez de usar el formato de datos XML se usa JSON.

Existen varias formas de realizar peticiones HTTP mediante AJAX, pero las principales suelen ser "XMLHttpRequest" y "fetch" (nativas, incluidas en el navegador por defecto), además de liberías como "axios" o "superagent".
_______________________________________________________

	[16.1]. XHR: "XMLHttpRequest":
_______________________________________________________

"XMLHttpRequest" (XHR) es un objeto especial de Javascript que permite realizar peticiones HTTP asíncronas (AJAX) de forma nativa desde Javascript. Se trata de la primera implementación que existió en ECMAScript (ES5) antes de surgir fetch, el estándar actual.

Consta de 4 Pasos:

(1) Instanciar el Objeto XMLHttpRequest.
(2) Prepara la función de respuesta.
(3) Realiza la petición al servidor.
(4) Ejecuta la función de respuesta.

Ejemplo: mostrar en un alert el texto del archivo "robots.txt" que se encuentra en el servidor. El archivo "robots.txt" es un fichero de texto que suele existir en prácticamente todas las páginas webs. Se trata de un fichero de texto plano que indica las URL a las que los robots o crawlers (como el de Google) no deben acceder.

	function descargaArchivo(){
		
		//(1) Obtener la instancia del objeto XHR
		
		// Navegadores buenos
		if(window.XMLHttpRequest) {
			const peticion_http = new XMLHttpRequest();
		}
		// Navegadores Malos ej. I.E.
		else if(window.ActiveXObject) {
			const peticion_http = new ActiveXObject("Microsoft.XMLHTTP");
		}
		
		//(2) Preparar la función de respuesta

		peticion_http.onreadystatechange = muestraContenido;
		
		//(3) Realizar petición HTTP
		
		peticion_http.open('GET', 'http://localhost/holamundo.txt', true);
		peticion_http.send(null);

		//(4) Se ejecuta automáticamente la función cuando se recibe la respuesta del servidor
		
		function muestraContenido() {
			if(peticion_http.readyState == 4) {
				if(peticion_http.status == 200) {
					alert(peticion_http.responseText);
				}
			}
		}
	}

	window.onload = descargaArchivo;

El primer paso es crear un objeto XMLHttpRequest (XHR):

	// Creamos la instancia del objeto XHR
	const client = new XMLHttpRequest();

Definimos el tipo de petición utilizando el método ".open(method, url)", indicando el método HTTP y la URL a la que queremos hacer la petición:

	// Preparamos la petición y la enviamos
	client.open("GET", "/robots.txt");
	client.send();

El método ".send()", lanza la petición al servidor.
_______________________________________________________

	[16.1.1]. Propiedades XHR:
_______________________________________________________

Al crear un objeto XHR tenemos acceso a una serie de propiedades que forman parte de nuestra instancia. Entre ellas, se encuentran las siguientes:

	".responseType" --> Define el tipo de respuesta de ".response": json, Blob, etc. Por defecto, text.
 
 	".response" -->	Contenido parseado automáticamente basado en ".responseType".

	".responseText" -->	Respuesta de la petición como texto plano o  si no se ha recibido.

	".responseURL" --> URL de la petición HTTP a realizar.

	".readyState" --> Número que indica en que estado se encuentra la petición.

		0: No inicializado (objeto creado, pero no se ha invocado el método open).
		1: Cargando (objeto creado, pero no se ha invocado el método send).
		2: Cargado (se ha invocado el método send, pero el servidor aún no ha respondido).
		3: Interactivo (se han recibido algunos datos, aunque no se puede emplear la propiedad responseText).
		4: Completo (se han recibido todos los datos de la respuesta del servidor).

		Usamos "spinners" (gifs de carga), si la propiedad ".readyState" se encuentra entre 1 y 3.

		Ejemplo:

			const client = new XMLHttpRequest();

			client.addEventListener("readystatechange", () => {
			if (client.readyState === 4 && client.status === 200)
				console.log(client.responseText);
			});

			client.open("GET", "/robots.txt");
			client.send();

	".timeout" --> Milisegundos permitidos para realizar la petición HTTP. Por defecto, 0 (sin límite).

	".status" --> Código de error HTTP de respuesta de la petición (200 para respuesta correcta, 404 “No encontrado”, 500 para error del servidor, etc.).

	".statusText" --> Texto con el código de error de respuesta, legible para humanos (“OK”, “Not Found”, “Internal Server Error”, etc.).

	".withCredentials" --> Indica si la petición HTTP se está realizando con credenciales (enviando un usuario y contraseña).
_______________________________________________________

	[16.1.2]. Métodos XHR:
_______________________________________________________

Los metodos del objeto XHR son:

	".setRequestHeader("cabecera", "valor")" --> Permite establecer cabeceras personalizadas en la petición HTTP. Se debe invocar el método "open()" antes que "setRequestHeader()".

	".getAllResponseHeaders()" --> devuelve una cadena de texto con todas las cabeceras de la respuesta del servidor.

	".getResponseHeader("cabecera")" --> devuelve una cadena de texto con el contenido de la cabecera solicitada.

	".overrideMimeType(mimetype)" --> Permite modificar el MIME (tipo de fichero) de la petición.

	".open("metodo", "url")" --> Permite preparar una petición HTTP. Los parámetros necesarios son: el método Http y la url destino (se puede indicar de forma relativa o absoluta). También tiene otros parámetros opcionales:
		
		open(string método, string URL[, Boolean asíncrono, string usuario, string password]);

	".send()" --> Envía la petición previamente preparada con ".open()". Tambien se puede indicar un parámetro opcional que sea un objeto para enviar junto a la petición:

		send(body)

	".abort()" --> Cancela la petición enviada.
_______________________________________________________

	[16.1.3]. Eventos XHR:
_______________________________________________________

El objeto XHR tiene los siguientes eventos:

	".onabort" --> Se dispara cuando una petición es cancelada.

	".onload" --> Se dispara cuando una petición se ha completado correctamente.

	".onloadstart" --> Se dispara cuando una petición comienza a cargar datos.

	".onloadend" --> Se dispara cuando una petición termina (con error o sin ellos).

	".onerror" --> Se dispara cuando una petición sufre un error.

	".ontimeout" --> Se dispara cuando una petición agota el tiempo máximo.

	".onprogress" --> Se dispara (varias veces) cuando una petición recibe datos.

	".onreadystatechange" --> Se dispara cuando el valor .readyState cambia.
_______________________________________________________

	[16.2]. PROMESAS (promise):
_______________________________________________________

Usado cuando se hacen peticiones asincronas, una promesa nos permite capturar un valor de respuesta que puede estar disponible ahora, a futuro, o nunca.

	//promesas
	var saludar = new Promise((resolve, reject) =>{

		//simulamos una respuesta asincrona
		setTimeout(()=> {
			let saludo = "Hola muy buenas tardes!!!";
			//descomentar la siguiente línea para pobrar el "catch"
			//saludo= false;
			if(saludo){
				resolve(saludo);
			}else{
				reject("No hay saludo disponible");
			}

		}, 2000);
	});

	//ejecutamos la promesa
	//el ".then" es cuando haya resultado
	//el ".catch" para capturar el error
	saludar.then(resultado => {
		alert(resultado);
	})
	.catch(err =>{
		alert(err);
	});

Nota: para más info. de las promesas ir a:

	https://lenguajejs.com/javascript/asincronia/promesas/
_______________________________________________________

	[16.3]. Fetch:
_______________________________________________________

Basado en promesas de Javascript, para realizar peticiones HTTP asíncronas de una forma más legible y cómoda.

	// Realizamos la petición y guardamos la promesa
	const request = fetch("/robots.txt");

	// Si es resuelta, entonces...
	request.then(function(response) { ... });

El "fetch()" devolverá una "promesa" que será aceptada cuando reciba una respuesta y sólo será rechazada si hay un fallo de red o si por alguna razón no se pudo completar la petición. El modo más habitual de manejar las promesas es utilizando ".then()". 

El ejemplo anterior se puede reescribir de la siguiente forma, que queda mucho más simple:

	fetch("/robots.txt")
		.then(function(response) {
			/** Código que procesa la respuesta **/
		});

Al método ".then()" se le pasa una función callback donde su parámetro "response" es el objeto de respuesta de la petición que hemos realizado. En su interior realizaremos la lógica que queramos hacer con la respuesta a nuestra petición. A la función "fetch(url, options)" se le pasa por parámetro la url de la petición y, de forma opcional, un objeto options con opciones de la petición HTTP.

	// Opciones de la petición (valores por defecto)
	const options = {
		method: "GET"
	};

	// Petición HTTP
	fetch("/robots.txt", options)
		.then(response => response.text())
		.then(data => {
			/** Procesar los datos **/
		});

En el parametro opcional "options" podemos definir:

	"method" --> Método HTTP de la petición. Por defecto, "GET". Otras opciones: "HEAD"," POST", "PUT" etc...

	"body" --> Cuerpo de la petición HTTP. Puede ser de varios tipos: "String", "FormData", "Blob", etc...

	"headers" --> Cabeceras HTTP. Por defecto, {}.

	"credentials" --> Modo de credenciales. Por defecto, "omit". Otras opciones: "same-origin" e "include".

Ejemplo:

	const options = {
		method: "POST",
		headers: {
			"Content-Type": "application/json"
		},
		body: JSON.stringify(jsonData)
	};

Nota 1: con la "fetch API" solo puede leer texto plano y JSON, no soporta XML. Se puede usar para enviar o recibir datos.

Nota 2: "fetch" ya trae el "resolve" y el "reject" de la promesa definidos, no tenemos que definirlos nosotros.
_______________________________________________________

	[16.3.1]. Cabeceras (Headers):
_______________________________________________________

Se puede crear un objeto "Headers":

	const headers = new Headers();
	headers.set("Content-Type", "application/json");
	headers.set("Content-Encoding", "br");

Para trabajar con cabeceras, se usan los métodos:

	".has("name")" --> Comprueba si la cabecera "name" está definida.

	".get("name")" --> Obtiene el valor de la cabecera "name".

	".set("name", "value")" -->	Establece o modifica el valor "value" a la cabecera "name".

	".append("name", "value")" --> Añade un nuevo valor "value" a la cabecera "name".

	".delete("name")" --> Elimina la cabecera "name".

Como muchos otros objetos iterables, podemos utilizar los métodos ".entries()", ".keys()" y/o ".values()" para recorrerlos:

	for ([key, value] of headers.entries()) {
		console.log("Clave: ", key, "valor: ", value);
	}
_______________________________________________________

	[16.3.2]. Respuesta de la petición HTTP:
_______________________________________________________

En el primer ".then()" tenemos un objeto "response". Se trata de la respuesta que nos llega del servidor web al momento de recibir nuestra petición:

	// Petición HTTP
	fetch("/robots.txt", options)
		.then(response => response.text())
		.then(data => {
			/** Procesar los datos **/
		});

Se está utilizando una arrow function que hace un "return" implícito de la promesa que devuelve el método ".text()", dicho objeto "response" tiene una serie de propiedades y métodos que pueden resultarnos útiles al implementar nuestro código:

	".status" --> Código de error HTTP de la respuesta (100-599).

	".statusText" --> Texto representativo del código de error HTTP anterior.

	".ok" --> Devuelve "true" si el código HTTP es 200 (o empieza por 2), es decir, que todo ha ido correctamente. Util para comprobar si todo ha ido bien al realizar la petición:

		fetch("/robots.txt")
			.then(response => {
				if (response.ok)
					return response.text()
			})

	".headers" --> Cabeceras de la respuesta.

	".url" --> URL completa de la petición HTTP que se ha realizado.
_______________________________________________________

	[16.3.3]. Métodos del objeto "response":
_______________________________________________________

La mayoría de estos métodos, procesan mediante una promesa los datos recibidos y facilitar el trabajo con ellos:

	".text()" --> Devuelve una promesa con el texto plano de la respuesta.

	".json()" --> Idem, pero con un objeto json. Equivalente a usar JSON.parse().

	".blob()" --> Idem, pero con un objeto Blob (binary large object).

	".arrayBuffer()" --> Idem, pero con un objeto ArrayBuffer (buffer binario puro).

	".formData()" --> Idem, pero con un objeto FormData (datos de formulario).

	".clone()" --> Crea y devuelve un clon de la instancia en cuestión.

	"Response.error()" --> Devuelve un nuevo objeto "Response" con un error de red asociado.

	"Response.redirect(url, code)" --> Redirige a una url, opcionalmente con un "code" de error.

Ejemplo:

	fetch("/robots.txt")
		.then(response => response.text()) // Devuelve una promesa
		.then(data => console.log(data));

Despues de procesar la respuesta con "response.text()", devolvemos una "promesa" con el contenido en texto plano. Esta "promesa" se procesa en el segundo ".then()", donde gestionamos dicho contenido almacenado en "data".

Tenemos varios métodos similares para procesar las respuestas. Por ejemplo:

	fetch("/contents.json")
		.then(response => response.text())
		.then(data => {
			const json = JSON.parse(data);
			console.log(json);
		});

El caso anterior utilizando el método "response.json()" en lugar de "response.text()" sería equivalente al siguiente fragmento:

	fetch("/contents.json")
		.then(response => response.json())
		.then(data => {
			console.log(data);
		});

Con "response.json()" nos ahorraríamos tener que hacer el "JSON.parse()" de forma manual.
_______________________________________________________

	[16.3.4]. Ejemplos:
_______________________________________________________

1) Obtener datos desde un archivo ".txt" al hacer click en un botón:

	const cargarTxtBtn = document.querySelector("#cargarTxt");

	cargarTxtBtn.addEventListener("click", obtenerDatos);

	function obtenerDatos() {
	const url = "data/datos.txt";

	fetch(url)
		.then( respuesta => {
			console.log("Respuesta: ", respuesta);
			console.log("Status: ", respuesta.status);
			console.log("Status Text: ", respuesta.statusText);
			console.log("URL: ", respuesta.url);
			console.log("Type: ", respuesta.type);

			return respuesta.text();
		})
		.then( datos => {
			console.log("Datos: ", datos);
		})
		.catch(  error => {
			console.log("Error: ", error);
		})
	}

2) Obtener datos de un archivo ".json" al hacer click en un botón:

	const cargarJSONBtn = document.querySelector("#cargarJSON");

	cargarJSONBtn.addEventListener("click", obtenerDatos);

	function obtenerDatos() {
		const url = "data/empleado.json";

		fetch(url)
			.then( respuesta => respuesta.json() )
			.then( datos => console.log("Datos: ", datos) )
			.catch(  error => console.log("Error: ", error) )
	}

El archivo JSON, es muy parecido a un objeto de JavaScript, pero tiene las claves en strings(comillas dobles):

	{
		"id" : 1,
		"nombre" : "Juan",
		"empresa" : "Código Con Juan",
		"trabajo" : "Desarrollador Web"
	}

3) Obtener datos de un archivo ".json" que tiene un array de empleados, e imprimirlos en el HTML:

	const cargarJSONArrayBtn = document.querySelector("#cargarJSONArray");

	cargarJSONArrayBtn.addEventListener("click", obtenerDatos);

	function obtenerDatos() {
	const url = "data/empleados.json";

	fetch(url)
		.then( respuesta => respuesta.json() )
		.then( datos => mostrarHtml(datos) )
		.catch(  error => console.log("Error: ", error) )
	}

	function mostrarHtml(empleados){
		const contenido = document.querySelector('#contenido');

		let html = '';
		empleados.forEach( empleado => {
			html += `
				<p>Id: ${empleado.id}</p>
				<p>Nombre: ${empleado.nombre}</p>
				<p>Empresa: ${empleado.empresa}</p>
				<p>Trabajo: ${empleado.trabajo}</p>
				<hr>
			`;
		});
		contenido.innerHTML = html;
	}

El ".json" con los empleados en un array:

	[
		{
			"id" : 1,
			"nombre" : "Juan",
			"empresa" : "Código con Juan",
			"trabajo" : "Desarrollador Web"
		},
		{
			"id" : 2,
			"nombre" : "Alejandra",
			"empresa" : "Código con Juan",
			"trabajo" : "Diseñadora"
		},
		{
			"id" : 3,
			"nombre" : "Pedro",
			"empresa" : "Código con Juan",
			"trabajo" : "Aplicaciones Móviles"
		}
	]

4) Obtener datos desde una API y cargarlos en el HTML:

	const cargarAPIBtn = document.querySelector("#cargarAPI");

	cargarAPIBtn.addEventListener("click", obtenerDatos);

	function obtenerDatos() {
	const url = "https://picsum.photos/list";

	fetch(url)
		.then( respuesta => respuesta.json() )
		.then( datos => mostrarHtml(datos) )
		.catch(  error => console.log("Error: ", error) )
	}

	function mostrarHtml(datos){
		const contenido = document.querySelector('#contenido');

		let html = '';
		datos.forEach( perfil => {
			const { author, post_url } = perfil;
			html += `
				<p>Autor: ${author}</p>
				<a href="${post_url}" target="_blank">ver imágen</a>
				<hr>
			`;
		});
		contenido.innerHTML = html;
	}

Nota 1: la API nos devuelve un array de datos en JSON.

Nota 2: al abrir la "url" de la API en el navegador podemos ver el JSON, pero para poderlo visualizar mejor, podemos instalar una extención en el navegador como "JSONView".
_______________________________________________________

	[16.3.4.1]. Ejemplo usando promesas:
_______________________________________________________

- Comprobamos que la petición es correcta con "response.ok".

- Utilizamos "response.text()" para procesarla.

- En el caso de producirse algún error, lanzamos excepción con el código de error.

- Procesamos los datos y los mostramos en la consola.

- En el caso de que la "promesa" sea rechazada, capturamos el error con el "catch".

	// Petición HTTP
	fetch("/robots.txt")
		.then(response => {
			if (response.ok)
				return response.text()
   			else
				throw new Error(response.status);
		})
		.then(data => {
			console.log("Datos: " + data);
		})
		.catch(err => {
			console.error("ERROR: ", err.message)
		});

Podemos optimizar un poco el ejemplo anterior. Creamos la función "isResponseOk()" para procesar la respuesta (invirtiendo el condicional para hacerlo más directo). Luego, los ".then()" y ".catch()" los utilizamos con una arrow function para simplificarlos:

	const isResponseOk = (response) => {
		if (!response.ok)
			throw new Error(response.status);
		return response.text()
	}

	fetch("/robots.txt")
		.then(response => isResponseOk(response))
		.then(data => console.log("Datos: ", data))
		.catch(err => console.error("ERROR: ", err.message));
_______________________________________________________

	[16.4.0]. Try/catch:
_______________________________________________________

JavaScript es un lenguaje que, en caso de existir errores, detiene su ejecución.

Por ejemplo si tenemos el siguiente código:

	console.log(1 + 1);

	hola();

	console.log(2 + 2);

Al ejecutar el código, vemos que se imprime el número "2", y al llamar a la función "hola()" que no existe, nos marca un error y no ejecuta el segundo "console.log".

Para solucionar esto, usamos "try/catch":

	console.log(1 + 1);

	try{
		hola();
	} catch(error){
		console.log(error);
	}

	console.log(2 + 2);

Enb este caso, imprime el número "2", el mensaje de error y el número "4"

"try/catch" es muy útil para usarlo, al consultar una Base de Datos, consultar una API, autenticar un usuario, o acciones que en caso de fallar, nuestra aplicación continue funcionando.

"try/catch" tambien es muy usado con "async/await".
_______________________________________________________

	[16.4]. Async/await:
_______________________________________________________

"async/await" nos permite hacer una tarea asincrona, pero que necesitamos bloquear el código, esperando que se realice para continuar con otras operaciones.

Un ejemplo de esto, es por ejemplo si en nuestra aplicación necesitamos que el usuario se autentique correctamente antes de mostrarle su dashboard, o que se descargue un listado de usuarios antes de poder editarlos, etc.

	function descargarClientes() {
		return new Promise((resolve, reject) => {
			const error = false;

			setTimeout( () => {
				if(!error) {
					resolve('El Listado de Clientes se descargo correctamente'); 
				} else {
					reject('No se pudo aplicar el descuento');					
				}            
			}, 3000);

		});
	}

	// Async await
	async function ejecutar() {
		try {
			const respuesta = await descargarClientes(); // Deten la ejecución hasta que sea ejecutado...
			console.log(respuesta);
		} catch (error) {
			console.log(error)
		}

	}
	ejecutar();

	console.log( 2 + 2); // Este código se continua ejecutando mientras que el await sigue esperando por su respuesta

En este ejemplo, primero tenemos una función "descargarClientes()", que devuelve una promesa, cuando la constante "error" es "false", la promesa se resuelve despues de 3 segundos.

Luego en nuestra funcion "ejecutar", que es padre de la función a la que vamos a esperar (await) a que se ejecute, la definimos como "async".

Luego usamos el "try/catch", que intenta ejecutar la función "descargarClientes()", esperando (await) hasta que esta se resuelva o se rechace, es decir, en la siguiente línea, se queda esperando:

	const respuesta = await descargarClientes();

Si la promesa se resuelve, se ejecuta el código que sigue dentro del "try", en este ejemplo:

	console.log(respuesta);

En caso de rechazarse la promesa (podemos simularlo cambiando el valor de la constante "error" a "true"), no se ejeucuta "console.log(respuesta)", sino que se va directamente al "catch".

El codigo que este por fuera del "try/catch" (en el ejemplo "console.log( 2 + 2)"), se sigue ejecutando, mientras que el await sigue esperando por su respuesta.

NOTA IMPORTANTE: un "await" sólo se puede ejecutar si esta dentro de una función definida como "async".

- Si quitamos el "async" de la función padre, nos marca un error, indicando que solo se puede usar "await" dentro de una función definida como "async".

- Si quitamos el "await", de la función "async", no se pone a esperar, sino que sigue ejecutando el código, y la promesa quedaria como pendiente.

Al final, utilizar ".then()" o "async/await" es una cuestión de gustos y puedes utilizar el que más te guste.

Si queremos usar "async/await" como "function expression" en vez de "function declaration":

	const ejecutar = async () => {
		...
	};

_______________________________________________________

	[16.4.1]. Manejar múltiples awaits:
_______________________________________________________

Para ejecutar dos funciones simultaneamente (en paralelo), esperando(await) a que se ejecuten, pero que la espera de una, no detenga la espera de otra, usamos "Promise.all":

	//Es muy común tener 2 Async Await,  es probable que quieras en una misma función descargar los últimos 100 clientes y también los últimos 50 pedidos..

	function descargarNuevosClientes() {
		return new Promise( resolve => {
			console.log('Descargando Clientes....');
			setTimeout( () => {
				resolve('Los clientes fueron descargados');           
			}, 5000);

		});
	}

	function descargarUltimosPedidos() {
		return new Promise( resolve => {
			console.log('Descargando Pedidos....');
			setTimeout( () => {
				resolve('Los pedidos fueron descargados');           
			}, 3000);
		});
	}

	// La solución, Promise.all();
	const app = async () => {
		try {
			const respuesta = await Promise.all([descargarNuevosClientes(), descargarUltimosPedidos() ])
			console.log(respuesta);
			console.log(respuesta[0]);
			console.log(respuesta[1]);
		} catch (error) {
			console.log(error)
		}
	}

	app();

Si bien mandamos a llamar ambas funciones al mismo tiempo, va a obtener los resultados hasta que se terminen de ejecutar ambas, haciendo que si bien una termine de ejecutarse antes de la otra, se va a mostrar hasta que la promesa mas lenta termine.

Supongamos que el "promise1" consume 5 segundos y "promise 2" consume 10 segundos, resolver "promise1" por un lado y luego "promise 2" llevaria un total de 15 segundos, mientras que hacerlos en un "promise.all" las iniciaria y acabaria cuando la que mas tiempo toma finalice, por lo tanto, tomando solo 10 segundos y ahorrando 5 a la función o funciones que luego emplean, muestran o almacenan esos datos.

_______________________________________________________

	[16.4.2]. Async/await hacia una API con Fetch:
_______________________________________________________

Lo que haciamos con "fetch" y ".then", lo podemos hacer tambien con "async/await":

	const url = 'https://picsum.photos/list';

	document.addEventListener('DOMContentLoaded', obtenerDatos);

	function obtenerDatos(){
		fetch(url)
			.then(respuesta => respuesta.json())
			.then(resultado => console.log(resultado))
			.catch(error => console.log(error));
	}

Lo podemos traducir a "async/await":

	async function obtenerDatos(){
		try{
			const respuesta = await fetch(url);
			const resultado = await respuesta.json();
			console.log(resultado);
		} catch(error){
			console.log(error);
		}
	}

_______________________________________________________

	[16.5]. Política CORS:
_______________________________________________________

"Cross Origin" (origen cruzado) es la palabra que se utiliza para denominar el tipo de peticiones que se realizan a un dominio diferente del dominio de origen desde donde se realiza la petición. De esta forma, por una parte tenemos las peticiones de origen cruzado (cross-origin) y las peticiones del mismo origen (same-origin).

Estamos realizando peticiones relativas, es decir, al mismo dominio. Por defecto, en Javascript, las peticiones al mismo dominio de la web donde nos encontramos se pueden realizar sin ninguna restricción. Sin embargo, si intentamos realizarlas a otro dominio diferente, probablemente nos aparezca un error de CORS (Cross-Origin Resource Sharing) similar al siguiente:

	Access to XMLHttpRequest at 'https://domain.com/robots.txt' from origin 'https://currentdomain.com/' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

Las peticiones HTTP asíncronas de origen cruzado no están permitidas, pero existen formas de permitirlas. La más básica, probablemente, sea la de incluir una cabecera "Access-Control-Allow-Origin" en la respuesta de la petición, donde debe indicarse el dominio al que se le quiere dar permiso:

	Access-Control-Allow-Origin: https://domain.com/

