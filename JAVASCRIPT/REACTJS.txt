
	REACTJS:
_______________________________________________________

INDICE:

[1]. Qué es ReactJs
    [1.1]. JSX
    [1.2]. Componentes
    [1.3]. State
    [1.4]. Props
    [1.5]. Renderizado condicional
    [1.6]. Renderizado de listas
    [1.7]. Manejando Eventos
    [1.8]. Formularios
        [1.8.1]. Dependencias para el Manejo de Formularios
            [1.8.1.1]. Validación Formularios
    [1.9]. Hooks
        [1.9.1]. Reglas de los hooks
        [1.9.2]. Hook useEffect
        [1.9.3]. Creando Hooks
        [1.9.4]. Hooks "useRef"
            [1.9.4.1]. Manipulando el DOM con "useRef"
            [1.9.4.2]. Manipulando el DOM Custom Components
            [1.9.4.3]. Exponiendo metodos Custom Components
    [1.10]. Estilos
        [1.10.1]. Estilos en Línea
        [1.10.2]. Hoja de estilos por componente
        [1.10.3]. Módulos CSS
    [1.11]. Routing
        [1.11.1]. Configurando Routing
        [1.11.2]. Rutas Inexistentes
        [1.11.3]. Parámetros en las Rutas
            [1.11.3.1]. Obtener valor parámetros URL
        [1.11.4]. Navegación entre Rutas con Link
        [1.11.5]. Navegación entre Rutas con "useNavigate"
        [1.11.6]. Rutas Anidadas
    [1.12]. fetch
    [1.13]. State Management
[2]. Proyecto
    [2.0]. Instalación con Vite
        [2.0.1]. Archivos Principales
    [2.1]. Scaffolding Proyecto
    [2.2]. Creando primer componente
    [2.3]. Renderizado Lista Eventos
    [2.4]. Manejando evento buscador
    [2.5]. Evento como Props
    [2.6]. Filtrando Eventos
    [2.7]. Creando Hook reusable de Eventos
    [2.8]. Creando Router
    [2.9]. Navegar al detalle de evento
    [2.10]. fetch al API
        [2.10.1]. Enviando parámetros al API
        [2.10.2]. Creando Paginación
        [2.10.3]. fetch en pantalla de detalle
            [2.10.3.1]. Manejo de fechas en pantalla de detalle
        [2.10.4]. Variables de Entorno
    [2.11]. Implementando State Management Zustand
    [2.12]. Agregando ícono de like y unlike a los eventos
    [2.13]. Sub-componentes de Perfil
        [2.13.1]. Creando tabs
            [2.13.1.1]. Formulario Información Usuario
            [2.13.1.2]. Eventos favoritos

_______________________________________________________

	[1]. Qué es ReactJs:
_______________________________________________________

- ReactJs es una librería para el desarrollo de Frontend moderno. 
- No es un framework. 
- Se basa en componentes. 
- Es declarativa, se le indica que renderizar, no como hacerlo (imperativa).
- Funciona usando el Virtual DOM.

_______________________________________________________

	[1.1]. JSX:
_______________________________________________________

JSX es una nueva sintaxis que nos permite combinar HTML y JavaScript, esto es util si queremeos añadir un poco de lógica al código HTML, por ejemplo si esta logueado imprima X elemento, etc.

Algunas propiedades de HTML, se escriben con camelCase, como por ejemplo "class" pasa a ser "className".

Nota: para más info de JSX ir a:

    https://react.dev/learn/writing-markup-with-jsx

Para convertir HTML a JSX, debemos seguir las siguientes reglas:

1) Retornar un solo elemento raíz, esto quiere decir que no podemos devolver varios elementos HTML sueltos, sino que deben estar todos envuieltos en un contenedor, por ejemplo:

    <div>
        <h1>Hedy Lamarr's Todos</h1>
        <img 
            src="https://i.imgur.com/yXOvdOSs.jpg" 
            alt="Hedy Lamarr" 
            class="photo"
        >
        <ul>
            <li>Invent new traffic lights
            <li>Rehearse a movie scene
            <li>Improve the spectrum technology
        </ul>
    </div>

Si no se quiere crear el "div" que envuelve todo se puede usar un Fragmento (<> y </>):

    <>
        <h1>Hedy Lamarr's Todos</h1>
        <img 
            src="https://i.imgur.com/yXOvdOSs.jpg" 
            alt="Hedy Lamarr" 
            class="photo"
        >
        <ul>
            <li>Invent new traffic lights
            <li>Rehearse a movie scene
            <li>Improve the spectrum technology
        </ul>
    </>

2) Toca cerrar todos los tags HTML, incluso si no tienen cierre, como las imagenes:

    <>
        <h1>Hedy Lamarr's Todos</h1>
        <img 
            src="https://i.imgur.com/yXOvdOSs.jpg" 
            alt="Hedy Lamarr" 
            class="photo"
        />
        <ul>
            <li>Invent new traffic lights
            <li>Rehearse a movie scene
            <li>Improve the spectrum technology
        </ul>
    </>

3) Usar camelCase en los atributos HTML:

    <img 
        src="https://i.imgur.com/yXOvdOSs.jpg" 
        alt="Hedy Lamarr" 
        className="photo"
    />

Nota: podemos usar una herramienta online de conversión para pasar de HTML a JSX:

    https://transform.tools/html-to-jsx

_______________________________________________________

	[1.2]. Componentes:
_______________________________________________________

Un componente es una función tradicional, que devuelve código de JSX.

El nombre del componente por convensión se define en PascalCase.

Nota: Para empezar, podemos usar la siguiente herramienta online para probar Vite +  React:

    https://stackblitz.com/edit/vitejs-vite-lataab?file=index.html&terminal=dev

- Creamos el archivo "MyFirstComponent.jsx" dentro de la carpeta "src":

    const MyFirstComponent = () => {
        const hola = 'Hola';
        return (
            <div>
                {hola} este es un componente!!!
            </div>
        );
    };

    export default MyFirstComponent;

O tambien podemos declarar un componente de la siguiente manera:

    function MyFirstComponent(){
        const hola = 'Hola';
        return {
            <div>
                {hola} este es un componente!!!
            </div>
        };
    }

    export default MyFirstComponent;

Nota 1: para usar variables o código JS dentro del HTML que retornamos usamos {}.

Nota 2: un archivo de JSX solo puede exportar una función.

- Para incluir el componente lo importamos y llamamos como una etiqueta HTML, en el componente principal "App.jsx":

    import { useState } from 'react';
    import './App.css';
    import MyFirstComponent from './MyFirstComponent';

    function App() {
        return (
            <>
                <MyFirstComponent />
            </>
        );
    }

_______________________________________________________

	[1.3]. State:
_______________________________________________________

React tiene un conjunto de funciones llamadas ganchos(hooks). Los ganchos te permiten agregar lógica adicional, como el estado(state), a tus componentes. Puedes pensar en el estado como cualquier información en tu interfaz de usuario que cambia con el tiempo, generalmente activado por la interacción del usuario.

Para que un componente sea reactivo, podemos declarar estados, usando "useState" podemos obtener un valor o setearlo

    import { useState } from 'react';

    const MyFirstComponent = () => {

        const [value, setValue] = useState(0);
        const [hola, setHola] = useState('Hola');

        setTimeout(() => {
            setValue(value + 1);
        }, 3000);


        return {
            <div>
                {hola} este es un componente!!! valor: {value}
            </div>
        };
    };

    export default MyFirstComponent;

Se usa desestructuración de arrays para obtener los dos valores de "useState", el primer elemento es el valor, y el segundo es el setter. 

Lo que le pasemos como argumento a la función "useState", es el valor inicial, en este ejemplo "0". Pero como valor inicial podemos asignar números, strings, objetos u otro valor que necesitemos.

Con el setter de "useState", React usa inmutabilidad, hace una copia de objeto inicial y reemplaza solo el valor que debe cambiar. Cuando se actualiza el valor, se re renderiza todo el componente.

_______________________________________________________

	[1.4]. Props:
_______________________________________________________

Los componentes de React, pueden tener propiedades, similares a los atributos HTML en una etiqueta, pero en React se llaman "props".

1) En el componente principal enviamos las props al componente hijo:

    import { useState } from 'react';
    import './App.css';
    import MyFirstComponent from './MyFirstComponent';

    function App() {

        const [value, setValue] = useState(0);

        setTimeout(() => {
            setValue(value + 1);
        }, 3000);

        return (
            <>
                <MyFirstComponent propOne={value} propTwo={2} propThree={{}} />
            </>
        );
    }

En este caso enviamos tres propiedades ( propOne={value} propTwo={2} propThree={{}} ), la ultima propiedad es un objeto vacio. Y como curiosidad en la propOne enviamos el valor del estado del componente principal.

Al actualizarse el estado del compennete principal, tambien se actualizan sus componentes hijos.

2) En el componente hijo recibimos las props como argumentos de la función:

    import { useState } from 'react';

    const MyFirstComponent = ({
        propOne,
        propTwo,
        propThree
    }) => {

        const [value, setValue] = useState(0);
        const [hola, setHola] = useState('Hola');

        setTimeout(() => {
            setValue(value + 1);
        }, 3000);

        console.log( propOne,
        propTwo,
        propThree );

        return {
            <div>
                {hola} este es un componente!!! valor: {value}
            </div>
        };
    };

    export default MyFirstComponent;

Como argumento del componente recibimos un objeto con las 3 propiedades, usamos desestructuración de objetos(solo encerramos las propiedades en {}), para que sea más sencillo acceder a las propiedades.

_______________________________________________________

	[1.5]. Renderizado condicional:
_______________________________________________________

El renderizado condicional es para mostrar determinados elementos si se cumple una condición, o si no mostrar otros:

- Usando "if else":

    if (isPacked) {
        return <li className="item">{name} ✔</li>;
    }
    return <li className="item">{name}</li>;

- Usando "operador ternario":

    return (
        <li className="item">
            {isPacked ? name + ' ✔' : name}
        </li>
    );

En JSX, {cond ? <A /> : <B />} significa: si cond, renderiza <A />, si no <B />.

- Usando operador lógico AND:

    return (
        <li className="item">
            {name} {isPacked && '✔'}
        </li>
    );

En JSX, {cond && <A />} significa: si cond, renderiza <A />, si no, nada.

- No mostrar nada con "null":

    if (isPacked) {
        return null;
    }
    return <li className="item">{name}</li>;

Nota: Para más info de renderizado condicional ir a:

    https://es.react.dev/learn/conditional-rendering

_______________________________________________________

	[1.6]. Renderizado de listas:
_______________________________________________________

Para el renderizado de listas (varios ítems), usamos dos metodos de Arrays de JavaScript: 

    filter()
    map()

Estos metodos retornan un array.

    const MyFirstComponent = () => {

        const arrayOfNumbers = [1, 2, 3, 4, 5, 6, 7, 8];

        const numberItems = arrayOfNumbers.map((item) => <li key={`array-number-item-${item}`} >{item}</li>);

        /*
        let numberItems = [];

        for(const item of arrayOfNumbers){
            numberItems.push(<li>{item}</li>);
        }
        */

        const arrayOfPeople = [
            {
                "id": 1,
                "name": "Uriel",
                "age": 20,
            },
            {
                "id": 2,
                "name": "Juan",
                "age": 24,
            },
            {
                "id": 3,
                "name": "Jose",
                "age": 21,
            },
            {
                "id": 4,
                "name": "Ismael",
                "age": 30,
            }
        ];

        const peopleItems = arrayOfPeople.map((person) => <li key={`array-person-item-${person.id}`} >{`${person.id}: ${person.name}`}</li>);

        return {
            <>
                <ul>
                    {numberItems}
                </ul>

                <ul>
                    {peopleItems}
                </ul>
            </>
        };
    };

    export default MyFirstComponent;

En React a c/u de los elementos que cremos de la lista le debemos asignar un id unico(key), ya que tiene que estar vigilandolos en caso de querer actualizar alguno.

Podemos usar un ciclo "for" de siempre para generar la lista de ítems, pero lo más usado es el método "map".

Nota: para más info del renderizado de listas ir a:

    https://es.react.dev/learn/rendering-lists

_______________________________________________________

	[1.7]. Manejando Eventos:
_______________________________________________________

Para manejar eventos, definimos dentro del componente la función que maneja el evento, la sintaxis para manejar el evento es muy similar a la que ya usa JavaScript, y usa camelCase:

    export default function Button() {
        function handleButtonClick() {
            alert('¡Me hiciste clic!');
        }

        return (
            <button onClick={handleButtonClick}>
                Hazme clic
            </button>
        );
    }

Nota 1: todos los eventos empiezan con el prefijo "on".

Nota 2: por convenciones la función manejadora del evento debemos nombrarla "handleElementoEvento", para que sea más descriptiva e indique que es un manejador de eventos.

Nota 3: si la función que maneja el evento tiene más de una línea de codigo, es mejor crear función, si no es así, se puede manejar ahí mismo:

    export default function Button() {

        return (
            <button onClick={() => alert('¡Me hiciste clic!')} >
                Hazme clic
            </button>
        );
    }

Nota 4: para más info del manejo de ventos ir a:

    https://es.react.dev/learn/responding-to-events

    https://es.react.dev/reference/react-dom/components/common

Algunas veses se desea desde el componente padre pasarle el manejador de eventos al componente hijo, esto de puede hacer desde las propiedades:

En el componente hijo:

    function Button({ onClick, children }) {
        return (
            <button onClick={onClick}>
                {children}
            </button>
        );
    }

En el componente padre:

    function UploadButton() {
        return (
            <Button onClick={() => alert('¡Subiendo!')}>
                Subir imagen
            </Button>
        );
    }

Nota: para más info ir a:

    https://es.react.dev/learn/responding-to-events#passing-event-handlers-as-props

_______________________________________________________

	[1.8]. Formularios:
_______________________________________________________

Para el uso de formularios podemos hacerlo de una manera facil, como si fuera HTML normal.

1) En un componente creamos la estructura basica del formulario:

    const SignupForm = () => {
        return (
            <form>
                <div className="form-field">
                    <label>
                        Name
                        <input value={} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Age
                        <input value={} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Address
                        <input value={} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Zipcode
                        <input value={} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Phone
                        <input value={} />
                    </label>
                </div>
            </form>
        );
    };

    export default SignupForm;

2) Para cada campo del formulario creamos un estado con su respectivo setter, y tambien manejamos el evento "onChange", para poder actualizar los valores de cada input:

    import { useState } from "react";

    const SignupForm = () => {
        const [name, setName] = useState('');
        const [age, setAge] = useState('');
        const [address, setAddress] = useState('');
        const [zipcode, setZipcode] = useState('');
        const [phone, setPhone] = useState('');

        return (
            <form>
                <div className="form-field">
                    <label>
                        Name
                        <input value={name} onChange={(event) => setName(event.target.value)} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Age
                        <input value={age} onChange={(event) => setAge(event.target.value)} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Address
                        <input value={address} onChange={(event) => setAddress(event.target.value)} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Zipcode
                        <input value={zipcode} onChange={(event) => setZipcode(event.target.value)} />
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Phone
                        <input value={phone} onChange={(event) => setPhone(event.target.value)} />
                    </label>
                </div>
            </form>
        );
    };

3) Para obtener los valores del formulario, manejamos las acciones del formulario con sus botones:

    const handleClearClick = () =>{
        setName('');
        setAge('');
        setAddress('');
        setZipcode('');
        setPhone('');
    };

    const handleSubmitForm = (event) =>{
        event.preventDefault();

        console.log('submit:', {
            name,
            age,
            address,
            zipcode,
            phone
        });
    };

    return (
        <form onSubmit={handleSubmitForm}>

            <div className="form-field">
                <label>
                    Name
                    <input value={name} onChange={(event) => setName(event.target.value)} required/>
                </label>
            </div>

            ...

            <div className="form__actions">
                <button type="button" onClick={handleClearClick} >Clear</button>
                <button type="submit">Submit</button>
            </div>
        </form>
    );


Nota 1: es necesario indicar el type="button" en los botones que realizan otras acciones diferentes a "submit", para evitar que hagan submit del formulario.

Nota 2: Al colocar un boton con type="submit", no se escucha el click de dicho boton, sino que se empieza a manejar el evento "onSubmit" del formulario. En su manejador hacemos "event.preventDefault();" para evitar que se recargue la página.

Nota 3: podemos añadir validaciones sencillas de HTML5, como el atributo "required" en los campos del formulario.

_______________________________________________________

	[1.8.1]. Dependencias para el Manejo de Formularios:
_______________________________________________________

Existen unas dependencias que podemos usar parea manejar el estado,  las validaciones y el envio de los campos del formulario de una forma más sencilla, entre las cuales tenemos:

    - React Hook Form (https://www.react-hook-form.com/)
    - FormiK (https://formik.org/)

1) Para usar React Hook Form, desde la raiz del proyecto instalamos la dependencia:

    npm install react-hook-form

2) En nuestro componente de formulario importamos "useForm", y en vez de usar el "useState", y el evento "onChange" en cada campo del formulario, registramos los campos:

    import { useForm } from "react-hook-form";

    const SignupForm = () => {
        const { register, handleSubmit } = useForm();

        const handleClearClick = () =>{
            
        };

        const handleSubmitForm = (data) =>{
            console.log('submit:', data);
        };

        return (
            <form onSubmit={handleSubmit(handleSubmitForm)}>
                <div className="form-field">
                    <label>
                        Name
                        <input {...register('name')} required/>
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Age
                        <input {...register('age')} required/>
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Address
                        <input {...register('address')} required/>
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Zipcode
                        <input {...register('zipcode')} required/>
                    </label>
                </div>
                <div className="form-field">
                    <label>
                        Phone
                        <input {...register('phone')} required/>
                    </label>
                </div>

                <div className="form__actions">
                    <button type="button" onClick={handleClearClick} >Clear</button>
                    <button type="submit">Submit</button>
                </div>
            </form>
        );
    };

    export default SignupForm;

Acá hicimos lo siguiente:

    - Instanciamos las funciones que vamos a usar:

        const { register, handleSubmit } = useForm();

    - Registramos los campos del formulario con:

        ...register('nombreCampo')

    - Usamos "handleSubmit" para manejar el envio del formulario, esta función recibe como parametro una función propia para manejar el evento "submit", y esa función recibe como parametro la "data" que se va a enviar.

        handleSubmit(funcionPropia)

3) Para resetear el formulario, instanciamos la función "reset":

    const SignupForm = () => {

        const { register, handleSubmit, reset } = useForm();

        const handleClearClick = () =>{
            reset();
        };

4) Para hacer las validaciones más personalizadas usamos "formState":

    const { register, handleSubmit, reset, formState: { errors } } = useForm();

    return (
        <form onSubmit={handleSubmit(handleSubmitForm)}>
            <div className="form-field">
                <label>
                    Name
                    <input {...register('name', { required: true })} />
                    {errors.name && <span>This field is required</span>}
                </label>
            </div>

_______________________________________________________

	[1.8.1.1]. Validación Formularios:
_______________________________________________________

Podemos definir diferentes reglas de validación o incluso crear una función de validación propia, podemos ver las reglas ya definidas de "React Hook Form" en:

    https://www.react-hook-form.com/api/useform/register/

Por ejemplo:

    <input
        {...register("age", {
            required: true,
            min: 1,
            max: 110,
            valueAsNumber: true,
        })}
        className={styles.forminput}
        type="number"
    />
    {errors.age && errors.age.type === "required" && (
        <span>Este campo es requerido.</span>
    )}
    {errors.age && errors.age.type === "min" && (
        <span>Edad minima 1 año.</span>
    )}

Tambien podemos definir la validación y el mensaje de error así:

    <input
        {...register("age", {
            required: {
                value: true,
                message: "Este campo es requerido."
            },
            min: {
                value: 1,
                message: "Edad minima 1 año."
            },
            max: {
                value: 110,
                message: "Edad máxima 110 años."
            },
            valueAsNumber: true,
        })}
        className={styles.forminput}
        type="number"
    />

Para luego instalar un componente para manejar de foprma más facil los mensajes de error:

1) lo instalamos:

    npm install @hookform/error-message

2) lo importamos:

    import { ErrorMessage } from '@hookform/error-message';

3) lo usamos:

    <ErrorMessage
        errors={errors}
        name="age"
        render={({ message }) => <p>{message}</p>}
    />

Nota: Para más info del cmponente de mensajes de error:

    https://www.react-hook-form.com/api/useformstate/errormessage/

_______________________________________________________

	[1.9]. Hooks:
_______________________________________________________

Los Hooks son funciones con su código ya encapsulado, que nos permiten inplementar diversas funcionalidades que ya se encuentran desarrolladas, solo tenemos que usarlas.

Uno de los Hooks que ya hemos visto es el de "useState", el cual nos sirve para obtener y setear el estado.
_______________________________________________________

	[1.9.1]. Reglas de los hooks:
_______________________________________________________

Los Hooks cumplen dos reglas:

    - Llama Hooks solo en el nivel superior; No llames Hooks dentro de ciclos, condicionales o funciones anidadas.

    - Llama Hooks solo en funciones de React; No llames Hooks desde funciones JavaScript regulares.

Nota: para más info ir a: 

    https://es.legacy.reactjs.org/docs/hooks-rules.html

_______________________________________________________

	[1.9.2]. Hook useEffect:
_______________________________________________________

El hook "useEffect" permite ejecutar código cada vez que alguna de sus dependencias cambia, se ejecuta cuando se monta el componente y cuando cambia alguna de sus dependencias.

Recibe dos argumentos:

    useEffect(() => {}, []);

El primer argumento es el "callback" o función flecha con el código que queremos que se ejecute.

El segundo argumento(opcional) es un array con sus dependencias, es decir donde le podemos indicar por ejemplo una variable, y si el valor de esa variable cambia, se ejecutaria el código del callback.

Nota 1: si necesitamos tener varios "useEffect", uno con una función y una dependencia, y otro con otra función y otra dependencia, podemos tener "N" cantidad de "useEffect" sin problemas.

Nota 2: en modo desarrollo los "useEffect" se ejecutan 2 veses, pero solo es en desarrollo.

Nota 3: la función callback de "useEffect" no puede ser asincrona, por dentro de la función flecha si puede llamar una función asincrona, pero esa función flecha no puede ser asincrona.

Nota 4: para más info ir a:

    https://es.react.dev/reference/react/useEffect

_______________________________________________________

	[1.9.3]. Creando Hooks:
_______________________________________________________

Podemos crear hooks con funcionalidades que veamos que podemos reutilizar en diferentes componentes de nuestra app.

Para crear un Hook:

1) Creamos una carpeta llamada "hooks" dentro de la carpeta "src".

2) Dentro de la carpeta "hooks", creamos nuestro "archivoDeHook.js" usando las siguientes buenas practicas:

    - el nombre del archivo va en camelCase.

    - el nombre del archivo empieza con la palabra "use", seguido de lo que hace el hook, por ejemplo:

        usePokemonsData.js

Nota: la extensión del archivo es ".js" y no ".jsx", ya que no retorna un componente sino información.

3) El código del hook es una simple función modulo que puede retornar un objeto, un array o un valor. Por ejemplo:

    import pokemonsJSON from '../ruta/pokemons.json';

    const usePokemonsData = () => {

        ...

        return {
            pokemons
        }
    };

    export default usePokemonsData;

_______________________________________________________

	[1.9.4]. Hooks "useRef":
_______________________________________________________

El hook "useRef" nos sirve para referenciar un valor que no es necesario para renderizar.

Ejemplo:

    import { useRef } from 'react';

    export default function Counter() {
        let ref = useRef(0);

        function handleClick() {
            ref.current = ref.current + 1;
            alert('You clicked ' + ref.current + ' times!');
        }

        return (
            <button onClick={handleClick}>
                Click me!
            </button>
        );
    }

Las diferencias entre "useRef" y "useState" son las siguientes:

    - useRef(initialValue) retorna { current: initialValue } <-- vs --> useState(initialValue) retorna valor actual de la variable de estado y la función setter del estado ( [value, setValue]).

    - "useRef" No desencadena el render cuando cambia <-- vs --> "useState" Dispara el re renderizado cuando se modifica.

    - "useRef" es Mutable: puede modificar y actualizar el valor actual fuera del proceso de renderizado. <-- vs --> "useState" es "Inmutable": debe usar la función de setter para modificar las variables de estado para poner en cola un nuevo re rendereo.

    - Con "useRef" No debemos leer (ni escribir) el valor actual durante el renderizado. <-- vs --> Con "useState" se puede leer el estado en cualquier momento. Sin embargo, cada render tiene su propia instantánea(snapshot) del estado que no cambia.

Nota 1: Para más info y ejemplos de "useRef":

    https://react.dev/reference/react/useRef

Nota 2: Para ver las diferencias y un ejemplo de "useRef" y "useState":

    https://react.dev/learn/referencing-values-with-refs#differences-between-refs-and-state

_______________________________________________________

	[1.9.4.1]. Manipulando el DOM con "useRef":
_______________________________________________________

El hook "useRef" lo podemos usar para obtener una referencia a un elemento del DOM(guardar el elemento en una variable), y nos sirve para obtener sus atributos (HTML), modificar su contenido, obtener medidas (width, height, etc.) del elemento.

    import { useRef } from 'react';

    export default function Form() {
        const inputRef = useRef(null);

        function handleClick() {
            inputRef.current.focus();
        }

        return (
            <>
                <input ref={inputRef} />
                <button onClick={handleClick}>
                    Focus the input
                </button>
            </>
        );
    }

1) En este ejemplo, primero declaramos un objeto de referencia, con un valor inicial de null:

    const inputRef = useRef(null);

2) Luego pasamos el objeto de referencia como atributo "ref" al JSX del nodo DOM que queremos manipular:

    <input ref={inputRef} />

3) Después de que React crea el nodo DOM y lo coloca en la pantalla, React establecerá la propiedad "current" del objeto de referencia en ese nodo DOM. Ahora se puede acceder al nodo DOM del <input> y llamar a métodos como focus():

    function handleClick() {
        inputRef.current.focus();
    }

React volverá a establecer la propiedad "current" en nula cuando se elimine el nodo de la pantalla.

_______________________________________________________

	[1.9.4.2]. Manipulando el DOM Custom Components:
_______________________________________________________

Si intentamos referenciar un componente custom que hayamos creado para manipularlo, obtendremos un error, para evitar esto, envolvemos el componente hijo al que queremos manipular en el hook "forwardRef":

1) En el componente hijo:

    import { forwardRef } from 'react';

    const MyInput = forwardRef(({ value, onChange }, ref) => {
        return (
            <input
            value={value}
            onChange={onChange}
            ref={ref}
            />
        );
    });

    export default MyInput;

Nota: el hook "forwardRef" recibe como primer parametro las "props" del componente y como segundo parametro la referencia "ref":

    forwardRef( (props, ref) => {} );

2) Y en el componente padre:

    const inputRef = useRef(null);

    console.log("Referencia DOM: ", inputRef.current);

    return <MyInput ref={inputRef} />;

Nota: acá en el console.log imprimimos el elemento del DOM que se obtuvo(el componente hijo), pero podemos tenerlo en una función y por ejemplo, manipular sus atributos HTML.

_______________________________________________________

	[1.9.4.3]. Exponiendo metodos Custom Components:
_______________________________________________________

Con el hook "useImperativeHandle", en vez de devolver al padre la referencia al elementoDOM, podemos exponenr metodos o propiedades propios del componente:

1) En el componente hijo usamos "useImperativeHandle":

    import { useState, forwardRef, useImperativeHandle } from 'react';

    const MyInput = forwardRef((props, ref) => {
        const [valorInput, setValorInput] = useState(0);

        useImperativeHandle(ref, () => ({
            valorInput,
            setValorInput,
            saludar,
        }));

        function saludar() {
            console.log('Hello!!!');
        }

        return <input {...props} ref={ref} />;
    });

    export default MyInput;

En este caso al componente padre le estamos enviando "valorInput" y la función para setearlo "setValorInput".

2) En el componente padre:

    import { useRef } from 'react';
    import MyInput from './MyInput.js';

    export default function Form() {
        const ref = useRef(null);

        function handleClick() {
            console.log("Valor del input enviado desde el componente hijo: ", ref.current.valorInput);

            // setear el Valor
            ref.current.setValorInput(3);

            ref.current.saludar();


            //Esto no funcionará porque el nodo DOM no está expuesto
            // ref.current.style.opacity = 0.5;
        }

        return (
            <form>
                <MyInput placeholder="Enter your name" ref={ref} />
                <button type="button" onClick={handleClick}>
                    Editar
                </button>
            </form>
        );
    }

En el componente padre, podemos usar los metodos y propiedades que definamos en el componente hijo con "useImperativeHandle".

Nota 1: No sobreutilizar las refs. Solo debes usar las refs para comportamientos imperativos que no puedes expresar como props: por ejemplo desplazarse a un nodo, enfocar un nodo, activar una animación, seleccionar texto, etc.

Si puedes expresar algo como una prop, no deberias usar una ref. Por ejemplo, en vez de exponer un identificador imperativo como { open, close } del componente Modal, es mejor tomar isOpen como una prop, algo como <Modal isOpen={isOpen} />.

Nota 2: para mas info del hook "useImperativeHandle" ir a:

    https://es.react.dev/reference/react/useImperativeHandle

_______________________________________________________

	[1.10]. Estilos:
_______________________________________________________

Podemos añadir estilos a los componentes de varias formas:

- En línea.
- Hoja de estilos por componente.
- Módulos CSS.

_______________________________________________________

	[1.10.1]. Estilos en Línea:
_______________________________________________________

En línea, pasandole un objeto con las propiedades CSS:

    <div style={{
        marginBottom: 14,
        width: '100%',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
    }}>

Las propiedades CSS se indican en "camelCase".

Los valores de las propiedades se las podemos indicar el solo número sin unidades y por defecto lo toma en pixeles, o si queremos indicar unidades como "em", porcentajes o son más de un valor, lo hacemos en un string entre comillas.

    style={{
        padding: '4px 8px'
    }}
_______________________________________________________

	[1.10.2]. Hoja de estilos por componente:
_______________________________________________________

1) Dentro de la carpeta del componente en un archivo "styles.css" aparte, donde manejamos los estilos de forma tradicional, por clases o con los selectores que se necesiten:

    .event-item__container{
        display: flex;
        align-items: center;
        gap: 15px;
        margin: 24px 0;
    }

2) En el archivo del componente "index.jsx" importamos la hoja de estilos correspondiente, y en el HTML indicamos las clases con "className":

    import './styles.css';

    const EventItem = ({
        info,
        name,
        image,
        onEventClick,
        id
    }) => {

        const handleSeeMoreClick = (event) => {
            event.stopPropagation();
            onEventClick(id);
        };

        return(
            <div onClick={ () => console.log('padre clickeado') } className='event-item__container'>
                <img src={image} alt={name} width="200px"/>
                <div className='event-item__info'>
                    <h4 className='event-item__title'>{name}</h4>
                    <p className='event-item__desc'>{info}</p>
                    <button onClick={ handleSeeMoreClick } className='event-item__call'>Ver más</button>
                </div>
            </div>
        )
    };

    export default EventItem;
_______________________________________________________

	[1.10.3]. Módulos CSS:
_______________________________________________________

Estos módulos CSS tienen la ventaja que las clases generan un hash, para que el nombre de la clase no colisione con la clase de otro componente, quedando más encapsulados los estilos.

1) En la carpeta del compoente, creamos un archivo con el mismo nombre del compoente:

    NombreComponente.module.css

Por ejemplo:

    EventItem.module.css

2) En el archivo del modulo que creamos "NombreComponente.module.css", indicamos los estilos, pero las clases las indicamos con "camelCase":

    .eventItemContainer{
        display: flex;
        align-items: center;
        gap: 15px;
        margin: 24px 0;
    }

    .eventItemInfo{
        display: flex;
        flex-direction: column;
        align-items: flex-start;
    }

3) En nuestro archivo de compoente, importamos el módulo CSS:

    import nombremodulo from './rutaModulo/NombreComponente.module.css';

Por ejemplo:

    import styles from './EventItem.module.css';

4) Y en el HTML del componente, en el "className" indicamos el modulo y la clase que se requiera:

    <div className={styles.eventItemContainer}>

Nota 1: al inspeccionar los elementos en el navegador, vemos que se aplican los estilos, y fuera de eso, a cada clase se le agrega el hash único, por ejemplo:

    <div class="_eventItemContainer_lkq6q_1" >

Nota 2: para indicarle a un elemento más de una clase, concatenamos con template strings:

    <div className={`${styles.eventItemContainer} ${styles.otraClase}`}>

_______________________________________________________

	[1.11]. Routing:
_______________________________________________________

Para la navegación entre paginas de nuestra app, manejaremos las diferentes rutas, donde cada ruta es un componente, por ejemplo:

    /login --> componente <Login />
    /signup --> componente <Signup />
    /home --> componente <Home />
    /profile --> componente <Profile />

Cada página o componente puede manjar N cantidad de componentes internos.

La forma en como funcionan las rutas, podemos imaginarlas como una pila de libros, por ejemplo, si vamos al "login", el libro de "login" queda sobra la mesa, luego vamos al "home", por lo que el libro del "home" queda encima del libro de "login", luego abrimos "profile", y este se apila sobre "home", etc.

Tambien lo podemos ver como un array, en donde vamos haciendo push(añadir a la pila), y si le damos "atras" en el navegador, hariamos pop del array (eliminar el ultimo elemento).

Para el Routing, usaremos la libreria "React Router":

    https://reactrouter.com/en/main

Esto usa Client Side Routing, que hace que en vez de recargar toda la pagina, permite que la aplicación actualice la URL a partir de un clic en un enlace sin realizar otra solicitud de otro documento desde el servidor. En cambio, la aplicación puede representar inmediatamente una nueva interfaz de usuario y realizar solicitudes de datos con "fetch" para actualizar la página con nueva información.

_______________________________________________________

	[1.11.1]. Configurando Routing:
_______________________________________________________

1) Instalamos la dependencia con el comando:

    npm install react-router-dom

2) Dentro de "/src", creamos la carpeta "routes".

3) Dentro de "/routes" creamos el archivo "index.jsx":

    import {
        createBrowserRouter,
        RouterProvider,
    } from "react-router-dom";

    const router = createBrowserRouter([
        {
            path: "/",
            element: <div>Home</div>,
        },
        {
            path: "/detail",
            element: <div>Detail</div>,
        },
    ]);

    const MyRoutes = () => {
        return (
            <RouterProvider router={router} />
        );
    };

    export default MyRoutes;

Primero importamos "createBrowserRouter" y "RouterProvider".

En la constante "router", creamos las rutas con la función "createBrowserRouter()" pasandole como parametro un array de objetos.

Cada objeto de la ruta, tiene dos llaves: el "path", con la ruta y el "element" con el componente o elemento a renderizar.

Tenemos "MyRoutes", que tiene el código base de cualquier modulo o componente. en este caso retorna el componente "RouterProvider", al que le pasamos como atributo la constante "router".

4) Lo ideal es que en la key "element" de cada objeto de la ruta le pasemos el componente de la vista o página a renderizar. Para esto creamos dentro de "/src" una carpeta llamada "views" o "pages" (a elección del desarrollador).

5) En la carpeta "/views", creamos las carpetas "Home" y "Detail" con sus respectivos archivos "index.jsx" para sus componentes:

    - En "src\views\Home\index.jsx":

        const Home = () => {
            return (
                <div>Home</div>
            );
        };

        export default Home;
    
    - En "src\views\Detail\index.jsx":

        const Detail = () => {
            return (
                <div>Detail</div>
            );
        };

        export default Detail;

6) Importamos y usamos los componentes en el router:

    import Home from "../views/Home";
    import Detail from "../views/Detail";

    const router = createBrowserRouter([
        {
            path: "/",
            element: <Home />,
        },
        {
            path: "/detail",
            element: <Detail />,
        },
    ]);

7) Importamos en el archivo "src\App.jsx" nuestro componente router:

    import Routes from './routes';

    function App() {
        return <Routes />
    }

    export default App

8) Probamos las rutas creadas en el navegador.

_______________________________________________________

	[1.11.2]. Rutas Inexistentes:
_______________________________________________________

Podemos configurar una ruta para errores 404.

1) En la carpeta "views" creamos la carpeta para el componente llamado "Error404":

    import { useRouteError } from "react-router-dom";

    const Error404 = () => {
        const error = useRouteError();
        console.error(error);

        return (
            <div className="errorPage">
                <h1 className="errorPageTitle">Oops! {error.status}</h1>
                <p className="errorPageDesc">No hemos encontrado lo que buscas.</p>
                <p className="errorPageError">
                    <i>{error.statusText || error.data}</i>
                </p>
            </div>
        );
    };

    export default Error404

En este componente importamos y usamos el hook "useRouteError", de nuestra libreria de router, para saber que tipo de error obtenemos.

2) En nuestro componente de router, definimos en la ruta raíz(home) el componente para el error:

    const router = createBrowserRouter([
        {
            path: "/",
            element: <Home />,
            errorElement: <Error404 />
        },
        {
            path: "/detail",
            element: <Detail />,
        },
    ]);

Para probar nuestra ruta 404, en el navegador escribimos:

    /rutaQueNoExiste

_______________________________________________________

	[1.11.3]. Parámetros en las Rutas:
_______________________________________________________

Para poder recibir en la ruta parametros de forma dinamica, definimos el "path" de la ruta de la siguiente manera:

    const router = createBrowserRouter([
        {
            path: "/",
            element: <Home />,
            errorElement: <Error404 />
        },
        {
            path: "/detail/:eventId",
            element: <Detail />,
        },
    ]);

Ahora si accedemos a "/detail", nos renderiza el componente de Error404. Ahora el componente recibe un parametro (numero o string) por la url así: "/detail/algo"

_______________________________________________________

	[1.11.3.1]. Obtener valor parámetros URL:
_______________________________________________________

Para obtener los valores de los parámetros enviados por la URL, en el componente que renderiza la ruta con el parametro, usamos el hook "useParams":

    import { useParams } from "react-router-dom";

    const Detail = () => {
        const { eventId } = useParams();

        console.log("Id del evento: ", eventId);

        return (
            <div>Detail</div>
        );
    };

    export default Detail;

Nota: acá desestructuramos "eventId", que debe coincidir con el parametro definido en el router.
_______________________________________________________

	[1.11.4]. Navegación entre Rutas con Link:
_______________________________________________________

Para crear links que nos sirvan para navegar entre las rutas que creamos, importamos y usamos el componente "Link" de nuestra libreria de router:

    import { Link } from "react-router-dom";

    return (
        <div>
            <Link to={`/detail/${id}`}>Ir al detalle</Link>
        </div>
    );

Este componente Link, nos crea una etiqueta de ancla "a" que redirige a la ruta especificada. 

Nota: En este caso la variable "id", la concatenamos a "/detail/", para navegar a esa ruta.

_______________________________________________________

	[1.11.5]. Navegación entre Rutas con "useNavigate":
_______________________________________________________

Si no queremos crear una etiqueta de ancla "a" para navegar, podemos usar el hook "useNavigate":

    import { useNavigate } from "react-router-dom";

    const navigate = useNavigate();
    
    const handleEventItemClick = (id) => {
        navigate(`/detail/${id}`);
    };

_______________________________________________________

	[1.11.6]. Rutas Anidadas:
_______________________________________________________

Hay rutas que podemos crear para que se muestren denbtro de otro componente, como por ejemplo tabs o pestañas, estas rutas son rutas hijas de otro, o rutas anidadas.

1) Definimos en nuestro router la ruta que va a ser padre de las rutas hijas con "children":

    const router = createBrowserRouter([
        {
            path: "/",
            element: <Home />,
            errorElement: <Error404 />
        },
        {
            path: "/detail/:eventId",
            element: <Detail />,
        },
        {
            path: "/profile",
            element: <Profile />,
            children: [
                {
                    path: "my-info",
                    element: <div>My Info</div>,
                },
                {
                    path: "liked-events",
                    element: <div>Eventos Favoritos</div>,
                },
            ],
        }
    ]);

2) En el componente "Profile", usamos el "Outlet" component, para indicar en donde queremos que se rendericen las rutas hijas, qeu en este caso vendrian a ser como el contenido de unos tabs:

    import { Outlet } from "react-router-dom";

    const Profile = () => {
        return (
            <div>
                <h1>Perfil</h1>
                <Outlet />
            </div>
        );
    };

    export default Profile;

De esta forma, quedamos con 3 rutas:

    /profile --> muestra solo el componente "Profile"

    /profile/my-info --> muestra el componente "Profile" y "MyInfo"

    /profile/liked-events --> muestra el componente "Profile" y  "LikedEvents"

_______________________________________________________

	[1.12]. fetch:
_______________________________________________________

Para hacer consultas a la API, vamos a usar "fetch", pero se puede usar alguna libreria de terceros como Axios.

    fetch('http://example.com/movies.json')
        .then(response => response.json())
        .then(data => console.log(data));

"fetch" devuelve una promesa, la cual parceamos en formato JSON, para luego procesar esa nueva promesa ya parceada en JSON.

"fetch" recibe dos argumentos, el primero es la url a la que se le hace la petición, y el segundo(opcional) es donde podemos indicar otro metodo diferente a GET, credenciales y headers.

Nota: para más info de "fetch" ir a:

    https://developer.mozilla.org/es/docs/Web/API/Fetch_API/Using_Fetch

_______________________________________________________

	[1.13]. State Management:
_______________________________________________________

Un "State Management" o manejador de estados, permite tener centralizados los estados (data) de nuestra aplicación, por si hay varios componentes que requieran esa info, la consultan desde el "State Management".

Esto permite que los componentes se actualicen cuando la información que requieran se actualice.

En donde se centraliza la info lo conocemos como "Store".

Los manejadores de estado más usados en React son:

- Redux
- Zustand
- Mobx
- Recoil

_______________________________________________________

	[2]. Proyecto:
_______________________________________________________

Creación del proyecto el cual iremos construyendo la boletera con la API de ticketmaster.

API:

    https://developer.ticketmaster.com/products-and-docs/apis/discovery-api/v2/

Para registrarnos como desarrolladores:

    https://developer.ticketmaster.com/

_______________________________________________________

	[2.0]. Instalación con Vite:
_______________________________________________________

Vamos a usar Vitejs como module bundler, para generar nuestro proyecto de react.

Para usarlo es necesario tener instalado node y npm.

1) En consola usamos:

    npm create vite@latest

2) Nos va a preguntar el nombre del proyecto:

    ticketmaster-events

3) Escogemos "React" cuando pregunte por framework.

4) En "variant" podemos escoger entre typescript y javaScript, escogemos javaScript.

5) Seguimos los comandos sugeridos en consola para instalar dependencia y correr el proyecto:

    cd ticketmaster-events
    npm install
    npm run dev

_______________________________________________________

	[2.0.1]. Archivos Principales:
_______________________________________________________

El archivo principal de nuestro proyecto es "main.jsx":

    import React from 'react'
    import ReactDOM from 'react-dom/client'
    import App from './App.jsx'
    import './index.css'

    ReactDOM.createRoot(document.getElementById('root')).render(
        <React.StrictMode>
            <App />
        </React.StrictMode>,
    )

Al metodo "createRoot" le pasamos como parametro el elemento del DOM donde se va a renderizar (con id root) toda la aplicación, y le indicamos que se renderice nuestra aplicación. 
Con "StrictMode" indicamos que nos muestre warnings de rendimiento o errores en nuestra aplicación.

Despues tenemos el archivo "App.jsx", que es nuestra aplicación.

Tenemos un solo archivo HTML llamado "index.html":

    <!doctype html>
    <html lang="en">
        <head>
            <meta charset="UTF-8" />
            <link rel="icon" type="image/svg+xml" href="/vite.svg" />
            <meta name="viewport" content="width=device-width, initial-scale=1.0" />
            <title>Vite + React</title>
        </head>
        <body>
            <div id="root"></div>
            <script type="module" src="/src/main.jsx"></script>
        </body>
    </html>

Acá llamamos al archivo principal indicando que es un modulo.

_______________________________________________________

	[2.1]. Scaffolding Proyecto:
_______________________________________________________

Dentro de la carpets "src", creamos las siguientes carpetas:

    - components --> donde crearemos los componentes generales que se comparten en toda la aplicación (algunas veses llamada shared-components).
    - views --> donde va c/u de las rutas o páginas del proyecto (algunas veses llamada pages).
    - routes --> guarda c/u de las rutas o configuraciónes del enrutador del proyecto.
    - utils --> archivos con funciones de utileria, es decir que podemos importar en cualquier parte para realizar lo que necesitemos por ejemoplo llamadas a la API, etc.
    - state --> donde se hace referencia a la información global del proyecto

_______________________________________________________

	[2.2]. Creando primer componente:
_______________________________________________________

1) Dentro de la carpeta "/components", creamos una carpeta llamada "Navbar".

2) Dentro de la carpeta "/Navbar" creamos un archivo "index.jsx":

    const Navbar = () => {
        return (
            <div>
                <p>Mi Boletera</p>
                <input placeholder="Busca tu evento favorito" />
            </div>
        );
    };

    export default Navbar;

3) Importamos y usamos nuestro componente en el componente principal "App.jsx":

    import Navbar from './components/Navbar';
    import './App.css'

    function App() {

        return (
            <>
                <Navbar />
            </>
        )
    }

    export default App

_______________________________________________________

	[2.3]. Renderizado Lista Eventos:
_______________________________________________________

Como aún no consumimos información desde la API, vamos a consumir información desde en archivo JSON.

1) Creamos dentro de "/src" una carpeta llamada "/data", y adentro colocamos el archivo JSON.

Link Json:

    https://github.com/codigofacilito/ticketmaster-events-react/blob/main/src/data/events.json

2) Dentro de la carpeta "/components" creamos una nueva carpeta llamada "/Events", que alojara un componente con el mismo nombre.

3) Dentro de la carpeta "/Events", creamos un archivo "index.jsx":

    const Events = () => {

        return (
            <div>
                <p>Eventos</p>
            </div>
        );
    };

    export default Events;

4) Lo importamos y usamos desde al archivo "App.jsx":

    import Navbar from './components/Navbar';
    import Events from './components/Events';
    import './App.css'

    function App() {

        return (
            <>
            <Navbar />
            <Events />
            </>
        )
    }

    export default App

5) Dentro de la carpeta "/Events", creamos una carpeta llamada "/components", para crear allí los componentes hijos del componente "Events".

6) Dentro de "/Events/components" creamos la carpeta "/EventItem".

7) Dentro de la carpeta "/EventItem", creamos un archivo "index.jsx":

    const EventItem = () => {
        return(
            <div>
                Event ítem
            </div>
        )
    };

    export default EventItem;

8) Importamos el componente "EventItem" dentro del componente "Events":

    import EventItem from "./components/EventItem";
    import data from "../../data/events.json";

    console.log(data);

    const events = data._embedded.events;

    const Events = () => {

        return (
            <div>
                <p>Eventos</p>

                <EventItem />
            </div>
        );
    };

    export default Events;

Tambien importamos el archivo JSON con la data, y hacemos una impresión en consola para ver como viene la data.

La siguiente línea:

    const events = data._embedded.events;

La podemos cambiar por la siguiente usando "desestructuración de objetos":

    const { _embedded: {events} } = data;

9) Usamos los conocimientos de renderizado de listas para renderizar los EventItem:

    const Events = () => {

    const eventsComponent = events.map((eventItem) => <EventItem key={`event-item-${eventItem.id}`} />);

        return (
            <div>
                <p>Eventos</p>

                { eventsComponent }
            </div>
        );
    };

Acá en el método "map", devolvemos un "EventItem", indicandole el id unico en el argumento "key".

10) En "EventItem", recibimos las propiedades que se van a enviar desde el componente padre, para mostrar la información del evento:

    const EventItem = ({
        info,
        name,
        image
    }) => {
        return(
            <div>
                <img src={image} alt={name} width="200px"/>
                <h4>{name}</h4>
                <p>{info}</p>
            </div>
        )
    };

    export default EventItem;

De momento solo recibimos 3 datos del evento, el nombre, una descripción y la url de la imagen.

11) Ahora en el componente padre "Events", enviamos las propiedades al componente hijo:

    import EventItem from "./components/EventItem";
    import data from "../../data/events.json";

    console.log(data);

    const events = data._embedded.events;

    const Events = () => {

        const eventsComponent = events.map((eventItem) => (
            <EventItem 
                key={`event-item-${eventItem.id}`}
                name={eventItem.name}
                info={eventItem.info}
                image={eventItem.images[0].url}
            />
        ));

        return (
            <div>
                <p>Eventos</p>

                { eventsComponent }
            </div>
        );
    };

    export default Events;

12) La información de momento es estatica, pero podemos almacenarla en un estado, por si cambia en un futuro:

    import { useState } from "react";

    import EventItem from "./components/EventItem";
    import eventsJSON from "../../data/events.json";

    // console.log(data);

    const Events = () => {
        const [data] = useState(eventsJSON);

        const events = data._embedded.events;
        const eventsComponent = events.map((eventItem) => (
            <EventItem 
                key={`event-item-${eventItem.id}`}
                name={eventItem.name}
                info={eventItem.info}
                image={eventItem.images[0].url}
            />
        ));

        return (
            <div>
                <p>Eventos</p>

                { eventsComponent }
            </div>
        );
    };

    export default Events;

_______________________________________________________

	[2.4]. Manejando evento buscador:
_______________________________________________________

En el componente "Navbar", añadimos un manejador de eventos en el input de busqueda:

    import { useState } from "react";

    const Navbar = () => {
        const [search, setSearch] = useState('');

        const handleInputChange = (event) => {
            setSearch(event.target.value);
        };

        console.log(search);

        return (
            <div>
                <p>Mi Boletera</p>
                <input 
                    placeholder="Busca tu evento favorito"
                    onChange={handleInputChange} 
                    value={search}
                />
            </div>
        );
    };

    export default Navbar;

Para el input tambien manejamos un estado, su valor inicial lo definimos como un string vacio, o sino el estado inicial seria "undefined" y nos saldria un warning en consola.

En el atributo "value" del input le asignamos el valor de "search", y en el manejador de eventos seteamos esa propiedad con el nuevo valor ingresado, si no lo hacemos, al escribir en el input no se actualiza el valor, y es como si no escribieramos nada, no se ve.

_______________________________________________________

	[2.5]. Evento como Props:
_______________________________________________________

1) En el componente "Events", vamos a manejar el click de cada evento social, y se lo pasaremos al componente hijo a través de sus propiedades:

    import { useState } from "react";

    import EventItem from "./components/EventItem";
    import eventsJSON from "../../data/events.json";

    const Events = () => {
        const [data] = useState(eventsJSON);

        const handleEventItemClick = (id) => {
            console.log('Evento clickeado: ', id);
        };

        const events = data._embedded.events;
        const eventsComponent = events.map((eventItem) => (
            <EventItem 
                key={`event-item-${eventItem.id}`}
                name={eventItem.name}
                info={eventItem.info}
                image={eventItem.images[0].url}
                onEventClick={handleEventItemClick}
                id={eventItem.id}
            />
        ));

        return (
            <div>
                <p>Eventos</p>

                { eventsComponent }
            </div>
        );
    };

    export default Events;

La propiedad que se le pasa al componente hijo para manejar el evento click es "onEventClick".

2) En el componente hijo "EventItem" recibimos las props y asignamos al evento click la función manejadora que recibimos desde el padre:

    const EventItem = ({
        info,
        name,
        image,
        onEventClick,
        id
    }) => {
        return(
            <div>
                <img src={image} alt={name} width="200px"/>
                <h4>{name}</h4>
                <p>{info}</p>
                <button onClick={ () => onEventClick(id) }>Ver más</button>
            </div>
        )
    };

    export default EventItem;

Como la función manejadora del padre recibe como parámetro el "id", donde asignamos el evento click, le asignamos una función anonima, para que nos permita enviar el parametro, si no lo hacemos cometemos un error y se empieza a ejecutar la función manejadora sin necesidad de hacer click e infinitamente y se bloquea la aplicación.

3) Cuando tenemos una función muy larga, podemos tenerla aparte para tener más limpio el código del "return":

    const EventItem = ({
        info,
        name,
        image,
        onEventClick,
        id
    }) => {

        const handleSeeMoreClick = (event) => {
            event.stopPropagation();
            onEventClick(id);
        };

        return(
            <div onClick={ () => console.log('padre clickeado') }>
                <img src={image} alt={name} width="200px"/>
                <h4>{name}</h4>
                <p>{info}</p>
                <button onClick={ handleSeeMoreClick }>Ver más</button>
            </div>
        )
    };

    export default EventItem;

En este caso creamos la función "handleSeeMoreClick", que recibe el paramentro "event", para evitar el "event bubbling", y no se haga click tambien en el padre.

_______________________________________________________

	[2.6]. Filtrando Eventos:
_______________________________________________________

Para poder filtrar los eventos a través del input de busqueda que tenemos en el navbar, es necesario hacer una comunicación del padre de los componentes de "Navbar" y "Events", esto lo logramos gracias a las props, desde el padre obtenemos la busqueda escrita en el input del "Navbar", y luego enviamos esa busqueda al listado "Events", donde filtraremos.

1) En el componente padre "App.jsx":

    import { useState } from 'react';

    import Navbar from './components/Navbar';
    import Events from './components/Events';
    import './App.css'

    function App() {
        const [searchTerm, setSearchTerm] = useState('');

        const handleNavbarSearch = (term) => {
            setSearchTerm(term);
        };

        return (
            <>
            <Navbar onSearch={handleNavbarSearch} />
            <Events searchTerm={searchTerm} />
            </>
        )
    }

    export default App

Creamos un estado "searchTerm" con su respectivo setter. Al "Navbar", le pasamos por las props la función para setear la busqueda, y al componente "Events", se le envia esa busqueda una vez seteada en el estado "searchTerm".

2) En el componente "Navbar":

    import { useState } from "react";

    const Navbar = ({onSearch}) => {
        const [search, setSearch] = useState('');

        const handleInputChange = (event) => {
            setSearch(event.target.value);
        };

        const handleInputKeyDown = (event) => {
            if(event.key === 'Enter'){
                onSearch(search);
            }
        };

        // console.log(search);

        return (
            <div>
                <p>Mi Boletera</p>
                <input 
                    placeholder="Busca tu evento favorito"
                    onChange={handleInputChange} 
                    value={search}
                    onKeyDown={handleInputKeyDown}
                />
            </div>
        );
    };

    export default Navbar;

Acá des estructuramos de las props la función "onSearch", la cual usamos en la función que va a escuchar cuando presionamos en el teclado la tecla "Enter" para enviar la busqueda, con esto se actualiza el estado del padre.

3) Filtramos la busqueda en el componente "Events":

    const Events = ({ searchTerm }) => {
        const [data] = useState(eventsJSON);
        const events = data._embedded.events;
        
        const handleEventItemClick = (id) => {
            console.log('Evento clickeado: ', id);
        };

        const renderEvents = () => {
            let eventsFiltered = events;
            
            if(searchTerm.length > 0){
                eventsFiltered = eventsFiltered.filter((item) => item.name.toLocaleLowerCase().includes(searchTerm));
            }

            return eventsFiltered.map((eventItem) => (
                <EventItem 
                    key={`event-item-${eventItem.id}`}
                    name={eventItem.name}
                    info={eventItem.info}
                    image={eventItem.images[0].url}
                    onEventClick={handleEventItemClick}
                    id={eventItem.id}
                />
            ));
        };

        return (
            <div>
                <p>Eventos</p>

                { renderEvents() }
            </div>
        );
    };

Recibimos en las props la busqueda, para tener más limpio el return, llamamos la función "renderEvents()", encargada de filtrar y renderizar los ítems. Comprueba si existe la busqueda:

    if(searchTerm.length > 0)

Y luego utiliza la función de arrays "filter", que se usa de manera similar a la función "map". Devuelve el/los ítem(s) que incluyan en su nombre el termino de busqueda "searchTerm". En caso de no existir el termino de busqueda, devuelve todos los ítems.

_______________________________________________________

	[2.7]. Creando Hook reusable de Eventos:
_______________________________________________________

Vamos a crear un hook que nos devuelva la data de los eventos, este hook lo podremos utilizar en varios componentes.

1) Creamos una carpeta llamada "hooks" dentro de la carpeta "src".

2) Creamos el archivo "useEventsData.js":

    import { useState } from "react";

    import eventsJSON from '../data/events.json';

    const useEventsData = () => {

        const [data] = useState(eventsJSON);
        const events = data._embedded.events;

        return {
            events
        };
    };

    export default useEventsData;

En este hook extraemos el código que estabamos usando en el componente de "Events" (src\components\Events\index.jsx).

Nota: el uso de "useState", funciona porque usaremos el hook "useEventsData" en un componente de react, si no, no funcionara en una función de js normal.

3) Llamamos nuestro hook en el componente de "Events" (src\components\Events\index.jsx):

    import useEventsData from "../../hooks/useEventsData";

    import EventItem from "./components/EventItem";

    const Events = ({ searchTerm }) => {
        
        const { events } = useEventsData();

Como en el hook "useEventsData" retornamos un objeto, acá lo desestructuramos para poder hacer uso simplemente de "events".
_______________________________________________________

	[2.8]. Creando Router:
_______________________________________________________

1) Creamos nuestro componente "router", con las rutas de home, detail y sus respectivos componentes.

2) Pasamos el código de "App.jsx" al componente de "src\views\Home\index.jsx":

    import { useState, useRef } from 'react';

    import Navbar from '../../components/Navbar';
    import Events from '../../components/Events';

    const Home = () => {
        const [searchTerm, setSearchTerm] = useState('');

        const navbarRef = useRef(null);

        const handleNavbarSearch = (term) => {
            console.log("Referencia DOM navbar: ", navbarRef.current);
            setSearchTerm(term);
        };

        return (
            <>
                <Navbar onSearch={handleNavbarSearch} ref={navbarRef} />
                <Events searchTerm={searchTerm} />
            </>
        );
    };

    export default Home;

Y el archivo "App.jsx" quedaria:

    import Routes from './routes';
    import './App.css'

    function App() {
        return <Routes />
    }

    export default App;

_______________________________________________________

	[2.9]. Navegar al detalle de evento:
_______________________________________________________

1) En nuestro componente de rutas, definimos la ruta para ver el detalle del evento:

    const router = createBrowserRouter([
        {
            path: "/",
            element: <Home />,
            errorElement: <Error404 />
        },
        {
            path: "/detail/:eventId",
            element: <Detail />,
        },
    ]);

2) En el componente de listado de eventos "Events", usamos el hook "useNavigate", para navegar al detalle del evento:

    import { useNavigate } from "react-router-dom";

    const Events = ({ searchTerm }) => {
    
    const { events, isLoading, error } = useEventsData();
        const navigate = useNavigate();
        
        const handleEventItemClick = (id) => {
            console.log('Evento clickeado: ', id);
            navigate(`/detail/${id}`);
        };

_______________________________________________________

	[2.10]. fetch al API:
_______________________________________________________

1) Para registrarnos en ticketmaster podemos ir a la siguiente url:

    https://developer.ticketmaster.com/

Si no queremos registrar nuestro correo verdadero, podemos hacer uso de un correo temporal como el provisto por:

    https://10minutemail.com/?lang=es

Y en esa misma página podemos ver el mail de confirmación de cuenta enviado por ticketmaster.

2) Podemos usar "Postman" para probar nuestra apikey:

    https://app.ticketmaster.com/discovery/v2/events.json?apikey=TUAPIKEY&countryCode=ES

En este caso filtramos los eventos por código de país de españa.

Nota: Para ver la cobertura de eventos de ticketmaster, así como los parametros que podemos enviar a la API, ir a:

    https://developer.ticketmaster.com/products-and-docs/apis/discovery-api/v2/

3) Usamos la API en el hook propio "useEventsData":

    import { useState, useEffect } from "react";

    const useEventsData = () => {

        const [data, setData] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState();

        useEffect(() => {
            const fetchEvents = async() =>{
                try{
                    const response = await fetch("https://app.ticketmaster.com/discovery/v2/events.json?apikey=TUAPIKEY&countryCode=ES");
                    const data = await response.json();

                    console.log(data);
                    setData(data);
                    setIsLoading(false);
                } catch (error){
                    setError(error);
                }
            };

            fetchEvents();

        }, []);

        return {
            events: data?._embedded?.events || [],
            isLoading,
            error
        };
    };

    export default useEventsData;

_______________________________________________________

	[2.10.1]. Enviando parámetros al API:
_______________________________________________________

1) Refactorizamos el hook "useEventsData", para que no llame a la API directamente, sino que le deje la responsabilidad de hacer el llamado al componente que lo requiera:

    import { useState } from "react";

    const useEventsData = () => {

        const [data, setData] = useState([]);
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState();
        
        const fetchEvents = async() =>{
            try{
                const response = await fetch("https://app.ticketmaster.com/discovery/v2/events.json?apikey=TUAPIKEY&countryCode=ES");
                const data = await response.json();

                console.log(data);
                setData(data);
                setIsLoading(false);
            } catch (error){
                setError(error);
            }
        };

        return {
            events: data?._embedded?.events || [],
            isLoading,
            error.
            fetchEvents
        };
    };

    export default useEventsData;

2) Ahora lo modificamos para que pueda enviar parametros a la misma url:

    const fetchEvents = async(params) =>{
        try{
            const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events.json?apikey=TUAPIKEY&countryCode=ES${params?.length ? params : ''}`);

Acá usamos operador ternario, si llega algo en params, se concatena, sino se concatena un string vacio.

3) Le quitamos la responsabilidad al componente "Events" de llamar al API:

    import { useNavigate } from "react-router-dom";
    // Eliminamos la siguiente línea
    // import useEventsData from "../../hooks/useEventsData";

    import EventItem from "./components/EventItem";

    // Recibimos events desde el componente padre
    const Events = ({ searchTerm, events }) => {
        // Eliminamos la siguiente línea
        // const { events, isLoading, error } = useEventsData();
        const navigate = useNavigate();
        
        const handleEventItemClick = (id) => {
            console.log('Evento clickeado: ', id);
            navigate(`/detail/${id}`);
        };

        const renderEvents = () => {
            let eventsFiltered = events;
            
            if(searchTerm.length > 0){
                eventsFiltered = eventsFiltered.filter((item) => item.name.toLocaleLowerCase().includes(searchTerm));
            }
            // Eliminamos el siguiente codigo
            // if(error){
            //     return <div>Ha ocurrido un error</div>
            // }

            // if(isLoading){
            //     return <div>Cargando...</div>
            // }

            return eventsFiltered.map((eventItem) => (
                <EventItem 
                    key={`event-item-${eventItem.id}`}
                    name={eventItem.name}
                    info={eventItem.info}
                    image={eventItem.images[0].url}
                    onEventClick={handleEventItemClick}
                    id={eventItem.id}
                />
            ));
        };

        return (
            <div>
                <p>Eventos</p>

                { renderEvents() }
            </div>
        );
    };

    export default Events;

La responsabilidad de llamar la API se la quitamos al componente "Events", ya que si la llamamos allí, estaria llamando la API nuevamente en un "useEffect" (cuando se carga el componente) y nuevamente cuando se hace la busqueda de evento en el navbar.

4) Llamamos el hook "useEventsData" al componente del "Home":

    import { useState, useRef, useEffect } from 'react';
    import useEventsData from "../../hooks/useEventsData";

    import Navbar from '../../components/Navbar';
    import Events from '../../components/Events';

    const Home = () => {
        const [searchTerm, setSearchTerm] = useState('');

        const navbarRef = useRef(null);

        const { events, isLoading, error, fetchEvents } = useEventsData();

        useEffect(()=>{
            fetchEvents();
        },[]);

        const handleNavbarSearch = (term) => {
            console.log("Referencia DOM navbar: ", navbarRef.current);
            setSearchTerm(term);
        };

        const renderEvents = () => {
            if(isLoading){
                return <div>Cargando...</div>
            }
            
            if(error){
                return <div>Ha ocurrido un error</div>
            }

            return (
                <Events searchTerm={searchTerm} events={events} />
            );

        };

        return (
            <>
                <Navbar onSearch={handleNavbarSearch} ref={navbarRef} />
                { renderEvents() }
            </>
        );
    };

    export default Home;

Hacemos uso nuevamente del hook "useEffect", para que se cargue la data apenas se monte el componente.

Tambien creamos la función "renderEvents", para cargar el loader, el listado de eventos o el error en caso de que ocurra un problema al llamar el API.

5) Ahora al hacer la busqueda en el componente Home reutilizamos "fetchEvents()", enviandole el termino de la busqueda, para que sea enviado a la API con la URL:

    const handleNavbarSearch = (term) => {
        console.log("Referencia DOM navbar: ", navbarRef.current);
        setSearchTerm(term);
        fetchEvents(`&keyword=${term}`);
    };

_______________________________________________________

	[2.10.2]. Creando Paginación:
_______________________________________________________

Vamos a agregar una paginación para el listado de eventos, ya que por defecto la API solo nos muestra 20 eventos, y nos provee una paginación, que debemos tambien implementar en el lado front.

1) Para la paginación, instalamos la libreria "react-paginate":

    npm install react-paginate --save

Nota: para más info de la libreria "react-paginate" ir a :

    https://github.com/AdeleD/react-paginate

2) Importamos y usamos "ReactPaginate" en nuestro componente de "Home":

    import ReactPaginate from 'react-paginate';

        ...

        const { events, isLoading, error, fetchEvents, page } = useEventsData();

        const handlePageClick = ( {selected} ) => {
            console.log("Pagina seleccionada: ", selected);
            fetchEvents(`&keyword=${searchTerm}&page=${selected}`);
        };

        const renderEvents = () => {
            if(isLoading){
                return <div>Cargando...</div>
            }
            
            if(error){
                return <div>Ha ocurrido un error</div>
            }

            return (
                <div>
                    <Events searchTerm={searchTerm} events={events} />
                    <ReactPaginate
                        breakLabel="..."
                        nextLabel=">"
                        onPageChange={handlePageClick}
                        pageRangeDisplayed={5}
                        pageCount={page.totalPages}
                        previousLabel="<"
                        renderOnZeroPageCount={null}
                    />
                </div>
            );

        };

        ...

Envolvemos los eventos y el componente de paginación en un div(regla de JSX), y en el componente "ReactPaginate" le pasamos las props necesarias para su inicialización.

Para cambiar de pagina es necesario que le definamos la función "handlePageClick", en la cual desestructuramos "selected", que corresponde al numero de pagina seleccionada (contando desde 0). Y hacemos otro llamado a la API con "fetchEvents", pasandole la "keyword"(si se hizo una busqueda) y la "page"(para la nueva pagina). 

En la prop "pageCount" pasamos el total de paginas, que obtenemos desde la API, y que enviaremos en el hook "useEventsData".

Nota: Para más info de las props que recibe:

    https://github.com/AdeleD/react-paginate?tab=readme-ov-file#props

3) En el hook "useEventsData", retornamos un nuevo objeto "page", que contiene los datos de paginación que nos envia la API:

    return {
        events: data?._embedded?.events || [],
        page: data?.page || {},
        isLoading,
        error,
        fetchEvents
    };

4) La libreria "react-paginate", carece de estilos, pero cuenta con varias props en las que podemos definir las clases para sus elementos internos y así poder personalizar los estilos a gusto.

En el componente del Home, importamos el modulo CSS para el paginador, y usamos las propiedades en el compónente de paginación:

    import styles from './Home.module.css';

    ...

    <ReactPaginate
        breakLabel="..."
        nextLabel=">"
        onPageChange={handlePageClick}
        pageRangeDisplayed={5}
        pageCount={page.totalPages}
        previousLabel="<"
        renderOnZeroPageCount={null}
        className={styles.pagination}
        pageClassName={styles.pageItem}
        previousClassName={styles.previous}
        nextClassName={styles.next}
        pageLinkClassName={styles.pageLink}
        nextLinkClassName={styles.pageLink}
        previousLinkClassName={styles.pageLink}
        activeClassName={styles.active}
        disabledLinkClassName={styles.disabledLink}
    />

5) Y en nuestro modulo CSS, definimos los estilos:

    .pagination{
        padding: 0;
        list-style-type: none;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .pageItem{
        font-size: 20px;
        border: 1px solid white;
        color: white;
    }

    .pageItem:hover:not(.active){
        background-color: #ddd;
        color: black;
    }

    .pageLink{
        padding: 8px 12px;
        cursor: pointer;
        color: inherit;
    }

    .pageLink:hover{
        color: inherit;
    }

    .previous,
    .next{
        cursor: pointer;
    }

    .active{
        background-color: aqua;
    }

    .disabledLink{
        cursor: not-allowed;
    }

_______________________________________________________

	[2.10.3]. fetch en pantalla de detalle:
_______________________________________________________

Vamos a usar nuevamente "fetch" en la pantalla de detalle para pedir la info de un solo evento, como solo se va a usar aquí no es necesario crear un hook como se hizo para obtener todos los eventos.

1) importamos "useEffect", para hacer el "fetch" apenas se monte el componente:

    import { useEffect, useState } from "react";
    import { useParams } from "react-router-dom";

    const Detail = () => {
        const { eventId } = useParams();

        const [eventData, setEventData] = useState();
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState({});

        useEffect(() => {
            const fetchEventData = async() =>{
                try{
                    const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events/${eventId}.json?apikey=TUAPIKEY`);

                    const data = await response.json();

                    console.log("Data evento: ", data);
                    setEventData(data);
                    setIsLoading(false);
                } catch(error){
                    setEventData({});
                    setError(error);
                    setIsLoading(false);
                }
            };

            fetchEventData();
        },[]);


        console.log("Id del evento: ", eventId);

        return (
            <div>Detail</div>
        );
    };

    export default Detail;

Tambien usamos "useState" para guardar en el componente la info del evento, el error en caso de que ocurra y un "isLoading", para indicar que se esta cargando información.

Nota: Para obtener solo la data de un evento en el "fetch" revisamos la documentación de la API:

    https://developer.ticketmaster.com/products-and-docs/apis/discovery-api/v2/#anchor_get

_______________________________________________________

	[2.10.3.1]. Manejo de fechas en pantalla de detalle:
_______________________________________________________

Vamos a completar la pantalla de detalle, y a usar una libreria para el manejo de fechas llamada "date-fns".

Nota: para más info de la libreria ir a:

    https://date-fns.org/

1) Primero completamos el "isLoading" y el "error", antes de mostrar la info del componente:

    if(isLoading && Object.keys(eventData) === 0){
        return <div>Cargando evento...</div>
    }

    if(Object.keys(error) > 0){
        return <div>Ha ocurrido un error</div>
    }

    return (
        <div>Detail</div>
    );

Utilizamos "Object.keys"", ya que en este caso manejamos esas variables como objetos.

2) Instalamos la libreria para fechas "date-fns":

    npm i --save date-fns

3) Usamos la libreria "date-fns" importando la función "format" en nuestro componente de detalle:

    import { useEffect, useState } from "react";
    import { useParams } from "react-router-dom";
    import { format } from "date-fns";
    import { es } from "date-fns/locale";

    import styles from './Detail.module.css';

    const Detail = () => {
        const { eventId } = useParams();

        const [eventData, setEventData] = useState({});
        const [isLoading, setIsLoading] = useState(true);
        const [error, setError] = useState({});

        useEffect(() => {
            const fetchEventData = async() =>{
                try{
                    const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events/${eventId}.json?apikey=TUAPIKEY`);

                    const data = await response.json();

                    console.log("Data evento: ", data);
                    setEventData(data);
                    setIsLoading(false);
                } catch(error){
                    setEventData({});
                    setError(error);
                    setIsLoading(false);
                }
            };

            fetchEventData();
        },[]);

        if(isLoading && Object.keys(eventData) === 0){
            return <div>Cargando evento...</div>
        }

        if(Object.keys(error) > 0){
            return <div>Ha ocurrido un error</div>
        }

        // console.log("Id del evento: ", eventId);

        return (
            <div className={styles.detailContainer}>
                <div className={styles.detailInfo}>
                    <img className={styles.detailImage} src={eventData.images?.[4].url} alt={eventData.name} />
                    <h1 className={styles.detailTitle}>
                        {eventData.name}
                    </h1>
                    <p className={styles.detailDesc}>
                        {eventData.info}
                    </p>
                    {eventData.dates?.start.dateTime ? <p className={styles.detailDate}>
                        <strong>Fecha del evento: </strong> { format(new Date(eventData.dates?.start.dateTime), "EEEE d 'de ' LLLL yyyy 'Hora ' h:mm aaa", {locale : es}) }
                    </p> : null}
                </div>

                <div className={styles.detailSeatContainer}>
                    <h2 className={styles.detailSeatTitle}>
                        Ubicación:
                    </h2>
                    <img className={styles.detailSeatImage} src={eventData.seatmap?.staticUrl} alt="Mapa de la ubicación" />
                    <p>{eventData.pleaseNote}</p>
                    <p><strong>Precios:</strong> Desde {eventData.priceRanges?.[0].min} hasta {eventData.priceRanges?.[0].max} {eventData.priceRanges?.[0].currency}</p>
                </div>

                <a className={styles.detailCall} href={eventData.url} target="_blank">Ir por tus boletas</a>
            </div>
        );
    };

    export default Detail;

La función "format" recibe 3 parametros, la fecha, el formato que queremos que nos muestre y el tercer parametro(opcional) el "locale" para traducir el día, o mes si se da en letras.

Nota: para más info de los formatos de fecha y hora ir a:

    https://date-fns.org/v4.1.0/docs/format

Cuando mostramos la fecha, primero evaluamosq ue exista "eventData.dates?.start.dateTime" antes de intentar crear con javaScript y formatear la fecha.

Tambien usamos en la obtención de las imagenes, fecha y precio, el "conditional chaining" (?), por si no nos llegan los datos, que no genere errores.

_______________________________________________________

	[2.10.4]. Variables de Entorno:
_______________________________________________________

Para no exponer datos sensibles como la "apikey", vamos a crear y usar variables de entorno.

1) En la raíz del proyecto creamos un archivo ".env":

    VITE_TICKETMASTER_API_KEY=TUAPIKEY

Nota: es necesario el prefijo "VITE", para que "Vite" nos permita leer la variable de entorno y no nos aparezca un error de cors en consola.

2) En los hooks o componentes donde usemos la "apikey", obtenemos y usamos la variable de entorno creada:

    const apikey = import.meta.env.VITE_TICKETMASTER_API_KEY;

    console.log("Variables de entorno: ", import.meta.env)

    const useEventsData = () => {

        ...
        
        const fetchEvents = async(params) =>{
            try{
                const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events.json?apikey=${apikey}&countryCode=MX${params?.length ? params : ''}`);
                const data = await response.json();

_______________________________________________________

	[2.11]. Implementando State Management Zustand:
_______________________________________________________

Vamos a implementar Zustand como "State Management", a diferencia de Redux, que centraliza toda la información en un solo "store", Zustand puede crear mini stores, para tener disponibles solo la info que se necesita, es decir, si unos componentes usan un store, y otros componentes otro, pueden haber N stores y no hay problema.

1) Instalamos "Zustand":

    npm i --save zustand

2) Dentro de "/src", creamos una carpeta llamada "state", y dentro un archivo "events-results.js":

    import { create } from "zustand";
    const apikey = import.meta.env.VITE_TICKETMASTER_API_KEY;

    const useEventsResults = create( (set) => ({
        data: [],
        error: null,
        isLoading: false,
        fetchEvents: async(params) =>{
            try{
                await set(() => ({ isLoading: true }));

                const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events.json?apikey=${apikey}&countryCode=MX${params?.length ? params : ''}`);
                const data = await response.json();

                await set(() => ({ data, isLoading: false }));
            } catch (error){
                await set(() => ({ error }));
            }
        },
    }) );

    export default useEventsResults;


La forma en como definmimos el store de Zustand es como un hook, igual que el que ya se habia definido "useEventsData", pero a diferencia de ese, no gurda la data a nivel local(componente) sino global (toda la app).

"create" recibe como parametro una función flecha que recibe "set" y retorna un objeto con toda la información y/o funciones que vamos a usar en los componentes.

El componente que usa nuestro "store" se inscribe a él, y cada vez que cambie la data en el "store", se actualiza el componente.

En este caso, lo que hicimos fue crear un "store" para tener disponible globalmente:

    - la data de los eventos.
    - isLoading
    - error del fetch
    - la acción "fetchEvents"

Por lo que el hook creado anteriormente "useEventsData", ya no lo usaremos más.

En la función "fetchEvents", para setear la "data", el "isLoading" y el "error", usamos ahora la función "set", que recibe una función flecha que retorna los objetos con las variables a setear.

3) En el componente "Home", importamos y usamos el "store" creado:

    import useEventsResults from '../../state/events-results';

    const Home = () => {

        const { data, isLoading, error, fetchEvents} = useEventsResults();
        const events = data?._embedded?.events || [];
        const page = data?.page || {};

Nota: es probable que el componente del paginador deje de funcionar mostrando siempre que estamos en la pág. #1, para corregir esto, creamos el siguiente estado en el componente "Home":

    const [pageOffset, setPageOffset] = useState(0);

    ...

    const handlePageClick = ( {selected} ) => {
        console.log("Pagina seleccionada: ", selected);
        setPageOffset(selected);
        fetchEvents(`&keyword=${searchTerm}&page=${selected}`);
    };

    ...

    return (
        <div>
            <Events searchTerm={searchTerm} events={events} />
            <ReactPaginate
                breakLabel="..."
                nextLabel=">"
                onPageChange={handlePageClick}
                pageRangeDisplayed={5}
                pageCount={Math.ceil(page.totalPages)}
                previousLabel="<"
                renderOnZeroPageCount={null}
                className={styles.pagination}
                pageClassName={styles.pageItem}
                previousClassName={styles.previous}
                nextClassName={styles.next}
                pageLinkClassName={styles.pageLink}
                nextLinkClassName={styles.pageLink}
                previousLinkClassName={styles.pageLink}
                activeClassName={styles.active}
                disabledLinkClassName={styles.disabledLink}
                forcePage={pageOffset}
                marginPagesDisplayed={1}
            />
        </div>
    );

Con la prop "forcePage={pageOffset}" forzamos al paginador a que muestre la pagina en la que estamos.

_______________________________________________________

	[2.12]. Agregando ícono de like y unlike a los eventos:
_______________________________________________________

Vamos a añadir la funcionalidad para poderle darle like o unlike a un evento.

1) En el componente "EventItem", añadimos el icono de un corazón vacio sobre la imagen (dar estilos).

Nota: el icono lo podemos extraer de:

    https://heroicons.com/outline

Tambien los podemos instalar y usar como un componente de React.

    npm install @heroicons/react --save

Luego para usarlo:

    import { HeartIcon } from '@heroicons/react/24/outline'

    <div className={styles.eventItemImageContainer}>
        <img src={image} alt={name} width="200px"/>
        <HeartIcon className={styles.eventItemHearth} />
    </div>

Nota 1: para más info de como usar los iconos: 

    https://github.com/tailwindlabs/heroicons?tab=readme-ov-file#react

Nota 2: si usamos un archivo estatico, que este ubicado en "src\assets", podemos importarlo en el compomnente y usarlo así:

    import HearthOutline from '../../../../assets/icons/hearth-outline.svg';
    
    <img src={HearthOutline} alt="Icono Corazon vacio"/>

2) Creamos un nuevo hook llamado "useLikeEvents.js":

    import { useState } from "react";

    // Key del localStorage
    const LIKED_EVENTS_STORAGE_KEY = 'likedEvents';

    const checkIsEventLiked = (eventId) => {
        const likedEvents = JSON.parse(localStorage.getItem(LIKED_EVENTS_STORAGE_KEY) ) || [];

        console.log("Eventos con 'Me gusta': ", likedEvents);

        return likedEvents.includes(eventId);
    };

    const useLikeEvents = (eventId) => {
        const [isEventLiked, setIsEventLiked] = useState(checkIsEventLiked(eventId));

        const toggleEventLike = () => {
            const likedEvents = JSON.parse(localStorage.getItem(LIKED_EVENTS_STORAGE_KEY) ) || [];
            const eventIndex = likedEvents.indexOf(eventId);

            // si existe
            if(eventIndex !== -1){
                // quitar evento del array
                likedEvents.splice(eventIndex, 1);
                setIsEventLiked(false);
            }else {
                // si no existe se añade al array
                likedEvents.push(eventId);
                setIsEventLiked(true);
            }

            localStorage.setItem(LIKED_EVENTS_STORAGE_KEY, JSON.stringify(likedEvents) );
        };

        return {
            isEventLiked,
            toggleEventLike,
        };
    };

    export default useLikeEvents;

Primero creamos una constante llamada "LIKED_EVENTS_STORAGE_KEY", para almacenar el key que vamos a usar en "localStorage" y si se necesita cambiar, solo cambiamos el valor de esta constante, en este caso el key es "likedEvents".

El hook "useLikeEvents", recibe como parametro el "eventId". Luego creamos un estado "isEventLiked" con su respectivo setter, este "state", como valor inicial va a tener lo que nos devuelva la función "checkIsEventLiked".

La función "checkIsEventLiked" se crea por fuera del hook, para que no se re-cree. Esta función recibe el "eventId", obtiene la key del "localStorage", que es un "string", y la convierte a "array" con "JSON.parse". Si no encuentra la clave, le asigna un "array" vacio a "likedEvents";

Con la función "includes", verificamos si en el array existe el evento, si llega a existir devuelve un "true", sino "false".

Volviendo al hook "useLikeEvents", este devuelve "isEventLiked" y la función "toggleEventLike".

La función "toggleEventLike", primero obtiene la key del "localStorage" con los eventos likeados, y los almacena en un "array"(el mismo proceso que se hace al principio de la función "checkIsEventLiked"). Luego buscamos el indice del evento en el array.

Si el indice existe("eventIndex" !== -1 ), quitamos el evento del array, e indicamos que es un evento "unliked" con "setIsEventLiked(false)";

Si el indice no existe, se añade al "array", y luego indicamos que es un evento con "like".

Luego almacenamos en el key del "localStorage" el array convertido en "string" con "JSON.stringify".

3) Usamos el hook creado "useLikeEvents" en el componente "EventItem":

    import useLikeEvents from '../../../../hooks/useLikeEvents';

    ...

    const { isEventLiked, toggleEventLike } = useLikeEvents(id);

    const handleHearthClick = (event) => {
        event.stopPropagation();
        toggleEventLike();
    };

    return(
        <div onClick={ () => console.log('padre clickeado') } className={styles.eventItemContainer}>
            <div className={styles.eventItemImageContainer}>
                <img src={image} alt={name} width="200px"/>
                <HeartIcon className={`${styles.eventItemHearth} ${isEventLiked ? styles.eventItemHearthFilled : '' }`} onClick={handleHearthClick} />
                
            </div>

Acá, desestructuramos "isEventLiked" y la función "toggleEventLike" del hook, pasando el "id" del evento.

En el corazón, escuchamos el "click", y llamamos a la función "handleHearthClick", que a su vez llama la función "toggleEventLike", dandole "like" o "unlike" al evento.

En este caso para llenar de color el corazón, usamos en la "className" un operador ternario, que verifica con "isEventLiked" si le añade la clase "eventItemHearthFilled" o no.

Este estilo lo definimos en el modulo CSS:

    .eventItemImageContainer{
        position: relative;
    }

    .eventItemHearth{
        width: 24px;
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1;
        cursor: pointer;
        stroke: magenta;
    }

    .eventItemHearth.eventItemHearthFilled{
        fill: deepskyblue;
    }

Ya al probar en el navegador, haciendo uso de "localStorage" podemos darle "like" o "unlike" a los eventos.

_______________________________________________________

	[2.13]. Sub-componentes de Perfil:
_______________________________________________________

Vamos a crear componentes para mostrar la información del usuario y los eventos con "me gusta" del usuario.

1) Creamos en el "Navbar" el enlace hacia la pestaña de "My Info" en el perfil:

    import { Link } from "react-router-dom";
    import { UserIcon } from "@heroicons/react/24/solid";

    <Link to='/profile/my-info' style={{
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        border: '1px solid white',
        width: '35px',
        height: '35px',
        borderRadius: '50%',
        color: 'white'
    }}>
        
        <UserIcon style={{width:'20px'}} />
        
    </Link>

2) Dentro de la carpeta del componente "src\views\Profile" creamos la carpeta "/components" y dentro de esta las sub-carpetas "Likedevents" y "MyInfo", con sus respectivos archivos de componentes:

    const MyInfo = () => {
        return (
            <div>My Info</div>
        );
    };

    export default MyInfo;

Y para los eventos con "Me gusta":

    const LikedEvents = () => {
        return (
            <div>Eventos Favoritos</div>
        );
    };

    export default LikedEvents;

3) Importamos y usamos los nuevos componentes en el "router":

    import MyInfo from "../views/Profile/components/MyInfo";
    import LikedEvents from "../views/Profile/components/LikedEvents";

    ...

    {
        path: "/profile",
        element: <Profile />,
        children: [
            {
                path: "my-info",
                element: <MyInfo />,
            },
            {
                path: "liked-events",
                element: <LikedEvents />,
            },
        ],
    }

_______________________________________________________

	[2.13.1]. Creando tabs:
_______________________________________________________

Para tener tabs dentro del componente de "Profile", que muestren los contenidos correspondientes a "MyInfo" y "Likedevents":

1) Dentro del componente "Profile":

    import { Link, Outlet, useLocation } from "react-router-dom";
    import styles from './Profile.module.css';
    import { HomeIcon } from "@heroicons/react/24/solid";

    const Profile = () => {
        const { pathname } = useLocation();

        return (
            <div>
                <header className={styles.profileHeader}>
                    <h1 className={styles.profileHeaderTitle}>Perfil</h1>
                    <Link className={styles.profileHeaderLinkHome} to='/'>
                        <HomeIcon className={styles.profileIconHome}/>
                    </Link>
                </header>
                <nav className={styles.profileTabsContainer}>
                    <ul className={styles.profileTabsUl}>
                        <li className={`${styles.profileTabItem} ${pathname.includes('my-info') ? styles.profileTabActive : ''}`}>
                            <Link to='my-info' className={styles.profileTabItemLink}>
                                Mi Información
                            </Link>
                        </li>
                        <li className={`${styles.profileTabItem} ${pathname.includes('liked-events') ? styles.profileTabActive : ''}`}>
                            <Link to='liked-events' className={styles.profileTabItemLink}>
                                Eventos Favoritos
                            </Link>
                        </li>
                    </ul>
                </nav>
                <Outlet />
            </div>
        );
    };

    export default Profile;

Importamos el "Link" y "useLocation" de "react-router-dom" para la navegación.

Desestructuramos "pathname' de "useLocation", fuera del componente "Outlet", creamos los tabs, ya que en el outlet se cargan los contenidos de forma dinámica.

Con "pathname.includes()" revisamos cual es el path en el que estamos, para añadir la clase activa "profileTabActive" a los tabs y setear estilos.

Nota: En vez de usar "Link", tambien podemos realizar la navegación con "useNavigate":

    import { Outlet, useLocation, useNavigate } from "react-router-dom";

    const handleTabClick = (path) => {
        navigate(`/profile/${path}`);
    };

    ...

    <span className={styles.profileTabItemLink} onClick={()=> handleTabClick('my-info')}>
        Mi Información
    </span>

_______________________________________________________

	[2.13.1.1]. Formulario Información Usuario:
_______________________________________________________

En el componente "MyInfo", creamos un formulario que guardara y obtendra los datos del usuario desde el "localStorage":

    import { useForm } from "react-hook-form";
    import { ErrorMessage } from "@hookform/error-message";
    import { useEffect, useState } from "react";

    import styles from "./MyInfo.module.css";

    import { ArrowPathIcon } from "@heroicons/react/24/outline";
    import { ArchiveBoxArrowDownIcon } from "@heroicons/react/24/solid";

    const USER_DATA_STORAGE_KEY = "userData";

    const isObjectEmpty = (objectName) => {
    return (
        objectName && Object.keys(objectName).length === 0 && objectName.constructor === Object
    );
    };

    const MyInfo = () => {
        const {
            register,
            handleSubmit,
            formState: { errors },
            setValue,
        } = useForm();

        const [isUpdateData, setIsUpdateData] = useState(false);

        useEffect(() => {
            try {
            const userData = JSON.parse(localStorage.getItem(USER_DATA_STORAGE_KEY)) || {};

            setIsUpdateData(!isObjectEmpty(userData));
                
            setValue("name", userData?.name);
            setValue("age", userData?.age);
            setValue("email", userData?.email);
            } catch (error) {
            console.error("Ha ocurrido un error: ", error);
            }
        }, []);

        const handleFormSubmit = (data) => {
            console.log("submit:", data);
            try {
            localStorage.setItem(USER_DATA_STORAGE_KEY, JSON.stringify(data));
            console.log("Info de usuario actualizada");
            setIsUpdateData(!isObjectEmpty(data));
            } catch (error) {
            console.error("Ha ocurrido un error: ", error);
            }
        };

        return (
            <form
            className={styles.userInfoform}
            onSubmit={handleSubmit(handleFormSubmit)}
            >
            <div className={styles.formField}>
                <label className={styles.formLabel}>
                Nombre
                <input
                    {...register("name", {
                    required: { value: true, message: "Este campo es requerido." },
                    minLength: {
                        value: 1,
                        message: "Minimo un caracter.",
                    },
                    maxLength: {
                        value: 256,
                        message: "Maximo 256 caracteres.",
                    },
                    })}
                    className={styles.forminput}
                    type="text"
                />
                <ErrorMessage
                    errors={errors}
                    name="name"
                    render={({ message }) => (
                    <p className={styles.formError}>{message}</p>
                    )}
                />
                </label>
            </div>
            <div className={styles.formField}>
                <label className={styles.formLabel}>
                Edad
                <input
                    {...register("age", {
                    required: {
                        value: true,
                        message: "Este campo es requerido.",
                    },
                    min: {
                        value: 1,
                        message: "Edad minima 1 año.",
                    },
                    max: {
                        value: 110,
                        message: "Edad máxima 110 años.",
                    },
                    valueAsNumber: true,
                    })}
                    className={styles.forminput}
                    type="number"
                />
                <ErrorMessage
                    errors={errors}
                    name="age"
                    render={({ message }) => (
                    <p className={styles.formError}>{message}</p>
                    )}
                />
                </label>
            </div>
            <div className={styles.formField}>
                <label className={styles.formLabel}>
                Email
                <input
                    {...register("email", {
                    required: { value: true, message: "Este campo es requerido." },
                    })}
                    className={styles.forminput}
                    type="email"
                />
                <ErrorMessage
                    errors={errors}
                    name="name"
                    render={({ message }) => (
                    <p className={styles.formError}>{message}</p>
                    )}
                />
                </label>
            </div>
            <div className={styles.formActions}>
                <button type="submit" className={styles.formSubmit}>
                {isUpdateData ? (
                    <>
                    <ArrowPathIcon className={styles.formSubmitIcon} /> Actualizar
                    </>
                ) : (
                    <>
                    <ArchiveBoxArrowDownIcon className={styles.formSubmitIcon} /> 
                    Guardar
                    </>
                )}
                </button>
            </div>
            </form>
        );
    };

    export default MyInfo;

Aca instalamos el componente "ErrorMessage", usamos "useEffect" para montar los datos(si existen) en los campos recien se inicialice el componente. Para setear los valores en los campos usamos "setValue" de "useForm()".

_______________________________________________________

	[2.13.1.2]. Eventos favoritos:
_______________________________________________________

El componente "LikedEvents", tendra el contenido de la pestaña "Eventos favoritos" del perfil:

    import { useEffect, useState } from "react";
    import { useNavigate } from "react-router-dom";

    // Key del localStorage
    import { LIKED_EVENTS_STORAGE_KEY } from '../../../../utils/constants';

    const apikey = import.meta.env.VITE_TICKETMASTER_API_KEY;

    import EventItem from "../../../../components/Events/components/EventItem";

    const LikedEvents = () => {

        const [events, setEvents] = useState([]);
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState({});
        const navigate = useNavigate();

        useEffect(()=>{
            const fetchEventsDetail = async () => {
                try {
                    setIsLoading(true);
                    const likedEvents = JSON.parse( localStorage.getItem(LIKED_EVENTS_STORAGE_KEY) ) || [];
                    // console.log("likedEvents: ", likedEvents);
                    const results = [];
                    for(const eventId of likedEvents){
                        // Pedimos a la API la data del evento
                        const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events/${eventId}.json?apikey=${apikey}`);

                        const data = await response.json();
                        console.log("Data evento:", data);
                        // Vamos armando el array donde cada ítem es un objeto con la data del evento
                        results.push(data);
                    }
                    // Guardamos en el estado local el array con la data de los eventos
                    setEvents(results);
                } catch(error){
                    setError(error);
                } finally{
                    setIsLoading(false);
                }
            };

            fetchEventsDetail();
        },[]);

        const handleEventItemClick = (eventId) => {
            navigate(`/detail/${eventId}`);
        };

        if(isLoading){
            return <div>Cargando...</div>
        }
        
        if(Object.keys(error).length > 0){
            return <div>Ha ocurrido un error</div>
        }

        return (
            <div>
                { events.length <= 0 ? (
                    <div>Aún no has añadido ningún evento a favoritos.</div>
                ) : (
                        events.map((event, index) => (
                            <EventItem 
                                key={`liked-event-item-${event.id}-${index}`}
                                name={event.name}
                                info={event.info}
                                image={event.images[0].url}
                                onEventClick={handleEventItemClick}
                                id={event.id}
                            />
                        ))
                    )
                }
            </div>
        );
    };

    export default LikedEvents;

Aca realizamos los siguientes pasos:

1) Para crear el listado de los eventos con "Me gusta", debemos obtenerlos apenas se monta el componente, por lo que vamos a usar el hook "useEffect".

2) Dentro del hook "useEffect", creamos y llamamos la función asincrona "fetchEventsDetail", encargada de obtener del "localStorage" el array con los "ids" de los eventos con "Me gusta".

Como vamos a obtener una llave del "localStorage", que ya habiamos usado en el hook "src\hooks\useLikeEvents.js", lo mejor es crear una carpeta llamada "utils", y allí crear las funciones y constantes que se van a re-utilizar en la app. En este caso seria el archivo "constants.js":

    export const LIKED_EVENTS_STORAGE_KEY = 'likedEvents';
    
3) Una vez obtenidos los eventos del "localStorage", creamos un ciclo "for of", para iterar por cada evento likeado, y obtenemos los datos de ese evento directamente desde la API con "fetch":

    const results = [];
    for(const eventId of likedEvents){
        // Pedimos a la API la data del evento
        const response = await fetch(`https://app.ticketmaster.com/discovery/v2/events/${eventId}.json?apikey=${apikey}`);

        const data = await response.json();
        // Vamos armando el array donde cada ítem es un objeto con la data del evento
        results.push(data);
    }
    // Guardamos en el estado local el array con la data de los eventos
    setEvents(results);

4) Al igual que habiamos hecho antes en otros componentes manejamos 3 eestados locales:

    const [events, setEvents] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState({});

Estos estados nos ayudaran a mostrar el mensaje de error, el mensaje de "cargando" o el listado de eventos.

5) Con operador ternario mostramos un mensaje si no hay eventos favoritos, o el listado de eventos favoritos usando el componnete "EventItem":

    <div>
        { events.length <= 0 ? (
            <div>Aún no has añadido ningún evento a favoritos.</div>
        ) : (
                events.map((event, index) => (
                    <EventItem 
                        key={`liked-event-item-${event.id}-${index}`}
                        name={event.name}
                        info={event.info}
                        image={event.images[0].url}
                        onEventClick={handleEventItemClick}
                        id={event.id}
                    />
                ))
            )
        }
    </div>

Nota: En la función flecha de la función "map", estamos usando un retorno"implícito", es decir que al usar paréntesis () después de la flecha =>, todo el contenido dentro de los paréntesis se retorna automáticamente.

Es útil cuando necesitas devolver JSX directamente sin lógica adicional.